/*
===========================================
Do not modify, this script is generated
===========================================
*/

/*!
\addtogroup Weapon
\{
*/

class BaseWeaponManagerComponentClass: GameComponentClass
{
}

class BaseWeaponManagerComponent: GameComponent
{
	ref ScriptInvoker<BaseWeaponComponent> m_OnWeaponChangeCompleteInvoker = new ScriptInvoker<BaseWeaponComponent>();
	ref ScriptInvoker<BaseWeaponComponent> m_OnWeaponChangeStartedInvoker = new ScriptInvoker<BaseWeaponComponent>();

	proto external IEntity GetOwner();
	//! performs throwing
	proto external void Throw(vector vDirection, float fSpeedScale);
	proto external int GetDefaultWeaponIndex();
	//! Returns currently selected weapon or null if none. (This can either be a weapon component directly or a slot component.)
	proto external BaseWeaponComponent GetCurrent();
	proto external BaseWeaponComponent GetCurrentWeapon();
	proto external BaseWeaponComponent GetCurrentGrenade();
	proto external WeaponSlotComponent GetCurrentSlot();
	proto external GrenadeSlotComponent GetCurrentGrenadeSlot();
	proto external SightsComponent GetCurrentSights();
	proto external int GetCurrentSightsIndex();
	/*!
	Select the weapon passed by the parameter. Returns true if the weapon has been selected.
	*IMPORTANT* This is not synchronized in multiplayer, it will only replicate during streams-in correctly. You will need to implement your RPC to send this command to every client.
	*/
	proto external bool SelectWeapon(BaseWeaponComponent weapon);
	//! Returns the old weapon entity of the specified weapon slot
	proto external IEntity SetSlotWeapon(WeaponSlotComponent pSlot, IEntity pWeaponEntity);
	//! weapons visibility
	proto external void SetVisibleAllWeapons(bool state);
	proto external void SetVisibleCurrentWeapon(bool state);
	/*!
	Returns the list of slots.
	\param outSlots The array where all slots will be inserted.
	\return The number of slots in the list
	*/
	proto external int GetWeaponsSlots(out notnull array<WeaponSlotComponent> outSlots);
	/*!
	Returns the list of weapons.
	\param outWeapons The array where all weapons will be inserted.
	\return The number of weapons in the list
	*/
	proto external int GetWeaponsList(out notnull array<IEntity> outWeapons);
	//! Returns true if current weapon is valid and outputs current weapon's muzzle transformation to the given matrix.
	proto external bool GetCurrentMuzzleTransform(vector outMatrix[4]);
	//! Returns true if current weapon is valid and has some sights data, outputs sights transformation and fov
	proto bool GetCurrentSightsTransform(out vector outWorldMatrix[4], out vector outLocalMatrix[4], out float fov);
	//! Returns true if current weapon is valid and has some sights data, outputs local sights transformation with adjusted roll angle and fov
	proto bool GetCurrentSightsCameraTransform(out vector outLocalMatrix[4], out float fov);

	// callbacks

	event protected void OnWeaponChangeComplete(BaseWeaponComponent newWeaponSlot) { m_OnWeaponChangeCompleteInvoker.Invoke(newWeaponSlot); };
	event protected void OnWeaponChangeStarted(BaseWeaponComponent newWeaponSlot) { m_OnWeaponChangeStartedInvoker.Invoke(newWeaponSlot); };
}

/*!
\}
*/

/*
===========================================
Do not modify, this script is generated
===========================================
*/

/*!
\addtogroup Weapon
\{
*/

class CharacterWeaponManagerComponentClass: BaseWeaponManagerComponentClass
{
}

//! Uses CharacterHandWeaponSlotComponent, and switch weapon to this slot when taken into hand
class CharacterWeaponManagerComponent: BaseWeaponManagerComponent
{
}

/*!
\}
*/

class SCR_PlayerControllerClass : PlayerControllerClass
{
}

//------------------------------------------------------------------------------------------------
void OnControlledEntityChangedPlayerController(IEntity from, IEntity to);
typedef func OnControlledEntityChangedPlayerController;
typedef ScriptInvokerBase<OnControlledEntityChangedPlayerController> OnControlledEntityChangedPlayerControllerInvoker;

//------------------------------------------------------------------------------------------------
void OwnershipChangedDelegate(bool isChanging, bool becameOwner);
typedef func OwnershipChangedDelegate;
typedef ScriptInvokerBase<OwnershipChangedDelegate> OnOwnershipChangedInvoker;

//------------------------------------------------------------------------------------------------
void OnDestroyedPlayerController(Instigator killer, IEntity killerEntity);
typedef func OnDestroyedPlayerController;
typedef ScriptInvokerBase<OnDestroyedPlayerController> OnDestroyedPlayerControllerInvoker;

//------------------------------------------------------------------------------------------------
void OnPossessed(IEntity entity);
typedef func OnPossessed;
typedef ScriptInvokerBase<OnPossessed> OnPossessedInvoker;

//------------------------------------------------------------------------------------------------
void OnBeforePossessed(IEntity entity);
typedef func OnBeforePossessed;
typedef ScriptInvokerBase<OnBeforePossessed> OnBeforePossessedInvoker;

class SCR_PlayerController : PlayerController
{
	static PlayerController s_pLocalPlayerController;
	protected static const float WALK_SPEED = 0.5;
	protected static const float FOCUS_ACTIVATION = 0.1;
	protected static const float FOCUS_DEACTIVATION = 0.05;
	protected static const float FOCUS_TIMEOUT = 0.3;
	protected static const float FOCUS_TOLERANCE = 0.005;
	protected static const float FOCUS_ANALOGUE_SCALE = 3.0;
	protected static float s_fADSFocus = 0.5;
	protected static float s_fPIPFocus = 1;
	protected static float s_fFocusTimeout;
	protected static float s_fFocusAnalogue;
	protected static bool s_bWasADS;

	protected CharacterControllerComponent m_CharacterController;
	protected bool m_bIsLocalPlayerController;
	protected bool m_bIsPaused;
	bool m_bRetain3PV;
	protected bool m_bGadgetFocus;
	protected SCR_EFocusToggleMode m_eFocusToggle;
	protected float m_fCharacterSpeed;


	[RplProp(onRplName: "OnRplMainEntityFromID")]
	protected RplId m_MainEntityID;
	protected IEntity m_MainEntity;

	[RplProp()]
	protected bool m_bIsPossessing;

	ref OnBeforePossessedInvoker m_OnBeforePossess = new OnBeforePossessedInvoker();		// Before an entity becomes possesed.
	ref OnPossessedInvoker m_OnPossessed = new OnPossessedInvoker();		// when entity becomes possessed or control returns to the main entity
	ref OnControlledEntityChangedPlayerControllerInvoker m_OnControlledEntityChanged = new OnControlledEntityChangedPlayerControllerInvoker();
	ref OnDestroyedPlayerControllerInvoker m_OnDestroyed = new OnDestroyedPlayerControllerInvoker();		// main entity is destroyed
	ref OnOwnershipChangedInvoker m_OnOwnershipChangedInvoker = new OnOwnershipChangedInvoker();
	//------------------------------------------------------------------------------------------------
	/*!
		\see PlayerController.OnOwnershipChanged for more information.
	*/
	OnOwnershipChangedInvoker GetOnOwnershipChangedInvoker()
	{
		return m_OnOwnershipChangedInvoker;
	}

	//------------------------------------------------------------------------------------------------
	/*!
		\see PlayerController.OnOwnershipChanged for more information.
	*/
	protected override void OnOwnershipChanged(bool changing, bool becameOwner)
	{
		super.OnOwnershipChanged(changing, becameOwner);
		
		if (becameOwner)
		{
			SocialComponent socialComp = SocialComponent.Cast(FindComponent(SocialComponent));
			if (socialComp)
				socialComp.m_OnBlockedPlayerJoinedInvoker.Insert(OnBlockedPlayerJoined);
			
			if (!changing)
			{
				SCR_EditorManagerCore managerCore = SCR_EditorManagerCore.Cast(SCR_EditorManagerCore.GetInstance(SCR_EditorManagerCore));
				managerCore.Event_OnEditorManagerInitOwner.Insert(OnPlayerRegistered);
			}
		}			
		
		m_OnOwnershipChangedInvoker.Invoke(changing, becameOwner);
	}

	//------------------------------------------------------------------------------------------------
	void OnPlayerRegistered(SCR_EditorManagerEntity managerEntity)
	{
		SCR_EditorManagerCore managerCore = SCR_EditorManagerCore.Cast(SCR_EditorManagerCore.GetInstance(SCR_EditorManagerCore));
		managerCore.Event_OnEditorManagerInitOwner.Remove(OnPlayerRegistered);

		// Wait for blocklist to be updated by SocialComponent.
		// Reinitiate blocklist update (if possible)
		SocialComponent.s_OnBlockListUpdateInvoker.Insert(OnBlockedListUpdated);
		SocialComponent.UpdateBlockList();
	}

	//------------------------------------------------------------------------------------------------
	void OnBlockedListUpdated(bool success)
	{
		if (!success)
		{
			// Some logging would be nice
			return;
		}

		// Remove only when it succeeds
		SocialComponent.s_OnBlockListUpdateInvoker.Remove(OnBlockedListUpdated);

		// Request all the authors
		SCR_EditableEntityCore core = SCR_EditableEntityCore.Cast(SCR_EditableEntityCore.GetInstance(SCR_EditableEntityCore));
		if (!core)
			return;
		
		core.Event_OnAuthorsRegisteredFinished.Insert(OnAuthorsRequestFinished);
		core.RequestAllAuthors();
	}
	
	//------------------------------------------------------------------------------------------------
	void OnAuthorsRequestFinished(set<SCR_EditableEntityAuthor> activeUGCAuthors)
	{	
		SCR_EditableEntityCore core = SCR_EditableEntityCore.Cast(SCR_EditableEntityCore.GetInstance(SCR_EditableEntityCore));
		if (!core)
			return;
		
		core.Event_OnAuthorsRegisteredFinished.Remove(OnAuthorsRequestFinished);
		
		PrintFormat("SCR_PlayerController::OnAuthorsRequestFinished - Number of UGC Authors: %1", activeUGCAuthors.Count(), level: LogLevel.VERBOSE);

		SocialComponent socialComp = SocialComponent.Cast(FindComponent(SocialComponent));
		if (!socialComp)
		{
			PrintFormat("SCR_PlayerController::OnAuthorsRequestFinished - Missing SocialComponent", level: LogLevel.VERBOSE);
			return;
		}
		
		array<string> identityIDs = {};
		foreach (SCR_EditableEntityAuthor author : activeUGCAuthors)
		{
			identityIDs.Insert(author.m_sAuthorUID);
		}
		PlayerManager.s_OnPlayerNameCacheUpdateInvoker.Insert(OnPlayerNameCacheUpdate);
		PlayerManager.RequestPlayerNameCacheUpdate(identityIDs);
		
		bool isBlockedAuthorPresent;
		foreach (SCR_EditableEntityAuthor author : activeUGCAuthors)
		{
			const bool isBlocked = socialComp.IsBlockedIdentity(author.m_sAuthorUID, author.m_ePlatform, author.m_sAuthorPlatformID);
			if (isBlocked)
			{
				PrintFormat(
					"Blocked user left UGC in this world {identity: %1; account: %2; platform: %3}",
					author.m_sAuthorUID,
					author.m_sAuthorPlatformID,
					author.m_ePlatform,
					level: LogLevel.VERBOSE
				);
				isBlockedAuthorPresent = true;
				break;
			}
		}
		
		if (isBlockedAuthorPresent)
		{					
			SCR_ConfigurableDialogUi dialog = SCR_ConfigurableDialogUi.CreateFromPreset(SCR_CommonDialogs.DIALOGS_CONFIG, "blocked_ugc_present");
			dialog.m_OnCancel.Insert(DisconnectFromGame);
		}
	}
	
	//------------------------------------------------------------------------------------------------
	void OnPlayerNameCacheUpdate(bool success)
	{
		Print("SCR_PlayerController - Name Cache Updated!", LogLevel.VERBOSE);
		PlayerManager.s_OnPlayerNameCacheUpdateInvoker.Remove(OnPlayerNameCacheUpdate);
	}
	
	//------------------------------------------------------------------------------------------------
	void DisconnectFromGame()
	{
		ChimeraWorld world = GetGame().GetWorld();
		world.PauseGameTime(false);
		
		GameStateTransitions.RequestGameplayEndTransition();
	}
	
	//------------------------------------------------------------------------------------------------
	void OnBlockedPlayerJoined(int playerID)
	{
		SCR_NotificationsComponent.SendLocal(ENotification.PLAYER_ON_BLOCKLIST_JOINED, playerID);
	}

	//------------------------------------------------------------------------------------------------
	override void OnControlledEntityChanged(IEntity from, IEntity to)
	{
		m_OnControlledEntityChanged.Invoke(from, to);

		ChimeraCharacter character = ChimeraCharacter.Cast(to);
		if (character)
			m_CharacterController = character.GetCharacterController();
		else
			m_CharacterController = null;

		SetGameUserSettings();
	}

	//------------------------------------------------------------------------------------------------
	static void SetGameUserSettings()
	{
		BaseContainer aimSensitivitySettings = GetGame().GetGameUserSettings().GetModule("SCR_AimSensitivitySettings");

		if (aimSensitivitySettings)
		{
			float aimSensitivityMouse;
			float aimSensitivityGamepad;
			float aimMultipADS;

			if (aimSensitivitySettings.Get("m_fMouseSensitivity", aimSensitivityMouse) &&
				aimSensitivitySettings.Get("m_fStickSensitivity", aimSensitivityGamepad) &&
				aimSensitivitySettings.Get("m_fAimADS", aimMultipADS))
			{
				CharacterControllerComponent.SetAimingSensitivity(aimSensitivityMouse, aimSensitivityGamepad, aimMultipADS);
				SCR_CharacterCameraHandlerComponent.SetADSSensitivity(aimMultipADS);
			}

			// Input curve: 0 = constant, 1 = linear
			float inputCurveMouse;
			float inputCurveStick;
			float inputCurveGyro;

			if (aimSensitivitySettings.Get("m_fFOVInputCurveMouse", inputCurveMouse) &&
				aimSensitivitySettings.Get("m_fFOVInputCurveStick", inputCurveStick) &&
				aimSensitivitySettings.Get("m_fFOVInputCurveGyro", inputCurveGyro))
			{
				CharacterControllerComponent.SetFOVInputCurve(inputCurveMouse, inputCurveStick, inputCurveGyro);
			}
		}

		BaseContainer gameplaySettings = GetGame().GetGameUserSettings().GetModule("SCR_GameplaySettings");

		if (gameplaySettings)
		{
			bool stickyADS;
			if (gameplaySettings.Get("m_bStickyADS", stickyADS))
				CharacterControllerComponent.SetStickyADS(stickyADS);

			bool stickyGadgets;
			if (gameplaySettings.Get("m_bStickyGadgets", stickyGadgets))
				CharacterControllerComponent.SetStickyGadget(stickyGadgets);

			bool mouseControlAircraft;
			if (gameplaySettings.Get("m_bMouseControlAircraft", mouseControlAircraft))
				CharacterControllerComponent.SetMouseControlAircraft(mouseControlAircraft);

			bool gamepadFreelookInAircraft;
			if (gameplaySettings.Get("m_bGamepadFreelookInAircraft", gamepadFreelookInAircraft))
				CharacterControllerComponent.SetGamepadControlAircraft(!gamepadFreelookInAircraft);

			EVehicleDrivingAssistanceMode drivingAssistance;
			if (gameplaySettings.Get("m_eDrivingAssistance", drivingAssistance))
				VehicleControllerComponent.SetDrivingAssistanceMode(drivingAssistance);
		}

		BaseContainer controllerSettings = GetGame().GetGameUserSettings().GetModule("SCR_ControllerSettings");
		if (controllerSettings)
		{
			bool gyroAlways;
			bool gyroFreelook;
			bool gyroADS;
			if (controllerSettings.Get("m_bGyroAlways", gyroAlways)
				&& controllerSettings.Get("m_bGyroFreelook", gyroFreelook)
				&& controllerSettings.Get("m_bGyroADS", gyroADS))
			{
				CharacterControllerComponent.SetGyroControl(gyroAlways, gyroFreelook, gyroADS);
			}

			float gyroSensitivity;
			float gyroVerticalHorizontalRatio;

			float gyroDirectionYaw;
			float gyroDirectionPitch;
			float gyroDirectionRoll;

			if (controllerSettings.Get("m_fGyroSensitivity", gyroSensitivity)
				&& controllerSettings.Get("m_fGyroVerticalHorizontalRatio", gyroVerticalHorizontalRatio)
				&& controllerSettings.Get("m_fGyroDirectionYaw", gyroDirectionYaw)
				&& controllerSettings.Get("m_fGyroDirectionPitch", gyroDirectionPitch)
				&& controllerSettings.Get("m_fGyroDirectionRoll", gyroDirectionRoll))
			{
				float sensitivityYaw   = gyroSensitivity * (1 - gyroDirectionYaw);
				float sensitivityPitch = gyroSensitivity * (1 - gyroDirectionPitch);
				float sensitivityRoll  = gyroSensitivity * (1 - gyroDirectionRoll);

				if (gyroVerticalHorizontalRatio > 1)
				{
					sensitivityYaw  *= 2 - gyroVerticalHorizontalRatio;
					sensitivityRoll *= 2 - gyroVerticalHorizontalRatio;
				}
				else
				{
					sensitivityPitch *= gyroVerticalHorizontalRatio;
				}

				CharacterControllerComponent.SetGyroSensitivity(sensitivityYaw, sensitivityPitch, sensitivityRoll);
			}
		}

		BaseContainer fovSettings = GetGame().GetGameUserSettings().GetModule("SCR_FieldOfViewSettings");
		if (fovSettings)
		{
			float focusInADS;
			if (fovSettings.Get("m_fFocusInADS", focusInADS))
				s_fADSFocus = focusInADS;

			float focusInPIP;
			if (fovSettings.Get("m_fFocusInPIP", focusInPIP))
				s_fPIPFocus = focusInPIP;
		}
	}

	//------------------------------------------------------------------------------------------------
	/*!
	Set entity which will be possessed by player.
	Possed entity is controlled by player, but it's not *the* player.
	\param entity Entity to be possessed, or null to return control back to the original player
	*/
	void SetPossessedEntity(IEntity entity)
	{
		if (!m_bIsPossessing)
		{
			if (entity)
			{
				m_OnBeforePossess.Invoke(entity);
				//--- Start posessing
				m_bIsPossessing = true;

				//--- Remember previously controlled entity
				IEntity controlledEntity = GetControlledEntity();
				m_MainEntityID = RplId.Invalid();
				if (controlledEntity)
				{
					RplComponent rpl = RplComponent.Cast(controlledEntity.FindComponent(RplComponent));
					if (rpl)
					{
						rpl.GiveExt(RplIdentity.Local(), false);
						m_MainEntityID = rpl.Id();
					}
				}

				OnRplMainEntityFromID(); //--- ToDo: Remove? BumpMe should call it automatically.
				Replication.BumpMe();

				//-- Tell manager we're possessing an entity
				SCR_PossessingManagerComponent possessingManager = SCR_PossessingManagerComponent.GetInstance();
				if (possessingManager)
					possessingManager.SetMainEntity(GetPlayerId(), entity, controlledEntity, m_bIsPossessing);

				//--- Switch control
				RplComponent rpl = RplComponent.Cast(entity.FindComponent(RplComponent));
				if (rpl)
					rpl.GiveExt(GetRplIdentity(), false);
				SetAIActivation(entity, false);
				SetControlledEntity(entity);
				m_OnPossessed.Invoke(entity);
			}
		}
		else
		{
			if (!entity)
			{
				//--- Stop possessing
				m_bIsPossessing = false;

				//--- Forget main entity
				m_MainEntityID = RplId.Invalid();
				OnRplMainEntityFromID(); //--- ToDo: Remove?
				Replication.BumpMe();

				SCR_PossessingManagerComponent possessingManager = SCR_PossessingManagerComponent.GetInstance();
				if (possessingManager)
					possessingManager.SetMainEntity(GetPlayerId(), GetControlledEntity(), m_MainEntity, m_bIsPossessing);

				//--- Switch control
				IEntity controlledEntity = GetControlledEntity();
				if (controlledEntity)
				{
					RplComponent rpl = RplComponent.Cast(controlledEntity.FindComponent(RplComponent));
					if (rpl)
						rpl.GiveExt(RplIdentity.Local(), false);

					SetAIActivation(controlledEntity, true);
				}

				//--- Switch control
				if (m_MainEntity)
				{
					RplComponent rpl = RplComponent.Cast(m_MainEntity.FindComponent(RplComponent));
					if (rpl)
						rpl.GiveExt(GetRplIdentity(), false);
				}
				SetControlledEntity(m_MainEntity);
				m_OnPossessed.Invoke(m_MainEntity);

				//--- SetControlledEntity(null) doesn't work yet. ToDo: Remove this check once it's implemented
				if (GetControlledEntity() != m_MainEntity)
					Print(string.Format("Error when switching control back to m_MainEntity = %1!", m_MainEntity), LogLevel.WARNING);
			}
			else
			{
				//--- Switch possessing
				SetPossessedEntity(null);
				SetPossessedEntity(entity);
				m_OnPossessed.Invoke(entity);
			}
		}
	}

	//------------------------------------------------------------------------------------------------
	/*!
	Set intial main entity of a player, for a case where an existing entity should be assigned instead of spawning a new one
	\param entity is the subject entity
	*/
	void SetInitialMainEntity(notnull IEntity entity)
	{
		RplComponent rpl = RplComponent.Cast(entity.FindComponent(RplComponent));
		if (!rpl)
			return;

		m_MainEntityID = rpl.Id();
		OnRplMainEntityFromID();
		Replication.BumpMe();

		SCR_PossessingManagerComponent possessingManager = SCR_PossessingManagerComponent.GetInstance();
		if (possessingManager)
			possessingManager.SetMainEntity(GetPlayerId(), GetControlledEntity(), entity, m_bIsPossessing);

		rpl.GiveExt(GetRplIdentity(), false); // transfer ownership
		SetAIActivation(entity, false);
		SetControlledEntity(entity);

		m_OnPossessed.Invoke(entity);
	}

	//------------------------------------------------------------------------------------------------
	/*!
	Check if player is currently possessing an entity.
	\return True when possessing
	*/
	bool IsPossessing()
	{
		return m_bIsPossessing;
	}

	//------------------------------------------------------------------------------------------------
	/*!
	Get player's main entity.
	When not possessing, this will be the same as GetControlledEntity()
	When possessing, this will be player's main entity which was controlled before possessing started
	\return Main player entity
	*/
	IEntity GetMainEntity()
	{
		if (m_bIsPossessing)
			return m_MainEntity;
		else
			return GetControlledEntity();
	}

	//------------------------------------------------------------------------------------------------
	protected void OnRplMainEntityFromID()
	{
		//m_MainEntity = IEntity.Cast(Replication.FindItem(m_MainEntityID));
		RplComponent rpl = RplComponent.Cast(Replication.FindItem(m_MainEntityID));
		if (rpl)
			m_MainEntity = rpl.GetEntity();
	}

	//------------------------------------------------------------------------------------------------
	protected void SetAIActivation(IEntity entity, bool activate)
	{
		if (!entity)
			return;

		AIControlComponent aiControl = AIControlComponent.Cast(entity.FindComponent(AIControlComponent));
		if (!aiControl)
			return;

		if (activate)
			aiControl.ActivateAI();
		else
			aiControl.DeactivateAI();
	}

	//------------------------------------------------------------------------------------------------
	//! Returns either a valid ID of local player or 0
	static int GetLocalPlayerId()
	{
		PlayerController pPlayerController = GetGame().GetPlayerController();
		if (!pPlayerController)
			return 0;

		return pPlayerController.GetPlayerId();
	}

	//------------------------------------------------------------------------------------------------
	/*!
	Get entity controlled by player on this machine.
	\return Controlled entity
	*/
	static IEntity GetLocalControlledEntity()
	{
		PlayerController pPlayerController = GetGame().GetPlayerController();
		if (pPlayerController)
			return pPlayerController.GetControlledEntity();

		return null;
	}

	//------------------------------------------------------------------------------------------------
	/*!
	Get player's main entity on this machine.
	When not possessing, this will be the same as GetControlledEntity()
	When possessing, this will be player's main entity which was controlled before possessing started
	\return Main player entity
	*/
	static IEntity GetLocalMainEntity()
	{
		SCR_PlayerController playerController = SCR_PlayerController.Cast(GetGame().GetPlayerController());
		if (playerController)
			return playerController.GetMainEntity();
		else
			return null;
	}

	//---- REFACTOR NOTE START: This code will need to be refactored as current implementation is not conforming to the standards ----
	// TODO: Use getter for faction affiliation component
	//------------------------------------------------------------------------------------------------
	/*!
	Get faction of currently controlled local player entity.
	\return Faction
	*/
	static Faction GetLocalControlledEntityFaction()
	{
		PlayerController playerController = GetGame().GetPlayerController();
		if (!playerController)
			return null;

		IEntity controlledEntity = playerController.GetControlledEntity();
		if (!controlledEntity)
			return null;

		FactionAffiliationComponent factionAffiliation = FactionAffiliationComponent.Cast(controlledEntity.FindComponent(FactionAffiliationComponent));
		if (factionAffiliation)
			return factionAffiliation.GetAffiliatedFaction();
		else
			return null;
	}

	//------------------------------------------------------------------------------------------------
	/*!
	Get faction of local player's main entity.
	When not possessing, the entity will be the same as GetControlledEntity()
	When possessing, the entity will be player's main entity which was controlled before possessing started
	\return Faction
	*/
	static Faction GetLocalMainEntityFaction()
	{
		SCR_PlayerController playerController = SCR_PlayerController.Cast(GetGame().GetPlayerController());
		if (!playerController)
			return null;

		IEntity controlledEntity = playerController.GetMainEntity();
		if (!controlledEntity)
			return null;

		FactionAffiliationComponent factionAffiliation = FactionAffiliationComponent.Cast(controlledEntity.FindComponent(FactionAffiliationComponent));
		if (factionAffiliation)
			return factionAffiliation.GetAffiliatedFaction();
		else
			return null;
	}
	//---- REFACTOR NOTE END ----

	//------------------------------------------------------------------------------------------------
	override void OnDestroyed(notnull Instigator killer)
	{
		super.OnDestroyed(killer);
		IEntity killerEntity = killer.GetInstigatorEntity();
		m_OnDestroyed.Invoke(killer, killerEntity);
	}

	//------------------------------------------------------------------------------------------------
	override void OnUpdate(float timeSlice)
	{
		if (!s_pLocalPlayerController)
			UpdateLocalPlayerController();

		if (m_bIsLocalPlayerController)
		{
			UpdateControls();
			//UpdateUI();
		}
	}

	//------------------------------------------------------------------------------------------------
	//! Find if this is local player controller. We assume that this never changes during scenario.
	protected void UpdateLocalPlayerController()
	{
		m_bIsLocalPlayerController = this == GetGame().GetPlayerController();
		if (!m_bIsLocalPlayerController)
			return;

		s_pLocalPlayerController = this;
		InputManager inputManager = GetGame().GetInputManager();
		if (!inputManager)
			return;

		inputManager.AddActionListener("WeaponChangeMagnification", EActionTrigger.VALUE, ChangeMagnification);
		inputManager.AddActionListener("CharacterWalk", EActionTrigger.DOWN, OnWalk);
		inputManager.AddActionListener("CharacterWalk", EActionTrigger.UP, OnEndWalk);
		inputManager.AddActionListener("FocusToggle", EActionTrigger.DOWN, ActionFocusToggle);
		inputManager.AddActionListener("FocusToggleVehicle", EActionTrigger.DOWN, ActionFocusToggleVehicle);
		inputManager.AddActionListener("FocusToggleUnarmed", EActionTrigger.DOWN, ActionFocusToggleUnarmed);
		inputManager.AddActionListener("Inventory", EActionTrigger.DOWN, ActionOpenInventory);
		inputManager.AddActionListener("TacticalPing", EActionTrigger.DOWN, ActionGesturePing);
		inputManager.AddActionListener("TacticalPingHold", EActionTrigger.DOWN, ActionGesturePingHold);
		inputManager.AddActionListener("TacticalPingHold", EActionTrigger.UP, ActionGesturePingHold);
		inputManager.AddActionListener("WeaponSwitchOptics", EActionTrigger.UP, ChangeWeaponOptics);
	}

	//------------------------------------------------------------------------------------------------
	//! Update disabling of character controls in menus
	protected void UpdateControls()
	{
		bool disableControls = GetGame().GetMenuManager().IsAnyMenuOpen();
		if (m_bIsPaused != disableControls)
		{
			m_bIsPaused = disableControls;
			SetDisableControls(disableControls);
		}
	}

	//---- REFACTOR NOTE START: This code will need to be refactored as current implementation is not conforming to the standards ----
	// TODO: This is obsolete
	//------------------------------------------------------------------------------------------------
	protected void UpdateUI()
	{
		ChimeraCharacter char = ChimeraCharacter.Cast(GetControlledEntity());
		if (!char)
			return;
		CharacterAnimationComponent animComp = char.GetAnimationComponent();
		if (!animComp)
			return;
		// Command ladder is present only when character is using ladder
		CharacterCommandLadder ladderCMD = animComp.GetCommandHandler().GetCommandLadder();
		if (!ladderCMD)
			return;
		int lrExitState = ladderCMD.CanExitLR();
		if (lrExitState & 0x1)
		{
			Print("Can exit right");
		}
		if (lrExitState & 0x2)
		{
			Print("Can exit left");
		}
	}
	//---- REFACTOR NOTE END ----

	//------------------------------------------------------------------------------------------------
	protected void ChangeMagnification(float value)
	{
		SCR_CharacterControllerComponent characterController = GetCharacterController();
		if (characterController)
			characterController.SetNextSightsFOVInfo(value);
	}

	//------------------------------------------------------------------------------------------------
	protected void ChangeWeaponOptics()
	{
		SCR_CharacterControllerComponent characterController = GetCharacterController();
		if (characterController)
			characterController.SetNextSights();
	}

	//------------------------------------------------------------------------------------------------
	protected SCR_CharacterControllerComponent GetCharacterController()
	{
		ChimeraCharacter char = ChimeraCharacter.Cast(GetControlledEntity());
		if (!char)
			return null;

		return SCR_CharacterControllerComponent.Cast(char.GetCharacterController());
	}

	//------------------------------------------------------------------------------------------------
	// Parameter value:
	// TRUE:  Disables the controls
	// FALSE: Enables the controls
	private void SetDisableControls(bool value)
	{
		SCR_CharacterControllerComponent characterController = GetCharacterController();
		if (!characterController)
			return;

		characterController.SetDisableViewControls(value);
		characterController.SetDisableWeaponControls(value);
		characterController.SetDisableMovementControls(value)
	}

	//------------------------------------------------------------------------------------------------
	/*! Focus input degree for analogue input
	\param adsProgress ADS focus percentage
	\param dt Delta time
	\return focus Amount of focus between 0 and 1
	*/
	float GetFocusValue(float adsProgress = 0, float dt = -1)
	{
		if (!m_CharacterController)

			return 0;
		float focus;

		// Autofocus
		if (adsProgress > 0)
		{
			// PIPCQB Separate slider
			if (SCR_2DPIPSightsComponent.IsPIPActive())
				focus = Math.Lerp(s_fADSFocus, 1, s_fPIPFocus);
			else
				focus = s_fADSFocus;

			focus *= Math.Min(adsProgress, 1);

			if (m_CharacterController.IsFreeLookEnabled())
			{
				// Freelook angle effect on ADS focus
				CharacterHeadAimingComponent headAiming = m_CharacterController.GetHeadAimingComponent();
				if (headAiming)
				{
					float freelookAngle = headAiming.GetAimingRotation().Length();
					float freelookFocus = 1 - Math.InverseLerp(1, 6, freelookAngle);
					focus *= Math.Clamp(freelookFocus, 0, 1);
				}
			}
		}

		InputManager inputManager = GetGame().GetInputManager();

		// Cancel toggled focus when focus is held
		bool inputDigital = inputManager.GetActionTriggered("Focus");
		if (inputDigital && m_eFocusToggle != SCR_EFocusToggleMode.DISABLED)
			m_eFocusToggle = SCR_EFocusToggleMode.DISABLED;

		// Conditions must be consistent with ActionFocusToggle and ActionFocusToggleUnarmed
		ChimeraCharacter character = m_CharacterController.GetCharacter();
		if (character && character.IsInVehicle())
		{
			// Vehicle focus toggle mode
			if (m_eFocusToggle == SCR_EFocusToggleMode.VEHICLE)
			{
				// Cancel toggle focus when in vehicle and aiming through gadget (binocular, compass)
				if (m_bGadgetFocus)
					m_eFocusToggle = SCR_EFocusToggleMode.DISABLED;

				// Cancel toggle focus when in vehicle and not in forced freelook
				if (!m_CharacterController.IsFreeLookEnabled() && !m_CharacterController.GetFreeLookInput())
					m_eFocusToggle = SCR_EFocusToggleMode.DISABLED;
			}
		}
		else
		{
			// Unarmed focus toggle mode
			if (m_eFocusToggle == SCR_EFocusToggleMode.UNARMED)
			{
				// Cancel toggle focus when not in vehicle and holding item in hands
				if (m_CharacterController.GetCurrentItemInHands())
					m_eFocusToggle = SCR_EFocusToggleMode.DISABLED;

				// Cancel toggle focus when not in vehicle and holding gadget
				if (m_CharacterController.IsGadgetInHands())
					m_eFocusToggle = SCR_EFocusToggleMode.DISABLED;
			}
		}

		// Vehicles have different focus action to prevent conflict with brakes
		bool isVehicleContextActive = inputManager.IsContextActive("CarContext") || inputManager.IsContextActive("TrackedContext") || inputManager.IsContextActive("HelicopterContext");
		float inputAnalogue;
		if (!isVehicleContextActive)
		{
			// Square root input to focus mapping results in linear change of picture area
			float focusAnalogue = Math.Sqrt(FOCUS_ANALOGUE_SCALE * inputManager.GetActionValue("FocusAnalog"));

			// Tolerance to prevent jittering
			if (focusAnalogue < FOCUS_DEACTIVATION)
				s_fFocusAnalogue = 0;
			else if (!float.AlmostEqual(s_fFocusAnalogue, focusAnalogue, FOCUS_TOLERANCE))
				s_fFocusAnalogue = focusAnalogue;

			inputAnalogue = s_fFocusAnalogue;
		}

		bool isADS = m_CharacterController.GetWeaponADSInput();

		// Check gadget ADS
		if (!isADS && m_CharacterController.IsGadgetInHands())
			isADS = m_CharacterController.IsGadgetRaisedModeWanted();

		// Verify turrets
		if (!isADS && character)
		{
			CompartmentAccessComponent compartmentAccess = character.GetCompartmentAccessComponent();

			BaseCompartmentSlot compartment;
			if (compartmentAccess)
				compartment = compartmentAccess.GetCompartment();

			TurretControllerComponent turretController;
			if (compartment)
				turretController = TurretControllerComponent.Cast(compartment.GetController());

			if (turretController)
				isADS = turretController.IsWeaponADS();
		}

		// Prevent focus warping back while toggling ADS on controller
		// analogue: track timeout as we have no input filter that has thresholds or delays and returns axis value yet
		if (inputAnalogue < FOCUS_DEACTIVATION)
			s_fFocusTimeout = FOCUS_TIMEOUT; // Below deactivation threshold
		else if (s_bWasADS != isADS && s_fFocusTimeout > 0)
			s_fFocusTimeout = FOCUS_TIMEOUT; // ADS toggled
		else if (inputAnalogue < FOCUS_ACTIVATION && s_fFocusTimeout > 0)
			s_fFocusTimeout = FOCUS_TIMEOUT; // Below activation threshold and not active
		else if (s_fFocusTimeout > dt)
			s_fFocusTimeout -= dt; // Not yet active, decrementing
		else
			s_fFocusTimeout = 0; // Activated

		// Cancel toggle focus with analogue input
		if (m_eFocusToggle != SCR_EFocusToggleMode.DISABLED && s_fFocusTimeout == 0)
			m_eFocusToggle = SCR_EFocusToggleMode.DISABLED;

		s_bWasADS = isADS;

		// Combine all valid input sources
		float input;
		if (m_eFocusToggle != SCR_EFocusToggleMode.DISABLED || inputDigital)
			input = 1;
		else if (s_fFocusTimeout == 0)
			input = inputAnalogue;

		if (input > 0)
			focus = Math.Max(focus, input);

		// Ensure return value always within 0-1
		focus = Math.Clamp(focus, 0, 1);
		return focus;
	}

	//------------------------------------------------------------------------------------------------
	//! Automatic focusing while gadget is aimed down sights
	void SetGadgetFocus(bool gadgetFocus)
	{
		m_bGadgetFocus = gadgetFocus;
	}

	//------------------------------------------------------------------------------------------------
	//! Automatic focusing while gadget is aimed down sights
	bool GetGadgetFocus()
	{
		return m_bGadgetFocus;
	}

	//---- REFACTOR NOTE START: This code will need to be refactored as current implementation is not conforming to the standards ----
	//! TODO: Action listener methods should be protected
	//------------------------------------------------------------------------------------------------
	void ActionFocusToggle(float value = 0.0, EActionTrigger reason = 0)
	{
		// If focus toggle was in different mode, it should be disabled first
		if (m_eFocusToggle == SCR_EFocusToggleMode.DISABLED)
			m_eFocusToggle = SCR_EFocusToggleMode.ENABLED;
		else
			m_eFocusToggle = SCR_EFocusToggleMode.DISABLED
	}

	//------------------------------------------------------------------------------------------------
	void ActionFocusToggleVehicle(float value = 0.0, EActionTrigger reason = 0)
	{
		if (!m_CharacterController)
			return;

		// Conditions must be consistent with GetFocusValue logic
		ChimeraCharacter character = m_CharacterController.GetCharacter();
		if (character && !character.IsInVehicle())
			return;

		// Cancel toggle focus when in vehicle and aiming through gadget (binocular, compass)
		if (m_bGadgetFocus)
			return;

		// Cancel toggle focus when in vehicle and not in forced freelook
		if (!m_CharacterController.IsFreeLookEnabled() && !m_CharacterController.GetFreeLookInput())
			return;

		// If focus toggle was in different mode, it should be disabled first
		if (m_eFocusToggle == SCR_EFocusToggleMode.DISABLED)
			m_eFocusToggle = SCR_EFocusToggleMode.VEHICLE;
		else
			m_eFocusToggle = SCR_EFocusToggleMode.DISABLED
	}

	//------------------------------------------------------------------------------------------------
	void ActionFocusToggleUnarmed(float value = 0.0, EActionTrigger reason = 0)
	{
		if (!m_CharacterController)
			return;

		// Conditions must be consistent with GetFocusValue logic
		ChimeraCharacter character = m_CharacterController.GetCharacter();
		if (character && character.IsInVehicle())
			return;

		// Cancel toggle focus when not in vehicle and holding item in hands
		if (m_CharacterController.GetCurrentItemInHands())
			return;

		// Cancel toggle focus when not in vehicle and holding gadget
		if (m_CharacterController.IsGadgetInHands())
			return;

		// Allow cancelling unarmed focus while picking up items
		// Disallow enabling unarmed focus while picking up items, as it may become irreleant quickly
		// Reason is player may want to enter ADS before ready, while intent is unclear
		if (m_eFocusToggle == SCR_EFocusToggleMode.DISABLED && m_CharacterController.IsPlayingItemGesture())
			return;
		
		// If focus toggle was in different mode, it should be disabled first
		if (m_eFocusToggle == SCR_EFocusToggleMode.DISABLED)
			m_eFocusToggle = SCR_EFocusToggleMode.UNARMED;
		else
			m_eFocusToggle = SCR_EFocusToggleMode.DISABLED
	}

	//------------------------------------------------------------------------------------------------
	void OnWalk()
	{
		if (!m_CharacterController || m_CharacterController.GetDynamicSpeed() == WALK_SPEED)
			return;

		m_fCharacterSpeed = m_CharacterController.GetDynamicSpeed();
		m_CharacterController.SetDynamicSpeed(WALK_SPEED);
		m_CharacterController.SetShouldApplyDynamicSpeedOverride(true);
	}

	//------------------------------------------------------------------------------------------------
	void OnEndWalk()
	{
		if (!m_CharacterController || m_CharacterController.GetDynamicSpeed() == m_fCharacterSpeed)
			return;

		m_CharacterController.SetDynamicSpeed(m_fCharacterSpeed);
		m_CharacterController.SetShouldApplyDynamicSpeedOverride(false);
	}

	//------------------------------------------------------------------------------------------------
	void ActionOpenInventory()
	{
		IEntity entity = s_pLocalPlayerController.GetControlledEntity();
		if (!entity)
			return;

		SCR_InventoryStorageManagerComponent inventory = SCR_InventoryStorageManagerComponent.Cast(entity.FindComponent(SCR_InventoryStorageManagerComponent));
		if (inventory)
			inventory.Action_OpenInventory();
	}

	//------------------------------------------------------------------------------------------------
	void ActionGesturePing(float value = 0.0, EActionTrigger reason = 0)
	{
		if (!m_CharacterController)
			return;

		// Press and forget variant... eg press comma once - character will point with it's finger for 1 second (including blending time from animation graph ~300ms)
		m_CharacterController.TryStartCharacterGesture(ECharacterGestures.POINT_WITH_FINGER, 1500);
	}

	//------------------------------------------------------------------------------------------------
	void ActionGesturePingHold(float value = 0.0, EActionTrigger reason = 0)
	{
		if (!m_CharacterController)
			return;

		// Hold key variant... hold period - character will point with it's finger until period key is released
		if (reason == EActionTrigger.DOWN)
		{
			m_CharacterController.TryStartCharacterGesture(ECharacterGestures.POINT_WITH_FINGER);
		} else if (reason == EActionTrigger.UP)
		{
			m_CharacterController.StopCharacterGesture();
		}
	}
	//---- REFACTOR NOTE END ----
	
	//------------------------------------------------------------------------------------------------
	// Set the correct platfrom icon to the provided Image Widget
	//! \param playerID
	//! \param image
	//! \param glowImage
	//! \param set image Visible
	//! \param show on PC
	//! \param show on Xbox
	bool SetPlatformImageTo(int playerID, notnull ImageWidget image, ImageWidget glow = null, bool setVisible = true, bool showOnPC = false, bool showOnXbox = false)
	{		
		PlayerManager playerMgr = GetGame().GetPlayerManager();
		if (!playerMgr)
			return false;
		
		PlatformKind targetPlatformKind = playerMgr.GetPlatformKind(playerID);
		PlatformKind ownPlatformKind = playerMgr.GetPlatformKind(GetLocalPlayerId());
		
		// Always show on PSN
		if (ownPlatformKind == PlatformKind.PSN	)
			SetPlatformImagePSN(targetPlatformKind, image, glow, setVisible);
		
		if (!showOnPC && !showOnXbox)
			return true;
		
		switch (ownPlatformKind)
		{
			case PlatformKind.STEAM:
				if (showOnPC)
					SetPlatformImagePC(targetPlatformKind, image, glow, setVisible);
			break;
			
			case PlatformKind.XBOX:
				if (showOnXbox)
					SetPlatformImageXbox(targetPlatformKind, image, glow, setVisible);
			break;
			
			case PlatformKind.NONE:
				if (showOnPC)
					SetPlatformImagePC(targetPlatformKind, image, glow, setVisible);
			break;
		}
		
		return true;
	}
	
	//------------------------------------------------------------------------------------------------
	// Set the correct platfrom icon to the provided Image Widget based on PlatformKind
	//! \param platform
	//! \param image
	//! \param glowImage
	//! \param set image Visible
	//! \param show on PC
	//! \param show on Xbox
	bool SetPlatformImageToKind(PlatformKind targetPlatform, notnull ImageWidget image, ImageWidget glow = null, bool setVisible = true, bool showOnPC = false, bool showOnXbox = false)
	{
		PlatformKind ownPlatformKind = GetGame().GetPlayerManager().GetPlatformKind(GetLocalPlayerId());
		
		// Always show on PSN
		if (ownPlatformKind == PlatformKind.PSN)
			SetPlatformImagePSN(targetPlatform, image, glow, setVisible);
		
		if (!showOnPC && !showOnXbox)
			return true;
		
		switch (ownPlatformKind)
		{
			case PlatformKind.STEAM:
				if (showOnPC)
					SetPlatformImagePC(targetPlatform, image, glow, setVisible);
			break;
			
			case PlatformKind.XBOX:
				if (showOnXbox)
					SetPlatformImageXbox(targetPlatform, image, glow, setVisible);
			break;
			
			case PlatformKind.NONE:
				if (showOnPC)
					SetPlatformImagePC(targetPlatform, image, glow, setVisible);
			break;
		}
		
		return true;
	}
	
	//------------------------------------------------------------------------------------------------
	protected void SetPlatformImagePSN(PlatformKind targetPlatformKind, notnull ImageWidget image, ImageWidget glow = null, bool setVisible = true)
	{
		if (targetPlatformKind == PlatformKind.PSN)
		{
			image.LoadImageFromSet(0, UIConstants.ICONS_IMAGE_SET, UIConstants.PLATFROM_PLAYSTATION_ICON_NAME);
			
			if (glow)
				glow.LoadImageFromSet(0, UIConstants.ICONS_GLOW_IMAGE_SET, UIConstants.PLATFROM_PLAYSTATION_ICON_NAME);
		}
		else
		{
			image.LoadImageFromSet(0, UIConstants.ICONS_IMAGE_SET, UIConstants.PLATFROM_GENERIC_ICON_NAME);
			
			if (glow)
				glow.LoadImageFromSet(0, UIConstants.ICONS_GLOW_IMAGE_SET, UIConstants.PLATFROM_GENERIC_ICON_NAME);
		}
		
		if (!setVisible)
			return;
		
		image.SetVisible(true);
		if (glow)
			glow.SetVisible(true);
	}
	
	//------------------------------------------------------------------------------------------------
	protected void SetPlatformImagePC(PlatformKind targetPlatformKind, notnull ImageWidget image, ImageWidget glow = null, bool setVisible = true)
	{
		string icon;
		switch (targetPlatformKind)
		{
			case PlatformKind.STEAM:
				icon = UIConstants.PLATFROM_PC_ICON_NAME;
			break;
			case PlatformKind.XBOX:
				icon = UIConstants.PLATFROM_XBOX_ICON_NAME;
			break;
			case PlatformKind.PSN:
				icon = UIConstants.PLATFROM_PLAYSTATION_ICON_NAME;
			break;
			case PlatformKind.NONE:
				icon = UIConstants.PLATFROM_PC_ICON_NAME;
			break;
		}
		
		image.LoadImageFromSet(0, UIConstants.ICONS_IMAGE_SET, icon);
		if (glow)
			glow.LoadImageFromSet(0, UIConstants.ICONS_GLOW_IMAGE_SET, icon);
		
		if (!setVisible)
			return;
		
		image.SetVisible(true);
		if (glow)
			glow.SetVisible(true);
	}
	
	//------------------------------------------------------------------------------------------------
	protected void SetPlatformImageXbox(PlatformKind targetPlatformKind, notnull ImageWidget image, ImageWidget glow = null, bool setVisible = true)
	{
		string icon;
		switch (targetPlatformKind)
		{
			case PlatformKind.STEAM:
				icon = UIConstants.PLATFROM_PC_ICON_NAME;
			break;
			case PlatformKind.XBOX:
				icon = UIConstants.PLATFROM_XBOX_ICON_NAME;
			break;
			case PlatformKind.PSN:
				icon = UIConstants.PLATFROM_PLAYSTATION_ICON_NAME;
			break;
			case PlatformKind.NONE:
				icon = UIConstants.PLATFROM_PC_ICON_NAME;
			break;
		}
		
		image.LoadImageFromSet(0, UIConstants.ICONS_IMAGE_SET, icon);
		if (glow)
			glow.LoadImageFromSet(0, UIConstants.ICONS_GLOW_IMAGE_SET, icon);
		
		if (!setVisible)
			return;
		
		image.SetVisible(true);
		if (glow)
			glow.SetVisible(true);
	}
}

/*
===========================================
Do not modify, this script is generated
===========================================
*/

/*!
\addtogroup Turrets
\{
*/

enum ETurretReloadState
{
	NONE,
	//Moving to reloading point
	BEFORE_RELOADING,
	//Reloading
	RELOADING,
	//If needed, move back to old position
	AFTER_RELOADING,
}

/*!
\}
*/
[EntityEditorProps(insertable: false)]
class SCR_Tutorial_ShootingRange_RELOADClass: SCR_BaseTutorialStageClass
{
};

//------------------------------------------------------------------------------------------------
class SCR_Tutorial_ShootingRange_RELOAD : SCR_BaseTutorialStage
{
	//------------------------------------------------------------------------------------------------
	override protected void Setup()
	{
		SCR_HintManagerComponent.HideHint();
		SCR_HintManagerComponent.ClearLatestHint();

		PlayNarrativeCharacterStage("SHOOTINGRANGE_Instructor", 4);
	}
	
	//------------------------------------------------------------------------------------------------
	override protected bool GetIsFinished()
	{
		BaseWeaponManagerComponent weaponManager = BaseWeaponManagerComponent.Cast(m_Player.FindComponent(BaseWeaponManagerComponent));
		
		if (!weaponManager)
			return false;

		BaseWeaponComponent weaponComponent = weaponManager.GetCurrent();
		
		if (!weaponComponent)
			return false;
		
		BaseMagazineComponent mag = weaponComponent.GetCurrentMagazine();
		
		if (mag)
			return (mag.GetAmmoCount() != 0);
		else
			return false;
	}
	
};

[EntityEditorProps(insertable: false)]
class SCR_Tutorial_SW_RPG_RELOADClass: SCR_BaseTutorialStageClass
{
};

//------------------------------------------------------------------------------------------------
class SCR_Tutorial_SW_RPG_RELOAD : SCR_BaseTutorialStage
{
	SCR_CharacterInventoryStorageComponent m_StorageComponent;
	//------------------------------------------------------------------------------------------------
	override protected void Setup()
	{
		SCR_TutorialLogic_SW.Cast(m_Logic).m_OnAmmoAddedChanged.Insert(OnAmmoChanged);
		
		m_StorageComponent = SCR_CharacterInventoryStorageComponent.Cast(m_Player.FindComponent(SCR_CharacterInventoryStorageComponent));
		
		RegisterWaypoint("SW_ARSENAL_USSR", "", "AMMO");
	}
	
	//------------------------------------------------------------------------------------------------
	bool IsTargetDestroyed()
	{
		IEntity target = GetGame().GetWorld().FindEntityByName("TARGET_1");
		if (!target)
			return true;
		
		IEntity destructible = target.GetChildren();
		if (!destructible)
			return true;
		
		SCR_DestructionMultiPhaseComponent destructionComp = SCR_DestructionMultiPhaseComponent.Cast(destructible.FindComponent(SCR_DestructionMultiPhaseComponent));
		if (destructionComp)
			return destructionComp.GetState() == EDamageState.DESTROYED;
		
		return false;
	}
	
	//------------------------------------------------------------------------------------------------
	void OnAmmoChanged()
	{
		SCR_TutorialLogic_SW.Cast(m_Logic).m_OnAmmoAddedChanged.Remove(OnAmmoChanged);
		
		if (!IsTargetDestroyed())
			m_TutorialComponent.SetStage("RPG_FIRE");
		
		m_bFinished = true;
	}
	
	//------------------------------------------------------------------------------------------------
	override bool GetIsFinished()
	{
		return m_bFinished;
	}
}

//------------------------------------------------------------------------------------------------
[BaseContainerProps()]
class SCR_CharacterReloadingCondition : SCR_AvailableActionCondition
{
	//------------------------------------------------------------------------------------------------
	override bool IsAvailable(SCR_AvailableActionsConditionData data)
	{
		if (!data)
			return false;

		float result = data.GetIsCharacterReloading();

		return GetReturnResult((int)result);
	}
};
//------------------------------------------------------------------------------------------------
//! Returns true if character has weapon equipped
[BaseContainerProps()]
class SCR_CharacterHasWeaponCondition : SCR_AvailableActionCondition
{
	//------------------------------------------------------------------------------------------------
	//! Returns true when current controlled entity has a weapon equipped
	//! Returns opposite if m_bNegateCondition is enabled
	override bool IsAvailable(SCR_AvailableActionsConditionData data)
	{
		if (!data)
			return false;

		bool result = data.GetCurrentWeaponEntity() != null;
		return GetReturnResult(result);
	}
};
//------------------------------------------------------------------------------------------------
//! Returns true if character is using weapon of given type
[BaseContainerProps()]
class SCR_CharacterWeaponTypeCondition : SCR_AvailableActionCondition
{
	[Attribute("", UIWidgets.EditBox, "", "")]
	private string m_sValue;

	//------------------------------------------------------------------------------------------------
	//! Returns true when current controlled entity has a weapon equipped of given type
	//! Returns opposite if m_bNegateCondition is enabled
	override bool IsAvailable(SCR_AvailableActionsConditionData data)
	{
		if (!data)
			return false;

		bool result = data.GetCurrentWeaponEntity() != null;

		if (result)
			result = data.GetCurrentWeapon().GetWeaponSlotType() == m_sValue;

		return GetReturnResult(result);
	}
};
//------------------------------------------------------------------------------------------------
[BaseContainerProps()]
class SCR_CharacterCanFireWeaponCondition : SCR_AvailableActionCondition
{
	//------------------------------------------------------------------------------------------------
	override bool IsAvailable(SCR_AvailableActionsConditionData data)
	{
		if (!data)
			return false;

		return GetReturnResult(data.GetCanCharacterFireWeapon());
	}
};
//------------------------------------------------------------------------------------------------
//! Returns true if ammo of current weapon matches the condition
[BaseContainerProps()]
class SCR_WeaponAmmoCountCondition : SCR_AvailableActionCondition
{
	[Attribute("3", UIWidgets.ComboBox, "Cond operator", "", ParamEnumArray.FromEnum(SCR_ComparerOperator) )]
	private SCR_ComparerOperator m_eOperator;

	[Attribute("1", UIWidgets.ComboBox, "Should comparison be done using percentage of ammo?", "" )]
	private bool m_bComparePercentage;

	[Attribute("2", UIWidgets.EditBox, "Percentages are 0-100, non-percentage values are rounded to integers", "")]
	private float m_fValue;

	//------------------------------------------------------------------------------------------------
	//! Returns true when current controlled entity's current weapon has met the specified ammo condition
	//! Returns opposite if m_bNegateCondition is enabled
	override bool IsAvailable(SCR_AvailableActionsConditionData data)
	{
		if (!data)
			return false;

		BaseMagazineComponent magazine = data.GetCurrentMagazine();
		if (!magazine)
			return false;

		int current = magazine.GetAmmoCount();
		int max = magazine.GetMaxAmmoCount();
		bool result = false;
		if (m_bComparePercentage)
		{
			if (max > 0.0)
			{
				float perc = (current/(float)max) * 100.0;
				result = SCR_Comparer<float>.Compare(m_eOperator, perc, m_fValue);
				return GetReturnResult(result);
			}
			return GetReturnResult(false);
		}

		result = SCR_Comparer<int>.Compare(m_eOperator, current, (int)m_fValue);
		return GetReturnResult(result);
	}
};
//------------------------------------------------------------------------------------------------
//! Returns true if weapon has loaded magazine
[BaseContainerProps()]
class SCR_WeaponBipodCondition : SCR_AvailableActionCondition
{
	[Attribute("true", uiwidget: UIWidgets.CheckBox, "True = unfolded, False = folded")]
	protected bool m_bBipodState;

	//------------------------------------------------------------------------------------------------
	//! Returns true when current weapon has bipod and matches the desired state
	//! Returns opposite if m_bNegateCondition is enabled, but only if weapon has bipod
	override bool IsAvailable(SCR_AvailableActionsConditionData data)
	{
		if (!data)
			return false;

		// Only evaluate weapons equipped with bipod
		BaseWeaponComponent weapon = data.GetCurrentWeapon();
		if (!weapon || !weapon.HasBipod())
			return false;

		return GetReturnResult(weapon.GetBipod() == m_bBipodState);
	}
};
[BaseContainerProps()]
class SCR_WeaponChangeSwitchOpticsCondition : SCR_AvailableActionCondition
{
	//------------------------------------------------------------------------------------------------
	//! Return true if currently held weapon has more than 1 scopes
	override bool IsAvailable(SCR_AvailableActionsConditionData data)
	{
		if (!data)
			return false;
	
		IEntity controlledEntity = SCR_PlayerController.GetLocalControlledEntity();
		if (!controlledEntity)
			return null;

		ChimeraCharacter character = ChimeraCharacter.Cast(controlledEntity);
		if (!character)
			return null;

		BaseWeaponManagerComponent weaponManager = character.GetCharacterController().GetWeaponManagerComponent();
		if (!weaponManager)
			return null;

		BaseWeaponComponent currentSights = weaponManager.GetCurrentWeapon();
		if (!currentSights)
			return null;

		bool canSwitchOptics;
		
		if (currentSights.FindAvailableSights() == 0)
			canSwitchOptics = currentSights.CanSetSights(1);
		else if(currentSights.FindAvailableSights() == 1)
			canSwitchOptics = currentSights.CanSetSights(0);

		return canSwitchOptics;
	}
};
//------------------------------------------------------------------------------------------------
[BaseContainerProps()]
class SCR_WeaponFiremodeCondition : SCR_AvailableActionCondition
{
	[Attribute("0", uiwidget: UIWidgets.ComboBox, "Fire mode to check", "", ParamEnumArray.FromEnum(EWeaponFiremodeType))]
	protected EWeaponFiremodeType m_iValue;

	[Attribute("true", uiwidget: UIWidgets.CheckBox, "True = currently active, False = contains")]
	protected bool m_bIsCurrent;

	//------------------------------------------------------------------------------------------------
	override bool IsAvailable(SCR_AvailableActionsConditionData data)
	{
		// Check muzzle
		BaseMuzzleComponent muzzle = data.GetCurrentMuzzle();
		if (!muzzle)
			return false;

		// Get result
		bool result = false;

		if (m_bIsCurrent)
		{
			BaseFireMode mode = muzzle.GetCurrentFireMode();
			if (mode)
				result = (mode.GetFiremodeType() == m_iValue);
		}
		else
			result = ContainsMode(muzzle, m_iValue);

		return GetReturnResult(result);
	}

	//------------------------------------------------------------------------------------------------
	protected bool ContainsMode(BaseMuzzleComponent muzzle, EWeaponFiremodeType modeType)
	{
		// Get fire modes list
		array<BaseFireMode> fireModes = {};
		muzzle.GetFireModesList(fireModes);

		// Go throught fire modes
		int count = fireModes.Count();
		for (int i = 0; i < count; i++)
		{
			// Contains mode
			if (fireModes[i].GetFiremodeType() == modeType)
				return true;
		}

		// Not found
		return false;
	}
};
//------------------------------------------------------------------------------------------------
//! Returns true if current weapon's number of firemodes matches current condition
[BaseContainerProps()]
class SCR_WeaponFiremodeCountCondition : SCR_AvailableActionCondition
{
	[Attribute("3", UIWidgets.ComboBox, "Cond operator", "", ParamEnumArray.FromEnum(SCR_ComparerOperator) )]
	private SCR_ComparerOperator m_eOperator;

	[Attribute("2", UIWidgets.EditBox, "Min firemodes, 2 = safety & default usually", "")]
	private int m_iValue;

	//------------------------------------------------------------------------------------------------
	//! Returns true when current controlled entity's current weapon number of firemodes matches the specified condition
	//! Returns opposite if m_bNegateCondition is enabled
	override bool IsAvailable(SCR_AvailableActionsConditionData data)
	{
		if (!data)
			return false;

		BaseMuzzleComponent muzzle = data.GetCurrentMuzzle();
		if (!muzzle)
			return false;

		bool result = SCR_Comparer<int>.Compare(m_eOperator, muzzle.GetFireModesCount(), m_iValue);
		
		return GetReturnResult(result);
	}
};
//------------------------------------------------------------------------------------------------
//! Returns true if weapon has loaded magazine
[BaseContainerProps()]
class SCR_WeaponHasMagazineCondition : SCR_AvailableActionCondition
{
	//------------------------------------------------------------------------------------------------
	//! Returns true when magazine is in current weapon
	//! Returns opposite if m_bNegateCondition is enabled
	override bool IsAvailable(SCR_AvailableActionsConditionData data)
	{
		if (!data)
			return false;

		bool result = false;

		BaseMagazineComponent magazine = data.GetCurrentMagazine();
		if (magazine)
			result = true;

		return GetReturnResult(result);
	}
};
//------------------------------------------------------------------------------------------------
[BaseContainerProps()]
class SCR_WeaponIsRaisedCondition : SCR_AvailableActionCondition
{
	//------------------------------------------------------------------------------------------------
	override bool IsAvailable(SCR_AvailableActionsConditionData data)
	{
		if (!data)
			return false;

		return GetReturnResult(data.GetIsCharacterWeaponRaised());
	}
};
//------------------------------------------------------------------------------------------------
//! Returns true if the count of additional magazines in character's inventory matches current condition
[BaseContainerProps()]
class SCR_WeaponMagazineCountCondition : SCR_AvailableActionCondition
{
	[Attribute("3", UIWidgets.ComboBox, "Cond operator", "", ParamEnumArray.FromEnum(SCR_ComparerOperator) )]
	private SCR_ComparerOperator m_eOperator;

	[Attribute("0", UIWidgets.EditBox, "", "")]
	private int m_iValue;

	//------------------------------------------------------------------------------------------------
	//! Returns true when current controlled entity owns amount of extra magazines for current weapon specified by the condition
	//! Returns opposite if m_bNegateCondition is enabled
	override bool IsAvailable(SCR_AvailableActionsConditionData data)
	{
		if (!data)
			return false;

		int additionalMagazines = data.GetAdditionalMagazinesCount();
		bool result = SCR_Comparer<int>.Compare(m_eOperator, additionalMagazines, m_iValue);
		return GetReturnResult(result);
	}
};
[BaseContainerProps()]
class SCR_WeaponManipulationCondition : SCR_AvailableActionCondition
{
	override bool IsAvailable(SCR_AvailableActionsConditionData data)
	{
		return GetReturnResult(data.IsWeaponManipulation());
	}
};
//------------------------------------------------------------------------------------------------
[BaseContainerProps()]
class SCR_WeaponMuzzleChamberedCondition : SCR_AvailableActionCondition
{
	//------------------------------------------------------------------------------------------------
	//! Return true if current weapon has bullet in chamber
	override bool IsAvailable(SCR_AvailableActionsConditionData data)
	{
		if (!data)
			return false;

		BaseMuzzleComponent muzzle = data.GetCurrentMuzzle();
		if (!muzzle)
			return false;

		bool result = muzzle.IsCurrentBarrelChambered();

		return GetReturnResult(result);
	}
};
//------------------------------------------------------------------------------------------------
[BaseContainerProps()]
class SCR_WeaponSightHasZeroingCondition : SCR_AvailableActionCondition
{
	//------------------------------------------------------------------------------------------------
	//! Return true when current zeroing on weapon is not 0
	//! That means that weapon has no zeroing, cause weapon with zeroing has zeroing alway > 0
	override bool IsAvailable(SCR_AvailableActionsConditionData data)
	{
		if (!data)
			return false;

		BaseWeaponComponent currentweapon = data.GetCurrentWeapon();
		if (!currentweapon)
			return false;

		float zeroing = currentweapon.GetCurrentSightsZeroing();
		return GetReturnResult(zeroing > 0);
	}
};
// Class which fully describes weapon state
class SCR_WeaponState
{
	BaseWeaponComponent m_Weapon;
	BaseMuzzleComponent m_Muzzle;
	BaseMagazineComponent m_Magazine;
	
	SCR_2DSightsComponent m_Sights;
	SCR_SightsZoomFOVInfo m_SightsZoomFOVInfo;
	
	WeaponUIInfo m_WeaponUI;
	MagazineUIInfo m_MagazineUI;
	MuzzleUIInfo m_MuzzleUI;
	GrenadeUIInfo m_GrenadeUI;
	
	SCR_MagazineIndicatorConfiguration m_MagazineConfig;
	
	int m_iMagCount;
	int m_iMagAmmoCount;
	int m_iMagMaxAmmoCount;
	float m_fMagAmmoPerc;
	int m_iZeroing;
	float m_fZoom;
	bool m_bShowFiremode;
	EWeaponFiremodeType m_FireModeType;
	EAmmoType m_eAmmoTypeFlags;
	bool m_bBarrelChambered;
	bool m_bBarrelCanBeChambered;
	bool m_bInADS;
	bool m_bInInspectionMode;
	bool m_bIsExplosive;
	bool m_bHasSpecialAmmo;
	bool m_bReloading;
	
	void Init()
	{
		m_Weapon = null;
		m_Muzzle = null;
		m_Magazine = null;
		
		m_Sights = null;
		m_SightsZoomFOVInfo = null;
		
		m_WeaponUI = null;
		m_MagazineUI = null;
		m_MuzzleUI = null;
		m_GrenadeUI = null;
		
		m_MagazineConfig = null;
		
		m_iMagCount = 0;
		m_iMagAmmoCount = 0;
		m_iMagMaxAmmoCount = 1;
		m_fMagAmmoPerc = 1;
		m_iZeroing = 0;
		m_fZoom = 0;
		m_bInADS = false;
		m_bInInspectionMode = false;
		m_bIsExplosive = false;
		m_bShowFiremode = false;
		m_FireModeType = EWeaponFiremodeType.Semiauto;
		m_eAmmoTypeFlags = EAmmoType.FMJ;
		m_bBarrelChambered = false;
		m_bBarrelCanBeChambered = false;
		m_bHasSpecialAmmo = false;
		m_bReloading = false;
	}
};

[EntityEditorProps(category: "GameScripted/UI/HUD/WeaponSwitchingBar", description: "Concept of quick selection bar")]

//---- REFACTOR NOTE START: This script is not made the best way and relies on delayed calls a bit too much. ----

class SCR_WeaponSwitchingBaseUI : SCR_InfoDisplay
{
	protected static ResourceName							s_sItemPreviewManagerPrefab = "{9F18C476AB860F3B}Prefabs/World/Game/ItemPreviewManager.et"; // This could be attribute
	protected static Widget									s_wQuickSlotStorage;
	protected static ref SCR_InventoryStorageQuickSlotsUI	s_QuickSlotStorage;
	protected static SCR_WeaponSwitchingBaseUI				s_WeaponSwitchingUI;

	static bool												s_bOpened;
	static bool												s_bRadial;

	[Attribute("{A1E61EF091EAC47D}UI/layouts/Menus/Inventory/InventoryQuickSlotsGrid.layout")]
	protected string m_sQuickSlotGridLayout;

	//------------------------------------------------------------------------------------------------
	static void RefreshQuickSlots(int id = -1)
	{
		if (!s_QuickSlotStorage)
			return;

		if (id < 0)
			s_QuickSlotStorage.RefreshQuickSlots();
		else
			s_QuickSlotStorage.RefreshSlot(id);

		s_QuickSlotStorage.HighlightLastSelectedSlot();
	}

	//------------------------------------------------------------------------------------------------
	static void SelectQuickSlot(int id)
	{
		bool wasOpen = s_bOpened;
		if (!wasOpen && s_WeaponSwitchingUI)
			s_WeaponSwitchingUI.OpenQuickSlots();

		if (s_QuickSlotStorage)
			s_QuickSlotStorage.SelectSlot(id);

		if (!wasOpen && s_WeaponSwitchingUI)
			s_WeaponSwitchingUI.CloseQuickSlots();
	}

	//------------------------------------------------------------------------------------------------
	static void HighlightQuickSlot(int id, bool highlight = true)
	{
		bool wasOpen = s_bOpened;
		if (!wasOpen && s_WeaponSwitchingUI)
			s_WeaponSwitchingUI.OpenQuickSlots();

		if (s_QuickSlotStorage)
			s_QuickSlotStorage.HighlightSlot(id, highlight);

		if (!wasOpen && s_WeaponSwitchingUI)
			s_WeaponSwitchingUI.CloseQuickSlots();
	}

	//------------------------------------------------------------------------------------------------
	protected void Init(IEntity owner)
	{
		if (s_WeaponSwitchingUI)
		{
			Print("More than one SCR_WeaponSwitchingBaseUI used in " + __FILE__ + " L" + __LINE__, LogLevel.WARNING);
			return;
		}

		s_WeaponSwitchingUI = this;
		s_bOpened = false;

		if (!owner || !m_wRoot)
			return;

		ChimeraWorld world = ChimeraWorld.CastFrom(owner.GetWorld());
		if (world)
		{
			//instantiate the preview manager
			if (!world.GetItemPreviewManager())
			{
				Resource rsc = Resource.Load(s_sItemPreviewManagerPrefab);
				if (rsc.IsValid())
					GetGame().SpawnEntityPrefabLocal(rsc, world);
			}
		}

		InputManager inputManager = GetGame().GetInputManager();
		inputManager.AddActionListener("Inventory_WeaponSwitching", EActionTrigger.DOWN, Action_QuickSlotsBar);
		inputManager.AddActionListener("Inventory_WeaponSwitching", EActionTrigger.UP, Action_QuickSlotsBar);
		inputManager.AddActionListener("Inventory_WeaponSwitchingRadial", EActionTrigger.DOWN, Action_QuickSlotsRadial);
		inputManager.AddActionListener("Inventory_WeaponSwitchingRadial", EActionTrigger.UP, Action_QuickSlotsRadial);

		for (int i; i < 10; ++i)
		{
			inputManager.AddActionListener("SwitchWeaponCategory" + i.ToString(), EActionTrigger.DOWN, Action_SwitchSlot);
			inputManager.AddActionListener("SwitchWeaponCategory" + i.ToString(), EActionTrigger.UP, Action_QuickSlotsBar);
		}
	}

	//------------------------------------------------------------------------------------------------
	protected void RemoveActionListeners()
	{
		InputManager inputManager = GetGame().GetInputManager();
		inputManager.RemoveActionListener("Inventory_WeaponSwitching", EActionTrigger.DOWN, Action_QuickSlotsBar);
		inputManager.RemoveActionListener("Inventory_WeaponSwitching", EActionTrigger.UP, Action_QuickSlotsBar);
		inputManager.RemoveActionListener("Inventory_WeaponSwitchingRadial", EActionTrigger.DOWN, Action_QuickSlotsRadial);
		inputManager.RemoveActionListener("Inventory_WeaponSwitchingRadial", EActionTrigger.UP, Action_QuickSlotsRadial);

		for (int i; i < 10; ++i)
		{
			inputManager.RemoveActionListener("SwitchWeaponCategory" + i.ToString(), EActionTrigger.DOWN, Action_SwitchSlot);
			inputManager.RemoveActionListener("SwitchWeaponCategory" + i.ToString(), EActionTrigger.UP, Action_QuickSlotsBar);
		}
	}

	//------------------------------------------------------------------------------------------------
	void OpenQuickSlots()
	{
		if (s_bOpened)
			return;

		ChimeraCharacter character = ChimeraCharacter.Cast(SCR_PlayerController.GetLocalControlledEntity());
		CharacterControllerComponent controller;

		if (character)
			controller = character.GetCharacterController();

		if (controller && controller.GetLifeState() != ECharacterLifeState.ALIVE)
			return;

		GetGame().GetInputManager().AddActionListener("CharacterSwitchWeapon", EActionTrigger.VALUE, Action_ScrollSlot);
		s_bOpened = true;
		GetGame().GetCallqueue().Remove(ShowQuickSlots);		// if there's a delayed Show method from the previous quick bar usage, purge it

		if (!m_wRoot)
			return;

		if (s_wQuickSlotStorage)
		{
			s_wQuickSlotStorage.RemoveHandler(s_wQuickSlotStorage.FindHandler(SCR_InventoryStorageQuickSlotsUI));
			s_wQuickSlotStorage.RemoveFromHierarchy();
		}
		Widget parent = m_wRoot.FindAnyWidget("QuickSlots");
		s_wQuickSlotStorage = GetGame().GetWorkspace().CreateWidgets(m_sQuickSlotGridLayout, parent);
		if (!s_wQuickSlotStorage)
			return;

		s_QuickSlotStorage = new SCR_InventoryStorageQuickSlotsUI(null, null, null);
		s_wQuickSlotStorage.AddHandler(s_QuickSlotStorage);
		s_QuickSlotStorage.SetInitialQuickSlot();
		s_QuickSlotStorage.HighlightLastSelectedSlot();

		Show(true, UIConstants.FADE_RATE_DEFAULT);
		BlurWidget wBlur = BlurWidget.Cast(m_wRoot.FindAnyWidget("wBlur"));

		if (wBlur)
			wBlur.SetVisible(true);

		SCR_UISoundEntity.SoundEvent(SCR_SoundEvent.SOUND_INV_HOTKEY_OPEN);

		if (!controller)
			return;

		SCR_InventoryStorageManagerComponent inventory = SCR_InventoryStorageManagerComponent.Cast(controller.GetInventoryStorageManager());
		if (inventory)
		{
			inventory.m_OnQuickBarOpenInvoker.Invoke(true);
			// Delay by 1 frame so the selected slot gets updated first
			GetGame().GetCallqueue().Call(ShowCommand, inventory);
		}
	}

	//------------------------------------------------------------------------------------------------
	void CloseQuickSlots()
	{
		if (s_QuickSlotStorage)
			s_QuickSlotStorage.SetQuickBarClosed();

		GetGame().GetInputManager().RemoveActionListener("CharacterSwitchWeapon", EActionTrigger.VALUE, Action_ScrollSlot);
		s_bOpened = false;

		if (!m_wRoot)
			return;

		BlurWidget wBlur = BlurWidget.Cast(m_wRoot.FindAnyWidget("wBlur"));
		if (wBlur)
			wBlur.SetVisible(false);

		if (s_QuickSlotStorage && s_QuickSlotStorage.UseItemInSlot())
			GetGame().GetCallqueue().CallLater(ShowQuickSlots, 2000, false, false, UIConstants.FADE_RATE_DEFAULT, true);
		else
			Show(false, UIConstants.FADE_RATE_DEFAULT);

		SCR_ChimeraCharacter character = SCR_ChimeraCharacter.Cast(SCR_PlayerController.GetLocalControlledEntity());
		if (!character)
			return;

		CharacterControllerComponent controller = character.GetCharacterController();
		if (!controller)
			return;

		SCR_InventoryStorageManagerComponent inventory = SCR_InventoryStorageManagerComponent.Cast(controller.GetInventoryStorageManager());
		if (inventory)
			inventory.m_OnQuickBarOpenInvoker.Invoke(false);
		
		SCR_PlayerControllerCommandingComponent commandComp = SCR_PlayerControllerCommandingComponent.GetLocalPlayerControllerCommandingComponent();
		if (commandComp)
			commandComp.HideCommandPreview();
	}

	//------------------------------------------------------------------------------------------------
	protected void ShowCommand(notnull SCR_InventoryStorageManagerComponent inventory)
	{
		SCR_CharacterInventoryStorageComponent characterStorage = inventory.GetCharacterStorage();
		if (!characterStorage)
			return;

		SCR_QuickslotCommandContainer commandQuickSlotContainer = SCR_QuickslotCommandContainer.Cast(characterStorage.GetContainerFromQuickslot(s_QuickSlotStorage.GetLastSelectedSlotIndex()));
		if (!commandQuickSlotContainer)
			return;
		
		SCR_PlayerControllerCommandingComponent commandComp = SCR_PlayerControllerCommandingComponent.GetLocalPlayerControllerCommandingComponent();
		if (!commandComp)
			return;
		
		commandComp.ShowCommandPreview(commandQuickSlotContainer.GetCommandName());
	}
	
	//------------------------------------------------------------------------------------------------
	protected void Action_QuickSlotsRadial(float value = 0.0, EActionTrigger reason = 0)
	{
		bool radial = reason == EActionTrigger.DOWN;

		if (!s_bOpened)
		{
			s_bRadial = radial;
			return;
		}
		

		// Restart the quick slots bar
		if (radial != s_bRadial)
		{
			s_bRadial = radial;
			CloseQuickSlots();
			OpenQuickSlots();
		}
	}

	//------------------------------------------------------------------------------------------------
	protected void Action_QuickSlotsBar(float value = 0.0, EActionTrigger reason = 0)
	{
		if (reason == EActionTrigger.DOWN)
			OpenQuickSlots();
		else
			CloseQuickSlots();
	}

	//------------------------------------------------------------------------------------------------
	protected void Action_SwitchSlot(float value = 0.0, EActionTrigger reason = 0)
	{
		int targetSlot = -1;

		InputManager inputManager = GetGame().GetInputManager();
		if (inputManager.GetActionTriggered("SwitchWeaponCategory1"))
			targetSlot = 0;
		else if (inputManager.GetActionTriggered("SwitchWeaponCategory2"))
			targetSlot = 1;
		else if (inputManager.GetActionTriggered("SwitchWeaponCategory3"))
			targetSlot = 2;
		else if (inputManager.GetActionTriggered("SwitchWeaponCategory4"))
			targetSlot = 3;
		else if (inputManager.GetActionTriggered("SwitchWeaponCategory5"))
			targetSlot = 4;
		else if (inputManager.GetActionTriggered("SwitchWeaponCategory6"))
			targetSlot = 5;
		else if (inputManager.GetActionTriggered("SwitchWeaponCategory7"))
			targetSlot = 6;
		else if (inputManager.GetActionTriggered("SwitchWeaponCategory8"))
			targetSlot = 7;
		else if (inputManager.GetActionTriggered("SwitchWeaponCategory9"))
			targetSlot = 8;
		else if (inputManager.GetActionTriggered("SwitchWeaponCategory0"))
			targetSlot = 9;

		if (targetSlot < 0)
			return;

		if (s_bOpened && s_bRadial)
			CloseQuickSlots();

		s_bRadial = false;
		OpenQuickSlots();

		SelectQuickSlot(targetSlot);
	}

	//------------------------------------------------------------------------------------------------
	protected void Action_ScrollSlot(float value = 0.0, EActionTrigger reason = 0)
	{
		if (!s_bOpened || !s_QuickSlotStorage)
			return;

		if (float.AlmostEqual(value, 0))
			return;

		s_QuickSlotStorage.SelectSlot(value);
	}

	//------------------------------------------------------------------------------------------------
	override void UpdateValues(IEntity owner, float timeSlice)
	{
		if (!s_bOpened)
			return;

		GetGame().GetInputManager().ActivateContext("WeaponSelectionContext");
	}

	protected void ShowQuickSlots(bool show, float speed = UIConstants.FADE_RATE_DEFAULT)
	{
		Show(show, speed);
	}

	//------------------------------------------------------------------------------------------------
	override event void OnStartDraw(IEntity owner)
	{
		super.OnStartDraw(owner);
		Init(owner);
		Show(false, 0);
	}

	//------------------------------------------------------------------------------------------------
	override event void OnStopDraw(IEntity owner)
	{
		super.OnStopDraw(owner);
		RemoveActionListeners();
		s_QuickSlotStorage = null;
	}
	
	//------------------------------------------------------------------------------------------------
	static SCR_WeaponSwitchingBaseUI GetWeaponSwitchingBaseUI()
	{
		return s_WeaponSwitchingUI;
	}
}

class SCR_QuickSlotRefreshCB : ScriptedInventoryOperationCallback
{
	override void OnComplete()
	{
		SCR_WeaponSwitchingBaseUI.RefreshQuickSlots();
	}
}

//---- REFACTOR NOTE START: This code will need to be refactored as current implementation is not conforming to the standards ----

//------------------------------------------------------------------------------------------------
//! SCR_WeaponLib Class
//!
//! Contains weapon related script functions
//------------------------------------------------------------------------------------------------
class SCR_WeaponLib
{
	//-----------------------------------------------------------------------------------------------------------
	//! Returns BaseWeaponComponent of current weapon
	static BaseWeaponComponent GetCurrentWeaponComponent(notnull ChimeraCharacter owner)
	{
		// Detect weapon manager
		CharacterControllerComponent controller = owner.GetCharacterController();
		if (!controller)
			return null;

		BaseWeaponManagerComponent weaponManager = controller.GetWeaponManagerComponent();
		if (!weaponManager)
			return null;

		BaseWeaponComponent weapon = SCR_WeaponLib.GetCurrentWeaponComponent(weaponManager);
	
		return weapon;
	}

	//-----------------------------------------------------------------------------------------------------------
	//! Returns BaseWeaponComponent of current weapon
	static BaseWeaponComponent GetCurrentWeaponComponent(notnull BaseWeaponManagerComponent weaponManager)
	{
		// Get weapon OR weapon slot
		BaseWeaponComponent weapon = weaponManager.GetCurrent();		
		if (!weapon) 
			return null;	
		
		// Try casting to weapon slot to check if it's weapon slot OR weapon
		WeaponSlotComponent weaponSlot = WeaponSlotComponent.Cast(weapon);
		
		// Weapon slot detected, retrieve weapon from it
		if (weaponSlot)
		{
			IEntity weaponEntity = weaponSlot.GetWeaponEntity();
			if (!weaponEntity) 
				return null;
		
			BaseWeaponComponent wpnComponent = BaseWeaponComponent.Cast(weaponEntity.FindComponent(BaseWeaponComponent));
			if (!wpnComponent) 
				return null;
			
			weapon = wpnComponent;
		}
	
		return weapon;
	}

	//-----------------------------------------------------------------------------------------------------------
	//! Returns true if current weapon has component we are testing
	static bool CurrentWeaponHasComponent(notnull BaseWeaponManagerComponent weaponManager, typename component)
	{
		BaseWeaponComponent weapon = weaponManager.GetCurrent();
		if (!weapon) 
			return false;
		
		// Try casting to weapon slot to check if it's weapon slot OR weapon
		WeaponSlotComponent weaponSlot = WeaponSlotComponent.Cast(weapon);
		
		// Weapon slot detected, retrieve weapon from it
		if (weaponSlot)
		{
			IEntity weaponEntity = weaponSlot.GetWeaponEntity();
			if (weaponEntity && weaponEntity.FindComponent(component))
				return true;
		}
	
		return false;
	}
	
	//------------------------------------------------------------------------------------------------
	//! Get ID of next muzzle
	static int GetNextMuzzleID(notnull BaseWeaponComponent weapon)
	{
		array<BaseMuzzleComponent> muzzles = {};
		weapon.GetMuzzlesList(muzzles);
		if (muzzles.IsEmpty())
			return -1;
		
		int currentMuzzleID = muzzles.Find(weapon.GetCurrentMuzzle());
		
		return (currentMuzzleID + 1) % muzzles.Count();
	}
};
/*
===========================================
Do not modify, this script is generated
===========================================
*/

/*!
\addtogroup Weapon
\{
*/

class WeaponSlotComponent: BaseWeaponComponent
{
	proto external InventoryStorageSlot GetSlotInfo();
	proto external void SetWeapon(IEntity weaponEntity);
	proto external IEntity GetWeaponEntity();
	proto external int GetWeaponSlotIndex();
}

/*!
\}
*/
/*
===========================================
Do not modify, this script is generated
===========================================
*/

/*!
\addtogroup Weapon
\{
*/

class WeaponSlotComponentClass: BaseWeaponComponentClass
{
}

/*!
\}
*/
/*
===========================================
Do not modify, this script is generated
===========================================
*/

/*!
\addtogroup Components
\{
*/

class WeaponSoundComponentClass: SoundComponentClass
{
}

class WeaponSoundComponent: SoundComponent
{
}

/*!
\}
*/
/*
===========================================
Do not modify, this script is generated
===========================================
*/

/*!
\addtogroup Weapon
\{
*/

class WeaponComponentClass: BaseWeaponComponentClass
{
}

class WeaponComponent: BaseWeaponComponent
{
	//! Set/Clear the active flags to all attachements on this weapon
	proto external void ActivateAttachments(bool active);
}

/*!
\}
*/
/*
===========================================
Do not modify, this script is generated
===========================================
*/

/*!
\addtogroup Weapon
\{
*/

class WeaponAnimationComponentClass: BaseItemAnimationComponentClass
{
}

class WeaponAnimationComponent: BaseItemAnimationComponent
{
	proto external bool GetBipod();
	proto external bool HasBipod();
	proto external void SetBipod(bool open, bool fastForwardAnimations = false);
	proto external void FoldWeapon(bool fastForwardAnimations = false);
	proto external void UnfoldWeapon(bool fastForwardAnimations = false);
	proto external bool IsFolded();
}

/*!
\}
*/
/*
===========================================
Do not modify, this script is generated
===========================================
*/

/*!
\addtogroup Weapon
\{
*/

class SwayWeaponAimModifier: BaseWeaponAimModifier
{
	//! How much sway is the weapon experiencing from stance, stamina and damage.
	proto external float GetCharacterWeaponSway();
}

/*!
\}
*/
/*
===========================================
Do not modify, this script is generated
===========================================
*/

/*!
\addtogroup Weapons
\{
*/

/*!
Object that is passed into AimModifier(s) to influence
their behavior by providing situational context.
*/
class WeaponAimModifierContext: Managed
{
}

/*!
\}
*/
/*
===========================================
Do not modify, this script is generated
===========================================
*/

/*!
\addtogroup Weapon
\{
*/

enum EWeaponType
{
	WT_NONE,
	WT_RIFLE,
	WT_GRENADELAUNCHER,
	WT_SNIPERRIFLE,
	WT_ROCKETLAUNCHER,
	WT_MACHINEGUN,
	WT_HANDGUN,
	WT_FRAGGRENADE,
	WT_SMOKEGRENADE,
	WT_COUNT,
}

/*!
\}
*/
