//! A scripted action class having optional logic for playing audio as well as checking if the faction is valid
class SCR_BaseAudioScriptedUserAction : SCR_ScriptedUserAction
{
	[Attribute(desc: "Sound effect played when action is exectuted")]
	protected string m_sActionSoundEffectEventName;
	
	[Attribute(desc: "File that contains the sound effect. Only used as backup if SFX was not played by the SoundComponent on the entity", params: "acp")]
	protected ResourceName m_sActionSoundEffectFile;
	
	//================================================== PERFORM ==================================================\\
	override void PerformAction(IEntity pOwnerEntity, IEntity pUserEntity) 
 	{
		PlayActionSoundEffect(pOwnerEntity);
	}
	
	//================================================== AUDIO ==================================================\\
	protected void PlayActionSoundEffect(IEntity pOwnerEntity)
	{
		if (!pOwnerEntity)
			return;
		
		if (SCR_StringHelper.IsEmptyOrWhiteSpace(m_sActionSoundEffectEventName))
			return;
		
		//~ Get sound component
		SoundComponent soundComponent = SoundComponent.Cast(pOwnerEntity.FindComponent(SoundComponent));
		
		//~ Has sound component. Play sound with that offset
		if (soundComponent)
		{			
			//~ Check if sound was played. If true simply play it and return
			if (soundComponent.GetEventIndex(m_sActionSoundEffectEventName) != -1)
			{
				soundComponent.SoundEventOffset(m_sActionSoundEffectEventName, GetLocalPositionAction());
				return;
			}
			else 
			{
				Print(string.Format("'SCR_BaseAudioScriptedUserAction': Trying to play sound for '%1' but sound either sound event '%2' or more likely sound file needed is not included on the SoundComponent! SCR_SoundManagerEntity is used instead (if any in the world) but that means position of sound is not updated if entity moves while sound is playing.", pOwnerEntity, m_sActionSoundEffectEventName, m_sActionSoundEffectFile), LogLevel.WARNING);
			}				
		}
		
		if (SCR_StringHelper.IsEmptyOrWhiteSpace(m_sActionSoundEffectFile))
			return;
		
		//~ No sound manager
		SCR_SoundManagerEntity soundManagerEntity = GetGame().GetSoundManagerEntity();
		if (!soundManagerEntity)
			return;
		
		vector transform[4];
		vector mat[4];
		pOwnerEntity.GetTransform(mat);
		transform[3] = GetWorldPositionAction();
		
		//~ Create new config
		SCR_AudioSourceConfiguration audioConfig = new SCR_AudioSourceConfiguration();
		audioConfig.m_sSoundProject = m_sActionSoundEffectFile;
		audioConfig.m_sSoundEventName = m_sActionSoundEffectEventName;
		audioConfig.m_eFlags = SCR_Enum.RemoveFlag(audioConfig.m_eFlags, EAudioSourceConfigurationFlag.Static);
	
		//~  Play sound
		soundManagerEntity.CreateAndPlayAudioSource(pOwnerEntity, audioConfig, transform);
	}
};

void UserActionEventListener(IEntity user, ScriptedUserAction action, EUserActionEvent e);
typedef func UserActionEventListener;

//! A scripted action class having optional logic to check if vehicle is valid
class SCR_ScriptedUserAction : ScriptedUserAction
{
	[Attribute("1", desc: "If action is Continuous and duration is less than 0 than the UI process bar goes to 0 again if it reaches the perform action amount")]
	protected bool m_bLoopAction;

	[Attribute("0.25", desc: "If action is looping this will be used to delay the action after it reaches 100% to prevent the action from instantly looping", params: "0 inf")]
	protected float m_fLoopActionHoldDuration;

	[Attribute("0", desc: "Using this action should automatically lower player weapon")]
	protected bool m_bLowerWeaponOnUse;

	[Attribute("0", desc: "When can the action be shown regarding the vehicle you are in. Note only checked for vehicle that the action is attached to. IGNORE will never check vehicle state", uiwidget: UIWidgets.SearchComboBox, enums: ParamEnumArray.FromEnum(EUserActionInVehicleState))]
	protected EUserActionInVehicleState m_eShownInVehicleState;

	[Attribute("1", desc: "Whether this action can only be performed by occupants of the same vehicle (if in vehicle)", uiwidget: UIWidgets.CheckBox)]
	protected bool m_bSameVehicleOnly;

	protected UserActionContext m_LastUserActionContext; //~ Last user action context when the action was selected. used for getting the action position

	//~ Keeps track of action duration if LoopUpdate is used
	protected float m_fLoopProgress;
	protected float m_fLoopProgressSmoothVelocity;

	//================================================== CAN SHOW ==================================================\\
	override bool CanBeShownScript(IEntity user)
	{
		if (m_eShownInVehicleState == EUserActionInVehicleState.IGNORE)
			return true;

		//~ Only check when character
		ChimeraCharacter character = ChimeraCharacter.Cast(GetOwner());
		if (!character)
		{
			character = ChimeraCharacter.Cast(user);
			if (!character)
				return true;
		}

		//~ Only check when has compartment access
		CompartmentAccessComponent compAccess = character.GetCompartmentAccessComponent();
		if (!compAccess)
			return true;

		//~ Never show when getting in or out vehicle
		if (compAccess.IsGettingIn() || compAccess.IsGettingOut())
			return false;

		//~ Is character in vehicle?
		bool isCharacterInVehicle = character.IsInVehicle();

		//~ Check if correct state
		switch (m_eShownInVehicleState)
		{
			//~ Character should not be in vehicle
			case EUserActionInVehicleState.NOT_IN_VEHICLE :
			{
				if (isCharacterInVehicle)
					return false;

				break;
			}
			//~ Check if character is in current vehicle and is in any position
			case EUserActionInVehicleState.IN_VEHICLE_ANY :
			{
				if (!isCharacterInVehicle)
					return false;

				break;
			}
			//~ Check if character is in current vehicle and pilot
			case EUserActionInVehicleState.IN_VEHICLE_PILOT :
			{
				if (!isCharacterInVehicle || compAccess.GetCompartment().GetType() != ECompartmentType.PILOT)
					return false;

				break;
			}
			//~ Check if character is in current vehicle and cargo
			case EUserActionInVehicleState.IN_VEHICLE_CARGO :
			{
				if (!isCharacterInVehicle || compAccess.GetCompartment().GetType() != ECompartmentType.CARGO)
					return false;

				break;
			}
			//~ Check if character is in current vehicle and turret
			case EUserActionInVehicleState.IN_VEHICLE_TURRET :
			{
				if (!isCharacterInVehicle || compAccess.GetCompartment().GetType() != ECompartmentType.TURRET)
					return false;

				break;
			}
		}

		//~ Disallow actions from being performed from the outside of a vehicle or the other way around, unless they are in the same vehicle (if set)
		if (isCharacterInVehicle && m_bSameVehicleOnly)
			return IsSameVehicleOrNone(character);

		//~ All passed so return true
		return true;
	}

	//------------------------------------------------------------------------------------------------
	protected bool IsSameVehicleOrNone(notnull IEntity user)
	{

		// See if user can even access compartments
		CompartmentAccessComponent userCompAccess;

		// Use cached getter for character, but don't hinder logic for non-character users
		ChimeraCharacter userCharacter = ChimeraCharacter.Cast(user);
		if (userCharacter)
			userCompAccess = userCharacter.GetCompartmentAccessComponent();
		else
			userCompAccess = CompartmentAccessComponent.Cast(user.FindComponent(CompartmentAccessComponent));

		if (!userCompAccess)
			return true; // Not really relevant

		IEntity owner = GetOwner();
		CompartmentAccessComponent ownerAccess = CompartmentAccessComponent.Cast(owner.FindComponent(CompartmentAccessComponent));
		if (!ownerAccess)
		{
			// If owner does not have comparment access, perhaps it is a vehicle itself?
			Vehicle vehicle = Vehicle.Cast(owner);
			if (!vehicle)
				return true; // No access, not relevant either

			IEntity userVehicle = userCompAccess.GetVehicleIn(user);
			return userVehicle == vehicle; // Same vehicle
		}

		// If both can access compartments, see if they are within the same vehicle
		IEntity userVehicle = userCompAccess.GetVehicleIn(user);
		IEntity ownerVehicle = ownerAccess.GetVehicleIn(owner);
		return userVehicle == ownerVehicle;
	}

	//================================================== GETTERS ==================================================\\
	/*!
	Get action local position
	Used for such things like playing audio at the correct location on action use
	\return action local position
	*/
	vector GetLocalPositionAction()
	{
		if (!m_LastUserActionContext)
			return vector.Zero;

		return GetOwner().CoordToLocal(m_LastUserActionContext.GetOrigin());
	}

	//------------------------------------------------------------------------------------------------
	/*!
	Get action world position
	Used for such things like playing audio at the correct location on action use
	\return action world position
	*/
	vector GetWorldPositionAction()
	{
		if (!m_LastUserActionContext)
			return GetOwner().GetOrigin();

		return m_LastUserActionContext.GetOrigin();
	}

	//------------------------------------------------------------------------------------------------
	//~ Update for looping actions. Make sure duration is set to less than 0 and perform continues is true.
	//~ Will return true if a loop was successfully completed
	protected bool LoopActionUpdate(float timeSlice)
	{
		float lastLoopProgress = m_fLoopProgress;

		m_fLoopProgress -= timeSlice;

		bool bLoopDone = false;

		//~ Is loop done ?
		if (lastLoopProgress > 0 && m_fLoopProgress <= 0)
			bLoopDone = true; // Loop Done

		// Is hold duration done ?
		if (m_fLoopProgress < -m_fLoopActionHoldDuration)
		{
			// Hold duration (after loop done) is over.
			m_fLoopProgress = Math.AbsFloat(GetActionDuration()) + m_fLoopActionHoldDuration + m_fLoopProgress;
		}

		return bLoopDone;
	}

	//------------------------------------------------------------------------------------------------
	/*!
	\return progress value for action progressbar UI.
	*/
	override float GetActionProgressScript(float fProgress, float timeSlice)
	{
		fProgress = fProgress + timeSlice;

		if (!IsActionLooping())
			return fProgress;

		float actionDuration = Math.AbsFloat(GetActionDuration());
		float totalDuration = actionDuration + m_fLoopActionHoldDuration;

		fProgress = Math.Min(Math.Mod(fProgress, totalDuration), actionDuration); // updated every frame
		float fTargetProgress = Math.Min(totalDuration - (m_fLoopProgress + m_fLoopActionHoldDuration), actionDuration); // update every fixed frame

		return Math.SmoothCD(fProgress, fTargetProgress, m_fLoopProgressSmoothVelocity, 0.01, 1000, timeSlice);
	}

	//------------------------------------------------------------------------------------------------
	/*!
	\return True if action process bar should reset if the action is continues. Else return false
	*/
	bool IsActionLooping()
	{
		return m_bLoopAction && ShouldPerformPerFrame() && GetActionDuration() < 0;
	}

	//------------------------------------------------------------------------------------------------
	/*!
	\return Duration of loop action being held at the end of the looping of the action
	*/
	float GetLoopActionHoldDuration()
	{
		return m_fLoopActionHoldDuration;
	}

	//------------------------------------------------------------------------------------------------
	protected override void OnActionSelected()
	{
		m_LastUserActionContext = GetActiveContext();
	}

	//------------------------------------------------------------------------------------------------
	override void OnActionStart(IEntity pUserEntity)
	{
		m_LastUserActionContext = GetActiveContext();

		//~ Used for looping actions
		if (ShouldPerformPerFrame())
			m_fLoopProgress = Math.AbsFloat(GetActionDuration());

		if (m_bLowerWeaponOnUse)
		{
			if (SCR_PlayerController.GetLocalControlledEntity() != pUserEntity)
			{
				RplComponent rplComp = RplComponent.Cast(pUserEntity.FindComponent(RplComponent));
				if (rplComp && !rplComp.IsOwner())
					return;
			}

			ChimeraCharacter character = ChimeraCharacter.Cast(pUserEntity);
			if (!character)
				return;

			CharacterControllerComponent contr = character.GetCharacterController();
			if (!contr)
				return;

			if (contr.CanPartialLower() && !contr.IsPartiallyLowered())
				contr.SetPartialLower(true);
		}
	}
}

//------------------------------------------------------------------------------------------------
//~ When can the action be shown
enum EUserActionInVehicleState
{
	IGNORE = 0,
	NOT_IN_VEHICLE = 10,
	IN_VEHICLE_ANY = 20,
	IN_VEHICLE_PILOT = 30,
	IN_VEHICLE_TURRET = 40,
	IN_VEHICLE_CARGO = 50,
}

/*
===========================================
Do not modify, this script is generated
===========================================
*/

/*!
\addtogroup UserAction
\{
*/

class ScriptedUserAction: BaseUserAction
{
	//! Called when object is initialized and registered to actions manager
	event void Init(IEntity pOwnerEntity, GenericComponent pManagerComponent);
	//! Called when someone tries to perform the action, user entity is typically character
	event void PerformAction(IEntity pOwnerEntity, IEntity pUserEntity);
	//! Called when someone tries to perform the continuous action, user entity is typically character
	event void PerformContinuousAction(IEntity pOwnerEntity, IEntity pUserEntity, float timeSlice);
	//! If action passed as callback OnConfirmed will be called when reached execution, user entity is typically character
	event void OnConfirmed(IEntity pUserEntity);
	//! If action passed as callback OnRejected will be called when execution was rejected, user entity is typically character
	event void OnRejected(IEntity pUserEntity);
	//! Method called when the action is interrupted/canceled.
	//! \param pUserEntity The entity that was performing this action prior to interruption
	event void OnActionCanceled(IEntity pOwnerEntity, IEntity pUserEntity) { };
	//! Method called from scripted interaction handler when an action is started (progress bar appeared)
	//! \param pUserEntity The entity that started performing this action
	event void OnActionStart(IEntity pUserEntity) { };
	//! If overridden and true is returned, outName is returned when BaseUserAction.GetActionName is called.
	//! If not overridden or false is returned the default value from UIInfo is taken (or empty string if no UI info exists)
	event bool GetActionNameScript(out string outName) { return false; };
	//! If overridden and true is returned, outName is returned when BaseUserAction.GetActionDescription is called.
	//! If not overridden or false is returned the default value from UIInfo is taken (or empty string if no UI info exists)
	event bool GetActionDescriptionScript(out string outName) { return false; };
	//! Can this action be performed by the provided user entity?
	event bool CanBePerformedScript(IEntity user) { return true; };
	//! Can this entity be shown in the UI by the provided user entity?
	event bool CanBeShownScript(IEntity user) { return true; };
	//! Does this action only have client side effect?
	event bool HasLocalEffectOnlyScript() { return false; };
	//! If HasLocalEffectOnly() is false this method tells if the server is supposed to broadcast this action to clients.
	event bool CanBroadcastScript() { return true; };
	//! Returns the progress of this action in seconds.
	event float GetActionProgressScript(float fProgress, float timeSlice) { return fProgress + timeSlice; };
}

/*!
\}
*/

class RplExampleDebugShapeClass: GenericEntityClass {}
RplExampleDebugShapeClass g_RplExampleDebugShapeClassInst;

class RplExampleDebugShape : GenericEntity
{
	static const int COLOR_COUNT = 4;
	static const int COLORS[] = {
		Color.BLACK,
		Color.RED,
		Color.GREEN,
		Color.BLUE,
	};

	private int m_Color;

	void RplExampleDebugShape(IEntitySource src, IEntity parent)
	{
		this.SetEventMask(EntityEvent.FRAME);
	}

	override void EOnFrame(IEntity owner, float timeSlice)
	{
		vector worldTransform[4];
		this.GetWorldTransform(worldTransform);
		Shape.CreateSphere(m_Color, ShapeFlags.ONCE, worldTransform[3], 0.5);
	}

	bool SetColorByIdx(int colorIdx)
	{
		if (colorIdx < 0 || colorIdx >= COLOR_COUNT)
			return false;

		m_Color = COLORS[colorIdx];
		return true;
	}
}
//! [Replication example common shape]

//! [Replication example 1]
class RplExample1ComponentColorAnimClass : ScriptComponentClass { }
RplExample1ComponentColorAnimClass g_RplExample1ComponentColorAnimClass;

class RplExample1ComponentColorAnim : ScriptComponent
{
	// Constant specifying how often (in seconds) to change the color index. For
	// example, setting this to 5 will change the color index every 5 seconds.
	private static const float COLOR_CHANGE_PERIOD_S = 5.0;

	// Helper variable for accumulating time (in seconds) every frame and to calculate
	// color index changes.
	private float m_TimeAccumulator_s;

	// Color index currently used for drawing the sphere.
	private int m_ColorIdx;

	override void OnPostInit(IEntity owner)
	{
		// We check whether this component is attached to entity of correct type and
		// report a problem if not. Once this test passes during initialization, we
		// do not need to worry about owner entity being wrong type anymore.
		auto shapeEnt = RplExampleDebugShape.Cast(owner);
		if (!shapeEnt)
		{
			Print("This example requires that the entity is of type `RplExampleDebugShape`.", LogLevel.WARNING);
			return;
		}

		// We initialize shape entity to correct color.
		shapeEnt.SetColorByIdx(m_ColorIdx);

		// We subscribe to "frame" events, so that we can run our logic in `EOnFrame`
		// event handler.
		SetEventMask(owner, EntityEvent.FRAME);
	}

	override void EOnFrame(IEntity owner, float timeSlice)
	{
		// We calculate change of color index based on time (and configured color
		// change period), then apply the change in color.
		int colorIdxDelta = CalculateColorIdxDelta(timeSlice);
		ApplyColorIdxDelta(owner, colorIdxDelta);
	}

	private int CalculateColorIdxDelta(float timeSlice)
	{
		// We first accumulate time and then calculate how many color change periods
		// have occurred, giving us number of colors we've cycled through.
		m_TimeAccumulator_s += timeSlice;
		int colorIdxDelta = m_TimeAccumulator_s / COLOR_CHANGE_PERIOD_S;

		// We remove full periods from the accumulator, only carrying over how much
		// time from current period has elapsed.
		m_TimeAccumulator_s -= colorIdxDelta * COLOR_CHANGE_PERIOD_S;

		return colorIdxDelta;
	}

	private void ApplyColorIdxDelta(IEntity owner, int colorIdxDelta)
	{
		// If there is no change to color index, we do nothing.
		if (colorIdxDelta == 0)
			return;

		// We calculate new color index.
		int newColorIdx = (m_ColorIdx + colorIdxDelta) % RplExampleDebugShape.COLOR_COUNT;

		// We check also new color index, since shorter periods and lower frame-rate
		// may result in new and old color index values being the same.
		if (newColorIdx == m_ColorIdx)
			return;

		// Now we can update the color index ...
		m_ColorIdx = newColorIdx;

		// ... and set new color based on new color index value.
		RplExampleDebugShape.Cast(owner).SetColorByIdx(m_ColorIdx);
	}
}
//! [Replication example 1]

//! [Replication example 2]
class RplExample2ComponentColorAnimClass : ScriptComponentClass { }
RplExample2ComponentColorAnimClass g_RplExample2ComponentColorAnimClass;

class RplExample2ComponentColorAnim : ScriptComponent
{
	private static const float COLOR_CHANGE_PERIOD_S = 5.0;

	private float m_TimeAccumulator_s;

	//! [Replication example 2 - color index as replicated property]
	// We mark color index as replicated property using RplProp attribute, making
	// it part of replicated state. We also say we want OnColorIdxChanged function
	// to be invoked whenever replication updates value of color index.
	[RplProp(onRplName: "OnColorIdxChanged")]
	private int m_ColorIdx;
	//! [Replication example 2 - color index as replicated property]

	//! [Replication example 2 - changes in initialization]
	override void OnPostInit(IEntity owner)
	{
		auto shapeEnt = RplExampleDebugShape.Cast(owner);
		if (!shapeEnt)
		{
			Print("This example requires that the entity is of type `RplExampleDebugShape`.", LogLevel.WARNING);
			return;
		}

		shapeEnt.SetColorByIdx(m_ColorIdx);

		// We must belong to some RplComponent in order for replication to work.
		// We search for it and warn user when we can't find it.
		auto rplComponent = BaseRplComponent.Cast(shapeEnt.FindComponent(BaseRplComponent));
		if (!rplComponent)
		{
			Print("This example requires that the entity has an RplComponent.", LogLevel.WARNING);
			return;
		}

		// We only perform simulation on the authority instance, while all proxy
		// instances just show result of the simulation. Therefore, we only have to
		// subscribe to "frame" events on authority, leaving proxy instances as
		// passive components that do something only when necessary.
		if (rplComponent.Role() == RplRole.Authority)
		{
			SetEventMask(owner, EntityEvent.FRAME);
		}
	}
	//! [Replication example 2 - changes in initialization]

	override void EOnFrame(IEntity owner, float timeSlice)
	{
		int colorIdxDelta = CalculateColorIdxDelta(timeSlice);
		ApplyColorIdxDelta(owner, colorIdxDelta);
	}

	private int CalculateColorIdxDelta(float timeSlice)
	{
		m_TimeAccumulator_s += timeSlice;
		int colorIdxDelta = m_TimeAccumulator_s / COLOR_CHANGE_PERIOD_S;
		m_TimeAccumulator_s -= colorIdxDelta * COLOR_CHANGE_PERIOD_S;
		return colorIdxDelta;
	}

	//! [Replication example 2 - changes in color index update and application]
	private void ApplyColorIdxDelta(IEntity owner, int colorIdxDelta)
	{
		if (colorIdxDelta == 0)
			return;

		int newColorIdx = (m_ColorIdx + colorIdxDelta) % RplExampleDebugShape.COLOR_COUNT;
		if (newColorIdx == m_ColorIdx)
			return;

		// Update replicated state with results from the simulation.
		m_ColorIdx = newColorIdx;

		// After we have written new value of color index, we let replication know
		// that there are changes in our state that need to be replicated to proxies.
		// Without this call, even if we change our color index, new value would not
		// be replicated to proxies.
		Replication.BumpMe();

		// Presentation of replicated state on authority.
		RplExampleDebugShape.Cast(owner).SetColorByIdx(m_ColorIdx);
	}

	// Presentation of replicated state on proxy.
	private void OnColorIdxChanged()
	{
		RplExampleDebugShape.Cast(GetOwner()).SetColorByIdx(m_ColorIdx);
	}
	//! [Replication example 2 - changes in color index update and application]
}
//! [Replication example 2]

//! [Replication example 3]
class RplExample3ComponentColorAnimClass : ScriptComponentClass { }
RplExample3ComponentColorAnimClass g_RplExample3ComponentColorAnimClass;

class RplExample3ComponentColorAnim : ScriptComponent
{
	[RplProp(onRplName: "OnColorIdxChanged")]
	private int m_ColorIdx;

	override void OnPostInit(IEntity owner)
	{
		auto shapeEnt = RplExampleDebugShape.Cast(owner);
		if (!shapeEnt)
		{
			Print("This example requires that the entity is of type `RplExampleDebugShape`.", LogLevel.WARNING);
			return;
		}

		shapeEnt.SetColorByIdx(m_ColorIdx);

		auto rplComponent = BaseRplComponent.Cast(shapeEnt.FindComponent(BaseRplComponent));
		if (!rplComponent)
		{
			Print("This example requires that the entity has an RplComponent.", LogLevel.WARNING);
			return;
		}
	}

	void NextColor()
	{
		m_ColorIdx = (m_ColorIdx + 1) % RplExampleDebugShape.COLOR_COUNT;
		Replication.BumpMe();
		RplExampleDebugShape.Cast(GetOwner()).SetColorByIdx(m_ColorIdx);
	}

	private void OnColorIdxChanged()
	{
		RplExampleDebugShape.Cast(GetOwner()).SetColorByIdx(m_ColorIdx);
	}
}

class RplExample3SystemClass : ScriptComponentClass { }
RplExample3SystemClass g_RplExample3SystemClassInst;

class RplExample3System : ScriptComponent
{
	static const ResourceName s_ControllerPrefab = "{65B426E2CD4049C3}kroslakmar/RplExampleController.et";
	static const ResourceName s_SpherePrefab = "{1AD0012447ACCE3F}kroslakmar/RplExampleShape.et";

	ref RplExample3SessionListener m_SessionListener = new RplExample3SessionListener(this);
	ref map<RplIdentity, RplExample3Controller> m_Controllers = new map<RplIdentity, RplExample3Controller>();

	ref array<RplExample3ComponentColorAnim> m_Spheres = new array<RplExample3ComponentColorAnim>();

	override void OnPostInit(IEntity owner)
	{
		if (g_Game.InPlayMode())
			SetEventMask(owner, EntityEvent.INIT);
	}

	override void EOnInit(IEntity owner)
	{
		RplMode mode = RplSession.Mode();
		if (mode != RplMode.Client)
		{
			RplSession.RegisterCallbacks(m_SessionListener);
		}

		if (mode == RplMode.None || mode == RplMode.Listen)
		{
			RplExample3Controller controller = NewController(RplIdentity.Local());
			controller.RplGiven(null);
		}

		Resource prefab = Resource.Load(s_SpherePrefab);
		EntitySpawnParams spawnParams = new EntitySpawnParams();
		spawnParams.TransformMode = ETransformMode.WORLD;
		owner.GetWorldTransform(spawnParams.Transform);
		float xBase = spawnParams.Transform[3][0];
		float yBase = spawnParams.Transform[3][1] + 2.0;
		for (int y = -1; y <= 1; y++)
		for (int x = -1; x <= 1; x++)
		{
			spawnParams.Transform[3][0] = xBase + x;
			spawnParams.Transform[3][1] = yBase + y;
			IEntity ent = g_Game.SpawnEntityPrefab(prefab, owner.GetWorld(), spawnParams);
			m_Spheres.Insert(RplExample3ComponentColorAnim.Cast(
				ent.FindComponent(RplExample3ComponentColorAnim)
			));
		}
	}

	RplExample3Controller NewController(RplIdentity identity)
	{
		ref Resource controllerPrefab = Resource.Load(s_ControllerPrefab);
		auto controller = RplExample3Controller.Cast(
			g_Game.SpawnEntityPrefab(controllerPrefab, GetOwner().GetWorld(), null)
		);
		controller.m_System = this;
		m_Controllers.Set(identity, controller);

		return controller;
	}

	void DeleteController(RplIdentity identity)
	{
		auto controller = m_Controllers.Get(identity);
		delete controller;
		m_Controllers.Remove(identity);
	}

	void ChangeColor(int idx)
	{
		m_Spheres[idx].NextColor();
	}
}

class RplExample3SessionListener: RplSessionCallbacks
{
	RplExample3System m_System;

	void RplExample3SessionListener(RplExample3System system)
	{
		m_System = system;
	}

	override void EOnConnected(RplIdentity identity)
	{
		RplExample3Controller controller = m_System.NewController(identity);
		auto rplComponent = BaseRplComponent.Cast(controller.FindComponent(BaseRplComponent));
		rplComponent.Give(identity);
	}

	override void EOnDisconnected(RplIdentity identity)
	{
		m_System.DeleteController(identity);
	}
};

class RplExample3ControllerClass : GenericEntityClass {}
RplExample3ControllerClass g_RplExample3ControllerClassInst;

class RplExample3Controller : GenericEntity
{
	static const KeyCode s_KeyMap[] = {
		KeyCode.KC_NUMPAD1,
		KeyCode.KC_NUMPAD2,
		KeyCode.KC_NUMPAD3,
		KeyCode.KC_NUMPAD4,
		KeyCode.KC_NUMPAD5,
		KeyCode.KC_NUMPAD6,
		KeyCode.KC_NUMPAD7,
		KeyCode.KC_NUMPAD8,
		KeyCode.KC_NUMPAD9,
	};

	RplExample3System m_System;
	int m_IsDownMask = 0;

	bool RplGiven(ScriptBitReader reader)
	{
		if (false)
		{
			SetEventMask(EntityEvent.FRAME);
		}
		else
		{
			SetEventMask(EntityEvent.FIXEDFRAME);
		}
		return true;
	}

	override void EOnFrame(IEntity owner, float timeSlice)
	{
		foreach (int idx, KeyCode kc : s_KeyMap)
		{
			int keyBit = 1 << idx;
			bool isDown = Debug.KeyState(kc);
			bool wasDown = (m_IsDownMask & keyBit);
			if (isDown && !wasDown)
				Rpc(Rpc_ChangeColor_S, idx);

			if (isDown)
				m_IsDownMask |= keyBit;
			else
				m_IsDownMask &= ~keyBit;
		}
	}

	[RplRpc(RplChannel.Reliable, RplRcver.Server)]
	void Rpc_ChangeColor_S(int idx)
	{
		if (idx < 0 || idx >= 9)
			return;

		m_System.ChangeColor(idx);
	}

	override void EOnFixedFrame(IEntity owner, float timeSlice)
	{
		int isDownMask = 0;
		int keyBit = 1;
		foreach (KeyCode kc : s_KeyMap)
		{
			if (Debug.KeyState(kc))
				isDownMask |= keyBit;

			keyBit <<= 1;
		}
		Rpc(Rpc_OwnerInputs_S, isDownMask);
	}

	[RplRpc(RplChannel.Unreliable, RplRcver.Server)]
	void Rpc_OwnerInputs_S(int isDownMask)
	{
		int inputsChanged = m_IsDownMask ^ isDownMask;
		if (!inputsChanged)
			return;

		for (int idx = 0; idx < 9; idx++)
		{
			int keyBit = 1 << idx;
			bool isDown = isDownMask & keyBit;
			bool wasDown = m_IsDownMask & keyBit;
			if (isDown && !wasDown)
				m_System.ChangeColor(idx);
		}

		m_IsDownMask = isDownMask;
	}
};
//! [Replication example 3]

#endif
/*!
\addtogroup Replication
\{
*/

class RplSessionCallbacks
{
	void EOnBegan();
	void EOnEnded();
	void EOnFailed(string msg);
	void EOnConnected(RplIdentity identity);
	void EOnDisconnected(RplIdentity identity);
}

//! \deprecated Use RplStateOverride instead.
enum ERplStateOverride
{
	None = RplStateOverride.None,
	Static = RplStateOverride.None,
	Dynamic = RplStateOverride.Runtime,
}

/*!
\}
*/
//-----------------------------------------------------------------------------
class RplSessionErrorHandler : RplSessionCallbacks
{
	protected const string ERROR_GROUP = "REPLICATION";
	
	//-----------------------------------------------------------------------------
	void RplSessionErrorHandler()
	{
		RplSession.RegisterCallbacks(this);
	}
	
	//-----------------------------------------------------------------------------
	override void EOnFailed(string msg)
	{
		SCR_KickDialogs.CreateKickErrorDialog(msg, ERROR_GROUP);
	}

};
class GameRplSchedulerInsertionCtx: RplSchedulerInsertionCtx
{
	RplIdentity OnlyRelevantTo;
	bool CanBeStreamed;
	bool OwnerStreamOut;
};

[ComponentEditorProps(category: "GameScripted/Test", description: "Test component showcasing doing the replication from script the RIGHT way")]
class SCR_RplTestComponentClass : ScriptComponentClass
{
}

class SCR_RplTestComponent : ScriptComponent
{
	protected ChimeraCharacter m_CharacterOwner = null;
	private RplComponent m_RplComponent = null;
	
	// NoOwner - executed everywhere but on the owner. Note both client and server can be owners.
		// Thus, when the client is owner, this won't be called for it.
	// onRplName: "OnTestChanged" - if the target is right,
		// everytime the value changes OnTestChanged is executed
	[RplProp(condition: RplCondition.NoOwner, onRplName: "OnTestChanged")]
	private int m_iTest = 0;
	
	float m_fdelay = 0;
	
	//------------------------------------------------------------------------------------------------
	//!
	//! \param[in] testNum
	void Do_TestRpc(int testNum)
	{
		Print("RPC TestRpc EXECUTED: " + testNum, LogLevel.NORMAL);
	}
	
	//------------------------------------------------------------------------------------------------
	//! Send request to the server to print a message everywhere
	//! \param[in] testNum
	[RplRpc(RplChannel.Reliable, RplRcver.Server)]
	void RpcAsk_TestRpc(int testNum)
	{
		Do_TestRpc(testNum);
		Rpc(RpcDo_TestRpc, testNum);
	}
	
	//------------------------------------------------------------------------------------------------
	//! Broadcast.
	//! When called from server this is executed everywhere but on the server.
	//! When called on client, this is executed only on the client.
	//!
	//! NOTE:
	//! The caller of the RPC needs to provide exectly one integral argument "testNum".
	//! Note, max. 16 args are possible in script. This restriction applies universally not just
	//! to RPCs but for all script methods in general
	//! \param[in] testNum
	[RplRpc(RplChannel.Reliable, RplRcver.Broadcast)]	
	void RpcDo_TestRpc(int testNum)
	{
		Print("RPC NetTestRpc EXECUTED: " + testNum, LogLevel.NORMAL);
	}

	//------------------------------------------------------------------------------------------------
	//! Server-only execution
	//! \param[in] timeSlice
	[RplRpc(RplChannel.Reliable, RplRcver.Server)]
	void RpcAsk_ChangePropValue(float timeSlice)
	{
		m_fdelay -= timeSlice;
		if (m_fdelay > 0)
			return;
		
		m_fdelay += 2;
		
		// Change the value server side
		// This will trigger OnTestChanged on clients
		m_iTest = Math.RandomIntInclusive(0, 100);
		Replication.BumpMe();
		Print("RPLPROP m_iTest CHANGED on SERVER: " + m_iTest, LogLevel.NORMAL);
	}

	//------------------------------------------------------------------------------------------------
	// Called on client everytime m_iTest changes value. No need to use m_iTestLast
	// unless you really need to know the previous value
	void OnTestChanged()
	{
		Print("RPLPROP m_iTest CHANGED on CLIENT: " + m_iTest, LogLevel.NORMAL);
	}
	
	//------------------------------------------------------------------------------------------------
	//!
	void Do_TestFire()
	{
		Print("RPC TestFire EXECUTED", LogLevel.NORMAL);
	}
	
	//------------------------------------------------------------------------------------------------
	//!
	[RplRpc(RplChannel.Reliable, RplRcver.Server)]
	void RpcAsk_TestFire()
	{
		// You might want to do some security checks here.
		// E.g., could the shot have been fired?
		// if (!...)
		// 	return;
		
		// Assuming the server is the authority here, we perform the action
		// right away.
		// If it weren't the case, we'd need to do the opposite condition we
		// did before calling the RPC which in our would result in:
		// if (m_RplComponent && !m_RplComponent.IsOwnerProxy())
		//   Do_TestFire();
		// Otherwise, Do_TestFire would be performed twice in some cases.
		// However, we design our code with security in mind and want the server
		// be the authority. Therefor, it's enough to have:
		Do_TestFire();
		
		Rpc(RpcDo_TestFire);
	}
	
	//------------------------------------------------------------------------------------------------
	//!
	[RplRpc(RplChannel.Reliable, RplRcver.Broadcast, RplCondition.NoOwner)]
	void RpcDo_TestFire()
	{
		Do_TestFire();
	}
	
	//------------------------------------------------------------------------------------------------
	override void OnPostInit(IEntity owner)
	{
		super.OnPostInit(owner);
		SetEventMask(owner, EntityEvent.FRAME | EntityEvent.INIT);
		owner.SetFlags(EntityFlags.ACTIVE, false);
	}
	
	//------------------------------------------------------------------------------------------------
	override void EOnInit(IEntity owner)
	{
		m_CharacterOwner = ChimeraCharacter.Cast(owner);
		if (m_CharacterOwner)
			m_RplComponent = RplComponent.Cast(m_CharacterOwner.FindComponent(RplComponent));
	}
	
	//------------------------------------------------------------------------------------------------
	override void EOnFrame(IEntity owner, float timeSlice)
	{
		if (Debug.KeyState(KeyCode.KC_P))
		{
			Debug.ClearKey(KeyCode.KC_P);
			int rndRPCNum = Math.RandomIntInclusive(0, 100);
			// Print first
			Print("Requesting TestRpc: " + rndRPCNum, LogLevel.NORMAL);
			// Execute second! Otherwise, when calling this on server,
			// you'd first print you changed the value and only then
			// you'd print your requested a change.
			Rpc(RpcAsk_TestRpc, rndRPCNum);	
		}
		
		// Ask the server to update the property value
		Rpc(RpcAsk_ChangePropValue, timeSlice);
		
		// There might be times when you want some local effect be performed
		// right away. E.g., you start shooting and want to hide the network
		// latency (request + response could take 100+ ms and you would notice
		// this immediatelly).
		// In this case, if we assume the server has the authority (which should
		// always be the case to keep the game secure), I recommend doing:
		if (m_RplComponent && m_RplComponent.IsOwnerProxy())
			Do_TestFire(); // local effect right away
		// Ask the server to perform the action and if possible, broadcast it
		// to everybody but the owner
		Rpc(RpcAsk_TestFire);
		
		// IMPORTANT:
		// ONLY OWNERS CAN PERFORM RPCs! Calling RPCs from a non-owner equals
		// doing nothing.
	}
	
	//------------------------------------------------------------------------------------------------
	// constructor
	//! \param[in] src
	//! \param[in] ent
	//! \param[in] parent
	void SCR_RplTestComponent(IEntityComponentSource src, IEntity ent, IEntity parent)
	{			
	}
}
[ComponentEditorProps(category: "GameScripted/Test", description: "Test component showcasing doing the replication from script the WRONG way")]
class SCR_RplTestComponentWrongClass : ScriptComponentClass
{
}

class SCR_RplTestComponentWrong : ScriptComponent
{
	[RplProp(condition: RplCondition.NoOwner)]
	private int m_iTest = 0;
	private int m_iTestLast = 0;
	
	float m_fdelay = 0;
	
	//------------------------------------------------------------------------------------------------
	[RplRpc(RplChannel.Reliable, RplRcver.Broadcast)]
	void NetTestRpc(int testNum)
	{
		Print("RPC RECEIVE: " + testNum, LogLevel.NORMAL);
	}
	
	//------------------------------------------------------------------------------------------------
	override void EOnFrame(IEntity owner, float timeSlice)
	{
		if (Debug.KeyState(KeyCode.KC_P))
		{
			Debug.ClearKey(KeyCode.KC_P);
			int rndRPCNum = Math.RandomIntInclusive(0, 100);
			// WRONG:
			// When performed on server, this is broadcast to everyone.
			// However when executed on client, this is only performed on the client.
			Rpc(NetTestRpc, rndRPCNum);
			Print("RPC SEND: " + rndRPCNum, LogLevel.NORMAL);
		}
		
		/*
			WRONG:
			Never never never (unless you really have to).
			If possible, never decide which RPC to call be checking for wheter you're
			a client or not.
			In general, if you need to write this condition it means your thought process is
			not the best one and you should think things through again.
			Instead, use proper attributes for the RPC. It takes a little bit of getting
			used to, however, you'll end up with code which is cleaner and easier to understand.
			This design actually enforces the right way of thinking on you.
		*/
		if (RplSession.Mode() == RplMode.Client) // Client
		{
			/*
				WRONG:
				Never never never.
				Always check for property changes on client using a callback.
				You won't need to remeber the previous value + you'll avoid
				cases where OnFrame isn't called for whatever reason (sometimes,
				simulation of certain entites might turn off EOnFrame for proxies).
				
				In this case, every time m_iTest changes on sever, OnTestChanged
				is called on client. The moment it's called, you know the value has
				already been updated to a new one. If you want to keep the old one (
				which you usually don't) you need to store it e.g. m_iTestLast or
				in an array depending on your needs.
			*/
			if (m_iTestLast != m_iTest)
				Print("RPLPROP CHANGED: " + m_iTest, LogLevel.NORMAL);

			m_iTestLast = m_iTest;
		}
		else
		{
			m_fdelay -= timeSlice;
			if (m_fdelay > 0)
				return;
			
			m_fdelay += 2;
			
			// Change the value server side
			if (RplSession.Mode() != RplMode.Client)
			{
				m_iTest = Math.RandomIntInclusive(0, 100);
				Replication.BumpMe();
			}
						
			Print("RPLPROP CHANGE: " + m_iTest);
		}
	}
	
	//------------------------------------------------------------------------------------------------
	void SCR_RplTestComponentWrong(IEntityComponentSource src, IEntity ent, IEntity parent)
	{
		SetEventMask(ent, EntityEvent.FRAME);
		ent.SetFlags(EntityFlags.ACTIVE, true);
	}
}
[EntityEditorProps(category: "GameScripted/Test", description: "Testing entity for scripted replication", color: "0 0 255 255")]
class SCR_RplTestEntityClass: GenericEntityClass
{
};

class RplTestPropType
{
	int iVal;
	float fVal;
	bool bVal;

	//################################################################################################
	//! Codec methods
	//------------------------------------------------------------------------------------------------
	static void Encode(SSnapSerializerBase snapshot, ScriptCtx hint, ScriptBitSerializer packet) 
	{
		snapshot.Serialize(packet, 9);
	}
	
	//------------------------------------------------------------------------------------------------
	static bool Decode(ScriptBitSerializer packet, ScriptCtx hint, SSnapSerializerBase snapshot) 
	{
		return snapshot.Serialize(packet, 9);
	}
	
	//------------------------------------------------------------------------------------------------
	static bool SnapCompare(SSnapSerializerBase lhs, SSnapSerializerBase rhs, ScriptCtx hint) 
	{
		return lhs.CompareSnapshots(rhs, 9);
	}
	
	//------------------------------------------------------------------------------------------------
	static bool PropCompare(RplTestPropType prop, SSnapSerializerBase snapshot, ScriptCtx hint) 
	{
		return snapshot.Compare(prop.iVal, 4) 
			&& snapshot.Compare(prop.fVal, 4) 
			&& snapshot.Compare(prop.bVal, 1);
	}
	
	//------------------------------------------------------------------------------------------------
	static bool Extract(RplTestPropType prop, ScriptCtx hint, SSnapSerializerBase snapshot) 
	{
		snapshot.SerializeBytes(prop.iVal, 4);
		snapshot.SerializeBytes(prop.fVal, 4);
		snapshot.SerializeBytes(prop.bVal, 1);

		return true;
	}
	
	//------------------------------------------------------------------------------------------------
	static bool Inject(SSnapSerializerBase snapshot, ScriptCtx hint, RplTestPropType prop) 
	{
		snapshot.SerializeBytes(prop.iVal, 4);
		snapshot.SerializeBytes(prop.fVal, 4);
		snapshot.SerializeBytes(prop.bVal, 1);

		return true;
	}
	//################################################################################################
		
};

//------------------------------------------------------------------------------------------------
class SCR_RplTestEntity : GenericEntity
{
	[RplProp(condition: RplCondition.NoOwner)]
	private int m_iTest = 0;
	private int m_iTestLast = 0;
	
	float m_fdelay = 0;
	
	[RplProp(onRplName: "OnRpl_CustomProp")]
	ref RplTestPropType customProp = new RplTestPropType();
	
	void OnRpl_CustomProp()
	{
		Print("CUSTOM RPLPROP CHANGE1: " + customProp.iVal);
		Print("CUSTOM RPLPROP CHANGE2: " + customProp.fVal);
		Print("CUSTOM RPLPROP CHANGE3: " + customProp.bVal);
	}

	//------------------------------------------------------------------------------------------------
	[RplRpc(RplChannel.Reliable, RplRcver.Broadcast)]
	void NetTestRpc(int testNum)
	{
		Print("RPC RECEIVE: " + testNum.ToString());
	}
	
	//------------------------------------------------------------------------------------------------
	override void EOnFrame(IEntity owner, float timeSlice)
	{
		if (Debug.KeyState(KeyCode.KC_P))
		{
			Debug.ClearKey(KeyCode.KC_P);
			int rndRPCNum = Math.RandomIntInclusive(0, 100);
			Rpc(NetTestRpc, rndRPCNum);
			Print("RPC SEND: " + rndRPCNum.ToString());
		}
		
		if (RplSession.Mode() == RplMode.Client) // Client
		{
			if (m_iTestLast != m_iTest)
			{
				Print("RPLPROP CHANGED: " + m_iTest);
				Print("CUSTOM RPLPROP CHANGED1: " + customProp.iVal);
				Print("CUSTOM RPLPROP CHANGED2: " + customProp.fVal);
				Print("CUSTOM RPLPROP CHANGED3: " + customProp.bVal);
			}
			
			m_iTestLast = m_iTest;
		}
		else
		{
			m_fdelay -= timeSlice;
			if (m_fdelay > 0)
				return;
			
			m_fdelay += 2;
			
			// Change the value server side
			if (RplSession.Mode() != RplMode.Client)
			{
				m_iTest = Math.RandomIntInclusive(0, 100);
				customProp.iVal = Math.RandomIntInclusive(0, 100);
				customProp.fVal = Math.RandomFloatInclusive(0, 100);
				customProp.bVal = customProp.iVal > 50;
			}
			
			Print("RPLPROP CHANGE: " + m_iTest);
			Print("CUSTOM RPLPROP CHANGE1: " + customProp.iVal);
			Print("CUSTOM RPLPROP CHANGE2: " + customProp.fVal);
			Print("CUSTOM RPLPROP CHANGE3: " + customProp.bVal);
		}
	}
	
	//------------------------------------------------------------------------------------------------
	void SCR_RplTestEntity(IEntitySource src, IEntity parent)
	{
		SetEventMask(EntityEvent.FRAME);
		SetFlags(EntityFlags.ACTIVE, true);
	}

	//------------------------------------------------------------------------------------------------
	void ~SCR_RplTestEntity()
	{
	}
};
/*
===========================================
Do not modify, this script is generated
===========================================
*/

/*!
\addtogroup Components
\{
*/

class RplComponentClass: BaseRplComponentClass
{
}

//! Base class for entity replication - e.g. vehicles, characters, animals
class RplComponent: BaseRplComponent
{
	/*!
	Deletes a replicated entity.

	When called by the authority it removes the entity from replication delete the entity physically. If releaseFromReplication
	is true, once deleted from the replication on proxies they won't delete the entity physically.

	When called by a proxy no physical delete happens until the authority deletes the entity. If releaseFromReplication is true
	the entity is marked and won't be deleted physically when deleted from the replication (unless the authority managed to
	tell the proxy the entity was deleted on the server already).

	\param pEntity Entity to delete
	\param releaseFromReplication When true after the entity is deleted from replication it won't be deleted from the game.
	*/
	static proto void DeleteRplEntity(IEntity entity, bool releaseFromReplication);
	/*!
	Gives ownership to newOwner if possible. Also notifies listeners if possible.
	Unlike Give this supports also custom data passing between the old and the new owner.

	\warning This method might be replaced by a unified Give method in the future. Use with caution.

	\param newOwner New owner.
	\param alwaysNotify Notifies listeners even if no change in ownership happened.
	*/
	proto external void GiveExt(RplIdentity newOwner, bool alwaysNotify);
	/*!
	Force scheduler to move node
	This is useful for nodes that do not have networked movement component, but are
	forcefully moved. To be used only in special cases.

	\warning Works only if Network Dynamic Simulation is enabled

	\param previousPos previous position to move the node from
	*/
	proto external void ForceNodeMovement(vector previousPos);
	/*!
	Enable streaming for a specific entity.
	This takes precedence over EnableStreaming for a specific Connection or Connection/Node

	\warning Works only if Network Dynamic Simulation is enabled

	\param enable If true streaming is enabled.
	*/
	proto external void EnableStreaming(bool enable);
	/*!
	Enable streaming of node to a specific player.
	Respects disabled connection rules, respects disabled nodes rules

	\warning Works only if Network Dynamic Simulation is enabled

	\param identity Client connection
	\param enable If true streaming is enabled.
	*/
	proto external void EnableStreamingConNode(RplIdentity identity, bool enable);
	/*!
	Enable streaming for a specific player.
	Ignores Connection/Node rules, but respects disabled nodes

	\warning Use with caution. This could can cause performance issues if used by many players.

	\param identity Client connection
	\param enable If true streaming is enabled.
	*/
	static proto void EnableStreamingForConnection(RplIdentity identity, bool enable);
	/*
	Insert MPObserver at position, for identity.
	Allows for static observer that then streams in/preloads replicated entities

	\warning Ensure you delete these observers after usage, they can cause performance issues.
	\param identity Client connection.
	\param x Position of observer.
	\param z Position of observer.
	*/
	static proto void InsertMPObserver(RplIdentity identity, float x, float z);
	/*
	Remove MPObserver for identity.

	\param identity Client connection.
	*/
	static proto void RemoveMPObserver(RplIdentity identity);
	/*
	Enable or disable spatial relevacny of a node.
	Spatial relevancy is not enforced in a hierarchy, meanining if a root node is not in spatial map, and a spatial node is attached to it, it will not be in spatial map.
	*/
	proto external void EnableSpatialRelevancy(bool enable);
}

/*!
\}
*/
