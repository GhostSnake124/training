/*
===========================================
Do not modify, this script is generated
===========================================
*/

class WeatherStateTransitionManager: BaseWeatherStateTransitionManager
{
	private void WeatherStateTransitionManager();

}

[CinematicTrackAttribute(name:"Weather Track", description:"Allows you to change weather options")]
class WeatherCinematicTrack : CinematicTrackBase
{
	[Attribute("0.0", params:"0.0 23.9")]
	float m_fTimeOfDay;
	
	[Attribute("0", params:"0 3")]
	int m_iWeatherType;
	
	[Attribute("0.0", params:"0.0 20.0")]
	float m_fWindSpeed;
	
	[Attribute("0.0", params:"0.0 360.0")]
	float m_fWindDirection;
	
	[Attribute("0.0", params:"0.0 1.0")]
	float m_fWetness;
	
	[Attribute("0.0", params:"0.0 1.0")]
	float m_fPuddles;
	
	[Attribute("0.0", params:"0.0 1.0")]
	float m_fFog;
	
	[Attribute("0.0", params:"0.0 1.0")]
	float m_fFogHeight;
	
	
	[Attribute("false")]
	bool setDate;
	
	[Attribute("1989")]
	int m_iYear;
	
	[Attribute("4")]
	int m_iMonth;
	
	[Attribute("1")]
	int m_iDay;
	
	float m_fActualTimeOfDay;
	float m_fActualWindSpeed;
	float m_fActualWindDirection;
	int m_iActualWeatherType;
	
	ChimeraWorld chimWorld;
	
	TimeAndWeatherManagerEntity weatherManager;
	
	override void OnInit(World world)
	{
		chimWorld = world;
		
		m_iActualWeatherType = -1;
		
		if(chimWorld)
			weatherManager = chimWorld.GetTimeAndWeatherManager();
			
		
		m_fActualTimeOfDay = -1;
		m_fActualWindSpeed = -1;
		m_fActualWindDirection = -1;
	}
	
	override void OnApply(float time)
	{	
		
		if (weatherManager)
		{
			
			WeatherState weatherState = weatherManager.GetCurrentWeatherState();
			
			weatherManager.SetFogAmountOverride(true, m_fFog);
			weatherManager.SetFogHeightDensityOverride(true, m_fFogHeight);
			weatherManager.SetCurrentWetness(m_fWetness);
			weatherManager.SetCurrentWaterAccumulation(0,m_fPuddles);
			
			//Time of day
			if (m_fTimeOfDay != m_fActualTimeOfDay)
			{
				weatherManager.SetTimeOfTheDay(m_fTimeOfDay, true);
				
				if (setDate)
				{
					weatherManager.SetDate(m_iYear, m_iMonth, m_iDay);
				}
				m_fActualTimeOfDay = m_fTimeOfDay;
			}
			
			//Wind speed and direction
			if (m_fWindSpeed != m_fActualWindSpeed)
			{
				weatherManager.SetWindSpeedOverride(true, m_fWindSpeed);
				m_fActualWindSpeed = m_fWindSpeed;
			}
			
			if (m_fWindDirection != m_fActualWindDirection)
			{
				weatherManager.SetWindDirectionOverride(true, m_fWindDirection);
				 m_fActualWindDirection = m_fWindDirection;
			}
			
			
			if ( m_iWeatherType == 0 && weatherState.GetStateName() != "Clear")
			{
				weatherManager.ForceWeatherTo(false, "Clear");
				
			} else if ( m_iWeatherType == 1 && weatherState.GetStateName() != "Cloudy") {
			
			  weatherManager.ForceWeatherTo(false, "Cloudy");
				
			} else if ( m_iWeatherType == 2 && weatherState.GetStateName() != "Overcast") {
			
			  weatherManager.ForceWeatherTo(false, "Overcast");
				
			} else if (m_iWeatherType == 3 && weatherState.GetStateName() != "Rainy") {
			
			  weatherManager.ForceWeatherTo(false, "Rainy");
			}
			
			weatherManager.UpdateWeather(0.01);
		}
	}
}

class TimeAndWeatherManagerEntityClass: BaseTimeAndWeatherManagerEntityClass
{
}

//~ Script invokers
void SCR_TimeAndWeatherManager_OnWeatherStatePreview(bool previewEnabled, string weatherState);
typedef func SCR_TimeAndWeatherManager_OnWeatherStatePreview;

void SCR_TimeAndWeatherManager_OnWindPreview(bool previewEnabled, float windSpeed, float windDirectionDegrees);
typedef func SCR_TimeAndWeatherManager_OnWindPreview;

void SCR_TimeAndWeatherManager_OnDateTimePreview(bool previewEnabled, int year, int month, int day, float timeOfTheDay);
typedef func SCR_TimeAndWeatherManager_OnDateTimePreview;

//! Manager entity responsible for managing in-game time and weather,
//! providing the script and gamecode with usable in-game API.
class TimeAndWeatherManagerEntity : BaseTimeAndWeatherManagerEntity
{	
	[Attribute(desc: "An ordered array of daytime info. Starting just after midnight and ending at midnight, the daytime must be ordered!")]
	protected ref array<ref SCR_DayTimeInfoBase> m_aOrderedDaytimeInfo;
	
	[Attribute(desc: "An ordered array of winddirection info, starting at north and having set steps between each wind direction. (default 45)")]
	protected ref array<ref SCR_WindDirectionInfo> m_OrderedWindDirectionInfo;
	
	[Attribute(desc: "An array of monephase naming in order from New moon to Full moon. Check GetMoonPhaseNameForDate before changing this array!")]
	protected ref array<ref SCR_MoonPhaseInfo> m_aMoonPhasesInfo;
	
	[Attribute(desc: "Ordered days of the weeks, Monday (Start), Tuesday, Wednesday, ect. to Sunday (Last)")]
	protected ref array<LocalizedString> m_aOrderedDaysOfWeek;
	
	protected bool m_bDelayedWindOverride = false;
	protected int m_iDelayedPlayerChangingWind = -1;
	protected float m_fDelayedWindSpeedOverride = -1;
	protected float m_fDelayedWindDirectionOverride = -1;
	protected bool m_bListiningToWindOverrideDelay = false;
	
	//~ ScriptInvokers
	protected ref ScriptInvokerBase<SCR_TimeAndWeatherManager_OnWeatherStatePreview> m_OnWeatherStatePreview;
	protected ref ScriptInvokerBase<SCR_TimeAndWeatherManager_OnWindPreview> m_OnWindPreview;
	protected ref ScriptInvokerBase<SCR_TimeAndWeatherManager_OnDateTimePreview> m_OnDateTimePreview;
	
	//Replicated
	protected bool m_bWeatherIsLooping = false;
	
	//------------------------------------------------------------------------------------------------
	//! Set Weather state preview. Can be called locally and will send an scriptInvoker when called succesfully
	//! \param preview True to enable preview, false to disable
	//! \param stateName Weather State name to preview, no need to give if preview is false
	//! \return True if preview changed succesfully
	bool SetWeatherStatePreview(bool preview, string stateName = "")
	{
		BaseWeatherStateTransitionManager weatherStateTransitionManager = GetTransitionManager();
		if (!weatherStateTransitionManager)
			return false;
		
		if (!weatherStateTransitionManager.SetStatePreview(preview, stateName))
			return false;
		
		//Script invoker
		if (m_OnWeatherStatePreview)
			m_OnWeatherStatePreview.Invoke(preview, stateName);
		
		return true;
	}
	
	//------------------------------------------------------------------------------------------------
	//! Set wind preview. Can be called locally and will send an scriptInvoker when called succesfully
	//! \param preview True to enable preview, false to disable
	//! \param windSpeed Windspeed to preview, no need to give if preview is false
	//! \param windAngleDegrees Wind Angle in Degrees to preview, no need to give if preview is false
	//! \return True if preview changed succesfully
	bool SetWindPreview(bool preview, float windSpeed = -1, float windAngleDegrees = -1)
	{
		BaseWeatherStateTransitionManager weatherStateTransitionManager = GetTransitionManager();
		if (!weatherStateTransitionManager)
			return false;
		
		if (!weatherStateTransitionManager.SetWindPreview(preview, windSpeed, windAngleDegrees))
			return false;
		
		//Script invoker
		if (m_OnWindPreview)
			m_OnWindPreview.Invoke(preview, windSpeed, windAngleDegrees);
		
		return true;
	}
	
	//------------------------------------------------------------------------------------------------
	//! Set date time Preview. Can be called locally and will send an scriptInvoker when called succesfully
	//! \param preview True to enable preview, false to disable
	//! \param year Year to preview, no need to give if preview is false
	//! \param month Month to preview, no need to give if preview is false
	//! \param day Day to preview, no need to give if preview is false
	//! \param timeOfTheDay Time of day to preview in 24.0, no need to give if preview is false
	//! \return True if preview changed succesfully
	bool SetDateTimePreview(bool preview, int year = -1, int month = -1, int day = -1, float timeOfTheDay = -1)
	{
		BaseWeatherStateTransitionManager weatherStateTransitionManager = GetTransitionManager();
		if (!weatherStateTransitionManager)
			return false;
		
		if (!weatherStateTransitionManager.SetDateTimePreview(preview, year, month, day, timeOfTheDay))
			return false;
		
		//Script ScriptInvoker
		if (m_OnDateTimePreview)
			m_OnDateTimePreview.Invoke(preview, year, month, day, timeOfTheDay);
		
		return true;
	}
	
	//------------------------------------------------------------------------------------------------
	//! Get if the sun is set for the current time, latitude/longitude/date configuration.\
	//! \return True if sun is set
	bool IsSunSet()
	{
		return IsSunSet(GetTimeOfTheDay());
	}
	
	//------------------------------------------------------------------------------------------------
	//! Get if the sun is set at given time.
	//! Note this will use current latitude/longitude/date configuration
	//! \param timeToCheck time to check. Uses 24 hour format e.g. 12.50 is 12:30 A.M
	//! \return True if sun is set for the given time
	bool IsSunSet(float timeToCheck)
	{
		float sunSetTime, sunRiseTime;
		
		//~ The sun never sets
		if (!GetSunsetHour(sunSetTime))
			return false;
		
		//~ The sun never rises
		if (!GetSunriseHour(sunRiseTime))
			return true;
		
		//~ Returns if given time is >= than sunset or smaller than sunrise time
		return (timeToCheck >= sunSetTime || timeToCheck < sunRiseTime);
	}
	
	//------------------------------------------------------------------------------------------------
	//! Use current date to get day of the week localized string (eg Monday, Tuesday ect)
	//! \return Day of the week
	string GetWeekDayString()
	{		
		int weekdayIndex = GetWeekDay();
		
		if (weekdayIndex < 0 || weekdayIndex > m_aOrderedDaysOfWeek.Count())
			return string.Empty;
		
		return m_aOrderedDaysOfWeek[weekdayIndex];
	}
	
	//------------------------------------------------------------------------------------------------
	//! Use given date to get day of the week localized string (eg Monday, Tuesday ect)
	//! \return Day of the week as defined in m_aOrderedDaysOfWeek
	string GetWeekDayStringForDate(int year, int month, int day)
	{
		int weekdayIndex = GetWeekDayForDate(year, month, day);
		
		if (weekdayIndex < 0 || weekdayIndex > m_aOrderedDaysOfWeek.Count())
			return string.Empty;
		
		 return m_aOrderedDaysOfWeek[weekdayIndex];
	}
	
	
	//------------------------------------------------------------------------------------------------
	//! Sets weather looping (server only)
	//! Use ForceWeatherTo to have more control over transition time and state duration
	//! \see ForceWeatherTo
	//! \see UpdateWeatherLooping
	//! \see IsWeatherLooping
	//! \param setLooping Set looping true or false
	//! \param playerChangedLooping ID of player that set weather to looping
	void SetCurrentWeatherLooping(bool setLooping, int playerChangedLooping = 0)
	{
		ForceWeatherTo(setLooping, playerThatChangedWeather: playerChangedLooping);
	}
	
	//------------------------------------------------------------------------------------------------
	//! Forces weather to the given state. Does not care if the transition is valid or not. (Server only)
	//! Use this if you want to set weather to looping or change the weather on the fly
	//! Do not change weather from looping true/false outside of this function
	//! \param setLooping Set looping true or false
	//! \param weatherID weather to set. Leave empty if you want to change the current weather to looping true/false
	//! \param transitionDuration transition duration of weather
	//! \param stateDuration state duration of weather
	//! \param playerThatChangedWeather ID of player that changed the weather for notifications. Leave empty if no notifications should be called
	void ForceWeatherTo(bool setLooping, string weatherID = string.Empty, float transitionDuration = 0, float stateDuration = 0.001, int playerThatChangedWeather = 0)
	{
		if (!Replication.IsServer())
		{
			Print("'ForceWeatherTo' was called in 'TimeAndWeatherManagerEntity' but only server has authority to change weather!", LogLevel.WARNING);
			return;
		}
		
		BaseWeatherStateTransitionManager transitionManager = GetTransitionManager();	
		if (!transitionManager)
		{
			Print("'ForceWeatherTo' was called in 'TimeAndWeatherManagerEntity' but TransitionManager was not found!", LogLevel.WARNING);
			return;
		}
		
		if (weatherID.IsEmpty())
		{
			WeatherState currentWeather = transitionManager.GetCurrentState();
			weatherID = currentWeather.GetStateName();
		}
			
		WeatherStateTransitionNode transitionNode = transitionManager.CreateStateTransition(weatherID, transitionDuration, stateDuration);
		if (!transitionNode)
		{
			Print("'ForceWeatherTo' in 'TimeAndWeatherManagerEntity' could not create a new WeatherStateTransitionNode", LogLevel.WARNING);
			return;
		}
		
		transitionNode.SetLooping(setLooping);
		
		//~ Remove Preview if any
		if (transitionManager.IsPreviewingState())
			SetWeatherStatePreview(false);
		
		transitionManager.EnqueueStateTransition(transitionNode, false);
		transitionManager.RequestStateTransitionImmediately(transitionNode);
		
		//~ Send to clients if weather is looping or not
		if (setLooping != m_bWeatherIsLooping)
		{
			UpdateWeatherLooping(setLooping);
			Rpc(UpdateWeatherLooping, setLooping);
		}
		
		//~ Send notification if player ID was given
		if (playerThatChangedWeather > 0)
		{
			if (!setLooping)
			{
				SCR_NotificationsComponent.SendToUnlimitedEditorPlayers(ENotification.EDITOR_ATTRIBUTES_WEATHER_AUTO, playerThatChangedWeather);
			}
			else 
			{
				BaseGameMode gameMode = GetGame().GetGameMode();
				if (gameMode)
				{
					SCR_NotificationSenderComponent notificationSender = SCR_NotificationSenderComponent.Cast(gameMode.FindComponent(SCR_NotificationSenderComponent));
					
					if (notificationSender)
						notificationSender.OnWeatherChangedNotification(playerThatChangedWeather);
				}
			}
		}
	}
	
	//------------------------------------------------------------------------------------------------
	//! Set weather's looping over the network
	//! \param isLooping
	[RplRpc(RplChannel.Reliable, RplRcver.Broadcast)]
	protected void UpdateWeatherLooping(bool isLooping)
	{	
		m_bWeatherIsLooping = isLooping;
	}
	
	//------------------------------------------------------------------------------------------------
	//! Get if weather is looping
	//! \see SetCurrentWeatherLooping
	//! \return true if weather currently is looping
	bool IsWeatherLooping()
	{
		return m_bWeatherIsLooping;
	}
	
	//------------------------------------------------------------------------------------------------
	//! Get moon phase for the current date
	//! \return SCR_MoonPhaseUIInfo moonphase info. This includes the full name of the moonphase as well as a simplified name (eg: first and Third quarter will be called half moon)
	SCR_MoonPhaseUIInfo GetCurrentMoonPhaseInfoForDate()
	{
		int day, month, year;
		GetDate(year, month, day);
		return GetMoonPhaseInfoForDate(year, month, day, GetTimeOfTheDay(), GetTimeZoneOffset(), GetDSTOffset(), GetCurrentLatitude());
	}
	
	//------------------------------------------------------------------------------------------------
	//! Gets moon phase name for supplied date, geo location is not needed but timezone yes in order to calculate UTC correctly.
	//! \param year Year.
	//! \param month Month in range <1, 12>
	//! \param day Day in range <1, 31>
	//! \param timeOfTheDay24 Time of the day in 24 hour floating point format.
	//! \param timezone TimeZone Offset in hours ranging <-12, +14>
	//! \param dstOffset DST (daylight savings time) offset, must be 0.0 or positive value.
	//! \return SCR_MoonPhaseUIInfo moonphase info. This includes the full name of the moonphase as well as a simplified name (eg: first and Third quarter will be called half moon)
	SCR_MoonPhaseUIInfo GetMoonPhaseInfoForDate(int year, int month, int day, float timeOfTheDay24, float timezone, float dstOffset, float Latitude)
	{
		if (m_aMoonPhasesInfo.IsEmpty())
		{
			Print("Could not get moon phase name as m_aMoonPhasesInfo is empty!", LogLevel.ERROR);
			return null;
		}
		
		float moonPhaseAmount = GetMoonPhaseForDate(year, month, day, timeOfTheDay24, timezone, dstOffset);		
		
		int nextPhaseYearCheck = year;
		int nextPhaseMonthCheck = month;
		int nextPhaseDayCheck = day + 1;
		
		//Calculate if the next day is a valid date
		if (!CheckValidDate(nextPhaseYearCheck, nextPhaseMonthCheck, nextPhaseDayCheck))
		{
			if (nextPhaseMonthCheck != 12)
			{
				nextPhaseMonthCheck += 1;
			}	
			else
			{
				nextPhaseMonthCheck = 1;
				nextPhaseYearCheck += 1;
			}
			
			nextPhaseDayCheck = 1;
		}
		
		//Check the next days moon phase
		float nextPhaseAmount = GetMoonPhaseForDate(nextPhaseYearCheck, nextPhaseMonthCheck, nextPhaseDayCheck, timeOfTheDay24, timezone, dstOffset);
		EMoonPhaseEnums beforeOrAfterFullMoon;
		
		//Check if current moonphase is before or after full moon by checking if next days moonphase amount is higher or lower then current moon phase amount
		if (nextPhaseAmount > moonPhaseAmount)
			beforeOrAfterFullMoon = EMoonPhaseEnums.BEFORE_FULL_MOON;
		else 
			beforeOrAfterFullMoon = EMoonPhaseEnums.AFTER_FULL_MOON;
			
		int count = m_aMoonPhasesInfo.Count();
		
		SCR_MoonPhaseUIInfo uiInfo;
		
		for(int i = 0; i < count; i++)
        {
			if (i == count -1)
			{
				uiInfo = m_aMoonPhasesInfo[i].GetUIInfo();
				break;
			}

			if (m_aMoonPhasesInfo[i].IsMoonPhase(moonPhaseAmount, beforeOrAfterFullMoon))
			{
				uiInfo = m_aMoonPhasesInfo[i].GetUIInfo();
				break;
			}
				
        }
		
		if (uiInfo)
			uiInfo.SetMoonphaseImageRotation(Latitude >= 0);
		
		return uiInfo;
	}
	
	//------------------------------------------------------------------------------------------------
	// Sets the current weather.
	// Only issuable by the authority.
	// Automatically broadcast to all clients.
	// \param hours Current weather as a normalized value <0.0, 1.0>
	// \param immediateChange Whether change should be applied immediately, forcing recomputation. This should be true only in case of editor and similar items.
	// \return Returns true when command is issued successfully, false otherwise.
	//proto native bool SetCurrentWeather(float weather01, bool immediateChange = false);
	
	//------------------------------------------------------------------------------------------------
	// Retrieves the current weather.
	// \return Current weather as a normalized value <0.0, 1.0>
	//proto native float GetCurrentWeather();
	
	//------------------------------------------------------------------------------------------------
	// Sets the current preset.
	// Only issuable by the authority.
	// Automatically broadcast to all clients.
	// \param hours Current preset as a normalized value <0.0, 1.0>
	// \param immediateChange Whether change should be applied immediately, forcing recomputation. This should be true only in case of editor and similar items.
	// \return Returns true when command is issued successfully, false otherwise.
	//proto native bool SetCurrentPreset(float preset01, bool immediateChange = false);
	
	//------------------------------------------------------------------------------------------------
	// Retrieves the current preset.
	// \return Current preset as a normalized value <0.0, 1.0>
	// proto native float GetCurrentPreset();

	
	//------------------------------------------------------------------------------------------------
	//! Retrieves current time of the day and returns it as a script wrapper for hours, minutes and seconds.
	//! \return Returns script wrapper for time
	TimeContainer GetTime()
	{
		ref TimeContainer cont = new TimeContainer();
		GetHoursMinutesSeconds(cont.m_iHours, cont.m_iMinutes, cont.m_iSeconds);
		return cont;
	}
	
	//------------------------------------------------------------------------------------------------
	//!
	//! \param year
	//! \param month
	//! \param day
	protected void CreateDayTimeInfoArray(int year = -1, int month = -1, int day = -1)
	{
		foreach (SCR_DayTimeInfoBase dayTimeInfo: m_aOrderedDaytimeInfo)
			dayTimeInfo.Clear();
		
		foreach (SCR_DayTimeInfoBase dayTimeInfo: m_aOrderedDaytimeInfo)
			dayTimeInfo.SetDayTime(m_aOrderedDaytimeInfo, this, year, month, day);
	}
	
	//------------------------------------------------------------------------------------------------
	//! Gets the UI info of the current time of day. Also returns the index of the current time of day info
	//! \param[out] uiInfo ui info of time of day
	//! \return int time of day info index
	int GetCurrentDayTimeUIInfo(out SCR_UIInfo uiInfo)
	{
		CreateDayTimeInfoArray();
		return GetDayTimeUIInfo(GetTimeOfTheDay(), uiInfo);		
	}
	
	//------------------------------------------------------------------------------------------------
	//! Gets the current daytime Ui info and Phase
	//! \param[out] uiInfo ui info of time of day
	//! \return Current DayTimePhase
	EDayTimeEnums GetCurrentDayTimeUIInfoAndPhase(out SCR_UIInfo uiInfo)
	{
		CreateDayTimeInfoArray();
		EDayTimeEnums dayTimePhase;
		return GetDayTimeUIInfo(GetTimeOfTheDay(), uiInfo, dayTimePhase);		
	}
	
	//------------------------------------------------------------------------------------------------
	//! Gets an array of daytime info which holds the UIinfo of specific times of the day
	//! \param TimeOfDay the time of day to get time info of
	//! \param[out] uiInfo time info of the given day time
	//! \param[out] dayTimePhase Phase of current daytime
	//! \param year date to get time info of
	//! \param month date to get time info of
	//! \param day date to get time info of
	//! \return int time of day info index
	int GetDayTimeUIInfo(float TimeOfDay, out SCR_UIInfo uiInfo, out EDayTimeEnums dayTimePhase = -1, int year = -1, int month = -1, int day = -1)
	{
		CreateDayTimeInfoArray(year, month, day);
		
		int count = m_aOrderedDaytimeInfo.Count();
		
		//If before early morning but after midnight
		if (TimeOfDay < m_aOrderedDaytimeInfo[0].GetDayTime())
		{
			uiInfo = m_aOrderedDaytimeInfo[count -1].GetDayTimeUIInfo();
			dayTimePhase =  m_aOrderedDaytimeInfo[count -1].GetDaytimeEnum();
			return count -1;
		}
		
		for (int i = 0; i < count -1; i++)
		{
			if (TimeOfDay > m_aOrderedDaytimeInfo[i].GetDayTime() && TimeOfDay < m_aOrderedDaytimeInfo[i +1].GetDayTime())
			{
				uiInfo = m_aOrderedDaytimeInfo[i].GetDayTimeUIInfo();
				dayTimePhase =  m_aOrderedDaytimeInfo[i].GetDaytimeEnum();
				return i;
			} 
		}
		
		//Just before Midnight
		uiInfo = m_aOrderedDaytimeInfo[count -2].GetDayTimeUIInfo();
		dayTimePhase =  m_aOrderedDaytimeInfo[count -2].GetDaytimeEnum();
		return count -2;
	}
	
	//------------------------------------------------------------------------------------------------
	//! Gets an array of daytime info which holds the UIinfo of specific times of the day
	//! \param[out] dayTimeInfoArray array with time of day infos
	//! \param year date to get time info of
	//! \param month date to get time info of
	//! \param day date to get time info of
	//! \return dayTimeInfoArray's count
	int GetDayTimeInfoArray(out notnull array<SCR_DayTimeInfoBase> dayTimeInfoArray, int year = -1, int month = -1, int day = -1)
	{
		CreateDayTimeInfoArray(year, month, day);
		
		dayTimeInfoArray.Clear();
		
		foreach (SCR_DayTimeInfoBase info: m_aOrderedDaytimeInfo)
			dayTimeInfoArray.Insert(info);
		
		return dayTimeInfoArray.Count();
	}
	
	/*!
	Gets array of ordered Wind Direction info
	\param[out] orderedWindDirectionInfo array of winddirection info
	\return int count of array
	*/

	//------------------------------------------------------------------------------------------------
	//! \param orderedWindDirectionInfo
	//! \return
	int GetOrderedWindDirectionInfoArray(notnull array<SCR_WindDirectionInfo> orderedWindDirectionInfo)
	{
		foreach (SCR_WindDirectionInfo windInfo: m_OrderedWindDirectionInfo)
			orderedWindDirectionInfo.Insert(windInfo);
		
		return m_OrderedWindDirectionInfo.Count();
	}
	
	/*!
	Gets wind direction info using index of array
	\param index index to find winddirection info
	\param[out] windDirectionInfo found winddirection info
	\return bool returns true if winddirection info found
	*/

	//------------------------------------------------------------------------------------------------
	//! \param index
	//! \param[out] windDirectionInfo
	//! \return
	bool GetWindDirectionInfoFromIndex(int index, out SCR_WindDirectionInfo windDirectionInfo)
	{
		if (m_OrderedWindDirectionInfo.IsEmpty() || index < 0 || index >= m_OrderedWindDirectionInfo.Count())
			return false;
		
		windDirectionInfo = m_OrderedWindDirectionInfo[index];
		return true;
	}
	
	/*!
	Gets wind direction info from winddirection float
	\param windDirectionFloat winddirection of which to find the info
	\param[out] index index of winddirection info
	\param[out] windDirectionInfo found winddirection info
	\return bool returns true if winddirection info found
	*/

	//------------------------------------------------------------------------------------------------
	//! \param windDirectionFloat
	//! \param[out] index
	//! \param[out] windDirectionInfo
	//! \return
	bool GetWindDirectionInfoFromFloat(float windDirectionFloat, out int index, out SCR_WindDirectionInfo windDirectionInfo)
	{
		if (m_OrderedWindDirectionInfo.IsEmpty() || m_OrderedWindDirectionInfo.Count() < 2)
			return false;
		
		int count = m_OrderedWindDirectionInfo.Count();
		float checkRange = (m_OrderedWindDirectionInfo[1].GetWindDirectionValue() - m_OrderedWindDirectionInfo[0].GetWindDirectionValue()) / 2;
		
		for (int i = 0; i < count; i++)
		{
			float firstCheck = m_OrderedWindDirectionInfo[i].GetWindDirectionValue() - checkRange;
			float secondCheck = m_OrderedWindDirectionInfo[i].GetWindDirectionValue() + checkRange;
	
			if (firstCheck < 0)
			{			
				firstCheck = firstCheck + 360;	
				if ((windDirectionFloat <= m_OrderedWindDirectionInfo[i].GetWindDirectionValue() || windDirectionFloat >= firstCheck) || (windDirectionFloat < secondCheck))
				{
					index = i;
					windDirectionInfo = m_OrderedWindDirectionInfo[i];
					return true;
				}
				
			}
			else if (secondCheck > 360)
			{
				secondCheck = secondCheck - 360;
				if ((windDirectionFloat >= firstCheck) && (windDirectionFloat > m_OrderedWindDirectionInfo[i].GetWindDirectionValue() || windDirectionFloat <= secondCheck))
				{
					index = i;
					windDirectionInfo = m_OrderedWindDirectionInfo[i];
					return true;
				}
			}
			else 
			{
				if (windDirectionFloat >= firstCheck && windDirectionFloat < secondCheck)
				{
					index = i;
					windDirectionInfo = m_OrderedWindDirectionInfo[i];
					return true;
				}
			}
		}
		return false;
	}

	/*!
	Sets wind override true or false. Will wait a frame before it is applied so wind direction change and wind speed change can be executed
	\param overrideWind if true wind will be set to override using m_fDelayedWindSpeedOverride and m_fDelayedWindDirectionOverride
	\param playerChangingWind player who changed the wind override to show a notification
	*/

	//------------------------------------------------------------------------------------------------
	//!
	//! \param overrideWind
	//! \param playerChangingWind
	void DelayedSetWindOverride(bool overrideWind, int playerChangingWind = -1)
	{
		m_bDelayedWindOverride = overrideWind;
		
		if (playerChangingWind > -1)
			m_iDelayedPlayerChangingWind = playerChangingWind;
		
		StartListeningToWindApplyDelay();
	}
	
	/*!
	Sets wind speed override. Will wait a frame before it is applied. Will do nothing if m_bDelayedWindOverride is false
	\params windSpeed new windspeed
	\param playerChangingWind player who changed the wind override to show a notification
	*/

	//------------------------------------------------------------------------------------------------
	//!
	//! \param windSpeed
	//! \param playerChangingWind
	void DelayedOverrideWindSpeed(float windSpeed, int playerChangingWind = -1)
	{
		m_fDelayedWindSpeedOverride = windSpeed;
		
		if (playerChangingWind > -1)
			m_iDelayedPlayerChangingWind = playerChangingWind;
		
		StartListeningToWindApplyDelay();
	}
	
	/*!
	Sets wind direction override. Will wait a frame before it is applied. Will do nothing if m_bDelayedWindOverride is false
	\params windDirection new winddirection
	\param playerChangingWind player who changed the wind override to show a notification
	*/

	//------------------------------------------------------------------------------------------------
	//!
	//! \param windDirection
	//! \param playerChangingWind
	void DelayedOverrideWindDirection(float windDirection, int playerChangingWind = -1)
	{
		m_fDelayedWindDirectionOverride = windDirection;
		
		if (playerChangingWind > -1)
			m_iDelayedPlayerChangingWind = playerChangingWind;
		
		StartListeningToWindApplyDelay();
	}
	
	//Start listening to the frame delay to execute all wind changed in one go
	protected void StartListeningToWindApplyDelay()
	{
		if (m_bListiningToWindOverrideDelay)
			return;
		
		m_bListiningToWindOverrideDelay = true;
		GetGame().GetCallqueue().CallLater(DelayedApplyWindOverride, 1);
	}
	
	//Applies all wind override changes in one go instead of separately setting wind speed and wind direction override.
	//Also shows noptification if m_iDelayedPlayerChangingWind is set 
	protected void DelayedApplyWindOverride()
	{		
		//Set wind to auto
		if (!m_bDelayedWindOverride)
		{
			SetWindSpeedOverride(false);
			SetWindDirectionOverride(false);
			
			//Notification wind default
			if (m_iDelayedPlayerChangingWind > -1)
				SCR_NotificationsComponent.SendToUnlimitedEditorPlayers(ENotification.EDITOR_ATTRIBUTES_WIND_DEFAULT, m_iDelayedPlayerChangingWind);
		}
		//Override wind
		else 
		{
			if (m_fDelayedWindSpeedOverride == -1)
				m_fDelayedWindSpeedOverride = GetWindSpeed();
			
			SetWindSpeedOverride(true, m_fDelayedWindSpeedOverride);
			
			if (m_fDelayedWindDirectionOverride == -1)
				m_fDelayedWindDirectionOverride =  GetWindDirection();
			
			SetWindDirectionOverride(true, m_fDelayedWindDirectionOverride);	
			
			//Notification wind override
			if (m_iDelayedPlayerChangingWind > -1)
			{
				SCR_WindDirectionInfo windDirectionInfo;
				int windDirectionIndex;
				GetWindDirectionInfoFromFloat(m_fDelayedWindDirectionOverride, windDirectionIndex, windDirectionInfo);
				SCR_NotificationsComponent.SendToUnlimitedEditorPlayers(ENotification.EDITOR_ATTRIBUTES_WIND_CHANGED, m_iDelayedPlayerChangingWind, m_fDelayedWindSpeedOverride * 1000, windDirectionIndex);
			}
		}
		
		ClearDelayedWindOverrideVars();
	}
	
	//Reset all changed wind varriables
	protected void ClearDelayedWindOverrideVars()
	{
		m_bListiningToWindOverrideDelay = false;
		m_bDelayedWindOverride = IsWindSpeedOverridden() || IsWindDirectionOverridden();
		m_iDelayedPlayerChangingWind = -1;
		m_fDelayedWindSpeedOverride = -1;
		m_fDelayedWindDirectionOverride = -1;
	}
	
	/*!
	Sets current time of the day via a script wrapper.
	\see SetHoursMinutesSeconds for more detailed description.
	\params cont Script wrapper for time in hours, minutes and seconds
	\return Returns true when command is issued successfully, false otherwise.
	*/

	//------------------------------------------------------------------------------------------------
	//! \param cont
	//! \return
	bool SetTime(TimeContainer cont)
	{
		return SetHoursMinutesSeconds(cont.m_iHours, cont.m_iMinutes, cont.m_iSeconds);
	}
	
	//------------------------------------------------------------------------------------------------
	/*!
	\return Get on weather state preview enabled/disabled
	*/

	//------------------------------------------------------------------------------------------------
	//! \return
	ScriptInvokerBase<SCR_TimeAndWeatherManager_OnWeatherStatePreview> GetOnWeatherStatePreview()
	{
		if (!m_OnWeatherStatePreview)
			m_OnWeatherStatePreview = new ScriptInvokerBase<SCR_TimeAndWeatherManager_OnWeatherStatePreview>();
	
		return m_OnWeatherStatePreview;
	}
	
	//------------------------------------------------------------------------------------------------
	//! \return Get on wind preview enabled/disabled
	ScriptInvokerBase<SCR_TimeAndWeatherManager_OnWindPreview> GetOnWindPreview()
	{
		if (!m_OnWindPreview)
			m_OnWindPreview = new ScriptInvokerBase<SCR_TimeAndWeatherManager_OnWindPreview>();
	
		return m_OnWindPreview;
	}
	
	//------------------------------------------------------------------------------------------------
	/*!
	\return Get on date time preview enabled/disabled
	*/

	//------------------------------------------------------------------------------------------------
	//! \return
	ScriptInvokerBase<SCR_TimeAndWeatherManager_OnDateTimePreview> GetOnDateTimePreview()
	{
		if (!m_OnDateTimePreview)
			m_OnDateTimePreview = new ScriptInvokerBase<SCR_TimeAndWeatherManager_OnDateTimePreview>();
	
		return m_OnDateTimePreview;
	}
	
	//======================================== RPL ========================================\\

	//------------------------------------------------------------------------------------------------
	override bool RplSave(ScriptBitWriter writer)
    {	
        writer.WriteBool(m_bWeatherIsLooping); 
        return true;
    }

	//------------------------------------------------------------------------------------------------
	override bool RplLoad(ScriptBitReader reader)
    {
		int isLooping;
		
        reader.ReadBool(isLooping);

		
		UpdateWeatherLooping(isLooping);
		
        return true;
    }
	
	/*!
	Forces weather to supplied state. 
	Also computes a new state transition and variant transitions.
	
	Can only be set by the authority (server, singleplayer...).
	
	\param stateName Name of the state
	\param setToStartVariant Set state to start variant (recommend = true), true by default.
	\return False if not authority or state does not exist within state machine. True otherwise.
	*/
	 //proto native bool SetWeatherState(string stateName, bool setToStartVariant = true);
	 
	/*!
	Forces state to supplied variant.
	Also computes a new variant transition.
	
	Can only be set by the authority (server, singleplayer...).
	
	\return False if not authority or variant does not exist within current state. True otherwise.
	*/
	//proto native bool SetWeatherVariant(string variantName);

	/*!
	Forces weather to supplied state and variant.
	Can only be set by the authority (server, singleplayer...)
	\return False if not authority or state does not exist or variant doest not exist within selected state. True otherwise.
	*/
	//proto native bool SetWeatherStateAndVariant(string stateName, string variantName);
	
	/*!
	Tries to request a state transition.
	Can only be set by the authority (server, singleplayer...)
	\param stateName destination state name
	\param durationHrs Transition duration (if greater than 0). Otherwise random duration between min/max limits.
	\return WeatherTransitionRequestResponse with result of call
	*/
	//proto native WeatherTransitionRequestResponse RequestWeatherStateTransition(string stateName, float durationHrs = 0);
	
	/*!
	Tries to request a variant transition.
	Can only be set by the authority (server, singleplayer...)
	\param variatName destination variant name
	\param durationHrs Transition duration (if greater than 0). Otherwise random duration between min/max limits.
	\return WeatherTransitionRequestResponse with result of call
	*/
	//proto native WeatherTransitionRequestResponse RequestWeatherVariantTransition(string variantName, float durationHrs = 0);
}

//! Simple container holding in-game time data in hours, minutes, seconds format.
class TimeContainer
{
	//!< In-game hours <0, 24>
	int m_iHours;
	//!< In-game minutes <0, 60>
	int m_iMinutes;
	//!< In-game seconds <0, 60>
	int m_iSeconds;
	
	/*!
		Creates new time container from provided params.
		Actual values can be retrieved via TimeAndWeatherManagerEntity.
		\param hours Hours <0,24>
		\param minutes Minutes <0,60>
		\param seconds Seconds <0,60>
	*/

	//------------------------------------------------------------------------------------------------
	// constructor
	//! \param hours
	//! \param minutes
	//! \param seconds
	void TimeContainer(int hours = 0, int minutes = 0, int seconds = 0)
	{
		m_iHours = hours;
		m_iMinutes = minutes;
		m_iSeconds = seconds;
	}
	
	/*
		Creates new time container from hours, minutes and seconds.
	*/

	//------------------------------------------------------------------------------------------------
	//!
	//! \param hours
	//! \param minutes
	//! \param seconds
	//! \return
	static TimeContainer FromHoursMinutesSeconds(int hours, int minutes, int seconds)
	{
		return new TimeContainer(hours, minutes, seconds);
	}
	
	/*
		Creates new time container from time of  the day <0.0, 0.24>
	*/

	//------------------------------------------------------------------------------------------------
	//!
	//! \param hours24
	//! \return
	static TimeContainer FromTimeOfTheDay(float hours24)
	{
		int h, m, s;
		TimeAndWeatherManagerEntity.TimeToHoursMinutesSeconds(hours24, h, m, s);
		return new TimeContainer(h, m, s);
	}
	
	/*
		Converts the content of this container into in-game time as a fraction of day <0.0, 0.24>.
	*/

	//------------------------------------------------------------------------------------------------
	//!
	//! \return
	float ToTimeOfTheDay()
	{
		return TimeAndWeatherManagerEntity.HoursMinutesSecondsToTime(m_iHours, m_iMinutes, m_iSeconds);
	}
}

[BaseContainerProps(), SCR_BaseContainerCustomTitleEnum(EDayTimeEnums, "m_dayTimeEnum")]
class SCR_DayTimeInfoBase
{
	[Attribute("0", UIWidgets.ComboBox, "Day Time Enum", "", ParamEnumArray.FromEnum(EDayTimeEnums))]
	protected EDayTimeEnums m_DayTimeEnum;
		
	[Attribute()]
	protected ref SCR_UIInfo m_UIInfo;
	
	protected float m_fTimeOfDay = -1;
	
	//------------------------------------------------------------------------------------------------
	//! Gets time of day UI info
	//! \return SCR_UIInfo ui info of time of day
	SCR_UIInfo GetDayTimeUIInfo()
	{
		return m_UIInfo;
	}
	
	//------------------------------------------------------------------------------------------------
	//! Gets time of day enum
	//! \return time of day enum
	EDayTimeEnums GetDaytimeEnum()
	{
		return m_DayTimeEnum;
	}
	
	//------------------------------------------------------------------------------------------------
	//! Gets time of day in seconds. This is when the time of day starts
	//! \return seconds of starting time of time of day
	float GetDayTime()
	{
		return m_fTimeOfDay;
	}

	//------------------------------------------------------------------------------------------------
	//! Clear the data
	void Clear()
	{
		m_fTimeOfDay = -1;
	}

	//------------------------------------------------------------------------------------------------
	//! Gets time of day in seconds. This is when the time of day starts. Used when init other times of day
	//! \param daytimeInfo array of other time of days to get info from
	//! \return seconds of starting time of time of day
	float GetDayTime(notnull array<ref SCR_DayTimeInfoBase> daytimeInfo, TimeAndWeatherManagerEntity timeAndWeatherEntity)
	{
		if (m_fTimeOfDay < 0)
			SetDayTime(daytimeInfo, timeAndWeatherEntity);
		
		return m_fTimeOfDay;
	}

	//------------------------------------------------------------------------------------------------
	//! Sets the starting time of the time of day in seconds
	//! \param daytimeInfo array of other time of days to get info from
	//! \param timeAndWeatherEntity
	//! \param year
	//! \param month
	//! \param day
	void SetDayTime(notnull array<ref SCR_DayTimeInfoBase> daytimeInfo, TimeAndWeatherManagerEntity timeAndWeatherEntity, int year = -1, int month = -1, int day = -1)
	{
		Print(string.Format("%1 Uses the SCR_DayTimeInfoBase use one of the inherited classes instead!", typename.EnumToString(EDayTimeEnums, m_DayTimeEnum)), LogLevel.WARNING);
	}
}

[BaseContainerProps(), SCR_BaseContainerCustomTitleEnum(EDayTimeEnums, "m_dayTimeEnum")]
class SCR_DayTimeInfoStatic: SCR_DayTimeInfoBase
{
	[Attribute(desc: "Hour which this daytime starts, is a value of 0 to 24.0")]
	protected int m_iHour;

	//------------------------------------------------------------------------------------------------
	override void SetDayTime(notnull array<ref SCR_DayTimeInfoBase> daytimeInfo, TimeAndWeatherManagerEntity timeAndWeatherEntity, int year = -1, int month = -1, int day = -1)
	{
		if (m_fTimeOfDay > -1)
			return;
		
		m_fTimeOfDay = m_iHour;
	}
}

[BaseContainerProps(), SCR_BaseContainerCustomTitleEnum(EDayTimeEnums, "m_dayTimeEnum")]
class SCR_DayTimeInfoAuto: SCR_DayTimeInfoBase
{
	//------------------------------------------------------------------------------------------------
	override void SetDayTime(notnull array<ref SCR_DayTimeInfoBase> daytimeInfo, TimeAndWeatherManagerEntity timeAndWeatherEntity, int year = -1, int month = -1, int day = -1)
	{
		if (m_fTimeOfDay > -1)
			return;
		
		if (year < 0)
		{
			timeAndWeatherEntity.GetDate(year, month, day);
		}
		
		bool hasSunSetandRise;
		
		switch (m_DayTimeEnum)
		{
			//~Todo: Needs to get sunset/sun rise of given date
			case EDayTimeEnums.DAYTIME_DAWN:
			{	
				hasSunSetandRise = timeAndWeatherEntity.GetSunriseHourForDate(year, month, day, timeAndWeatherEntity.GetCurrentLatitude(), timeAndWeatherEntity.GetCurrentLongitude(), timeAndWeatherEntity.GetTimeZoneOffset(),  timeAndWeatherEntity.GetDSTOffset(),  m_fTimeOfDay);
				
				//If has no sun rise
				if (!hasSunSetandRise)
					m_fTimeOfDay = 5;

				return;
			}
			//~Todo: Get sunset time
			case EDayTimeEnums.DAYTIME_DUSK:
			{	
				hasSunSetandRise = timeAndWeatherEntity.GetSunsetHourForDate(year, month, day, timeAndWeatherEntity.GetCurrentLatitude(), timeAndWeatherEntity.GetCurrentLongitude(), timeAndWeatherEntity.GetTimeZoneOffset(),  timeAndWeatherEntity.GetDSTOffset(),  m_fTimeOfDay);
				
				//If has no sun set
				if (!hasSunSetandRise)
					m_fTimeOfDay = 19;
				
				return;
			}
		}
			
		Print(string.Format("%1 is not supported with autoTime!", typename.EnumToString(EDayTimeEnums, m_DayTimeEnum)), LogLevel.WARNING);
	}
}

[BaseContainerProps(), SCR_BaseContainerCustomTitleEnum(EDayTimeEnums, "m_dayTimeEnum")]
class SCR_DayTimeInfoBetween: SCR_DayTimeInfoBase
{
	[Attribute("0", UIWidgets.ComboBox, "Day Time X", "", ParamEnumArray.FromEnum(EDayTimeEnums))]
	protected EDayTimeEnums m_DaytimeAfter;
	
	[Attribute("0", UIWidgets.ComboBox, "Day Time Y", "", ParamEnumArray.FromEnum(EDayTimeEnums))]
	protected EDayTimeEnums m_DaytimeBefore;

	//------------------------------------------------------------------------------------------------
	override void SetDayTime(notnull array<ref SCR_DayTimeInfoBase> daytimeInfo, TimeAndWeatherManagerEntity timeAndWeatherEntity, int year = -1, int month = -1, int day = -1)
	{
		if (m_DayTimeEnum == m_DaytimeAfter || m_DayTimeEnum == m_DaytimeBefore)
		{	
			Print(string.Format("SCR_DayTimeInfoBetween %1 has a reference to itself!", typename.EnumToString(EDayTimeEnums, m_DayTimeEnum)), LogLevel.WARNING);	
			return;
		}
		
		if (m_fTimeOfDay > -1)
			return;
		
		float dayTimeAfterSeconds, DayTimeBeforeSeconds;
		bool dayTimeAfterSet = false;
		bool dayTimeBeforeSet = false;
		
		foreach (SCR_DayTimeInfoBase daytime: daytimeInfo)
		{
			if (daytime.GetDaytimeEnum() == m_DaytimeAfter)
			{
				dayTimeAfterSeconds = daytime.GetDayTime(daytimeInfo, timeAndWeatherEntity);
				dayTimeAfterSet = true;
				
				if (dayTimeAfterSeconds == 24)
					dayTimeAfterSeconds = 0;
				
				if (dayTimeAfterSet && dayTimeBeforeSet)
					break;
			}
			else if (daytime.GetDaytimeEnum() == m_DaytimeBefore)
			{
				DayTimeBeforeSeconds = daytime.GetDayTime(daytimeInfo, timeAndWeatherEntity);
				dayTimeBeforeSet = true;
				
				if (DayTimeBeforeSeconds == 0)
					DayTimeBeforeSeconds = 24;
				
				if (dayTimeAfterSet && dayTimeBeforeSet)
					break;
			}
		}
		
		if (dayTimeAfterSeconds < 0 || !dayTimeAfterSet)
		{
			Print(string.Format("Could not set %1 as %2 daytime after was not correctly found! This might be because %2 is also depened on %1 or that it doesn't exist in the array!", typename.EnumToString(EDayTimeEnums, m_DayTimeEnum), typename.EnumToString(EDayTimeEnums, m_DaytimeAfter)), LogLevel.WARNING);
			m_fTimeOfDay = 0;
			return;
		}
			
		if (DayTimeBeforeSeconds < 0 || !dayTimeBeforeSet)
		{
			Print(string.Format("Could not set %1 as %2 daytime before was not correctly found! This might be because %2 is also depened on %1 or that it doesn't exist in the array!", typename.EnumToString(EDayTimeEnums, m_DayTimeEnum), typename.EnumToString(EDayTimeEnums, m_DaytimeBefore)), LogLevel.WARNING);  
			m_fTimeOfDay = 0;
			return;
		}
		
		m_fTimeOfDay = (dayTimeAfterSeconds + DayTimeBeforeSeconds) / 2;
	}
}

[BaseContainerProps(), SCR_BaseContainerCustomTitleUIInfo("m_UIInfo")]
class SCR_WindDirectionInfo
{
	[Attribute()]
	ref SCR_UIInfo m_UIInfo;
	
	[Attribute()]
	protected int m_iWindDirection;
	
	//------------------------------------------------------------------------------------------------
	//! \return
	SCR_UIInfo GetUIInfo()
	{
		return m_UIInfo;
	}
	
	//------------------------------------------------------------------------------------------------
	//! \return wind direction in degrees
	int GetWindDirectionValue()
	{
		return m_iWindDirection;
	}
}

[BaseContainerProps(), SCR_BaseContainerCustomTitleUIInfo("m_UIInfo")]
class SCR_MoonPhaseInfo
{
	[Attribute()]
	ref SCR_MoonPhaseUIInfo m_UIInfo;
	
	[Attribute(desc: "IsMoonPhase will return true if moonPhaseAmount is equal or greater then m_fPhaseEqualOrGreater and less then m_fPhaseLessThen")]
	protected float m_fPhaseEqualOrGreater;
	
	[Attribute(desc: "IsMoonPhase will return true if moonPhaseAmount is equal or greater then m_fPhaseEqualOrGreater and less then m_fPhaseLessThen")]
	protected float m_fPhaseLessThen;
	
	//! Before full moon means first quarter and waxing Crescent/Gibbous\
	//! After full moon meaning it is third Quarter and Waning Crescent/Gibbous\
	//! Ignore means full moon or new moon
	[Attribute("0", UIWidgets.ComboBox, "Before Or AfterFull Moon", "", ParamEnumArray.FromEnum(EMoonPhaseEnums))]
	protected EMoonPhaseEnums m_iBeforeOrAfterFullMoon;
	
	//------------------------------------------------------------------------------------------------
	//! \return
	SCR_MoonPhaseUIInfo GetUIInfo()
	{
		return m_UIInfo;
	}
	
	//------------------------------------------------------------------------------------------------
	//! \param moonPhaseAmount
	//! \param beforeOrAfterFullMoon
	//! \return true if the moon phase matches, false otherwise
	bool IsMoonPhase(float moonPhaseAmount, EMoonPhaseEnums beforeOrAfterFullMoon)
	{
		if (m_iBeforeOrAfterFullMoon != EMoonPhaseEnums.IGNORE && beforeOrAfterFullMoon != EMoonPhaseEnums.IGNORE)
		{
			if (m_iBeforeOrAfterFullMoon != beforeOrAfterFullMoon)
				return false;
		}
		
		return moonPhaseAmount >= m_fPhaseEqualOrGreater && moonPhaseAmount < m_fPhaseLessThen;
	}
}

enum EMoonPhaseEnums
{
	IGNORE,
	BEFORE_FULL_MOON,
	AFTER_FULL_MOON
}

enum EDayTimeEnums
{
	DAYTIME_DAWN,
	DAYTIME_MORNING,
	DAYTIME_AFTERNOON,
	DAYTIME_DUSK,
	DAYTIME_EVENING,
	DAYTIME_NIGHT
}
//SCR_WeatherUseAdvancedEditorAttribute
[BaseContainerProps(), SCR_BaseEditorAttributeCustomTitle()]
class SCR_WeatherUseAdvancedEditorAttribute : SCR_BaseEditorAttribute
{	
	/*override SCR_BaseEditorAttributeVar ReadVariable(Managed item, SCR_AttributesManagerEditorComponent manager)
	{
		//Disabled for now
		return null;
		
		//If opened in global attributes
		if (!IsGameMode(item)) return null;
		
		BaseGameMode gameMode = GetGame().GetGameMode();
		if (!gameMode)
			return null;
		
		SCR_TimeAndWeatherEditorComponent editorWeatherComponent = SCR_TimeAndWeatherEditorComponent.Cast(gameMode.FindComponent(SCR_TimeAndWeatherEditorComponent));
		if (!editorWeatherComponent)
			return null;
	
		return SCR_BaseEditorAttributeVar.CreateBool(editorWeatherComponent.GetUseAdvancedWeather());
	}
	
	//Disable respawn time if respawning is disabled
	override void UpdateInterlinkedVariables(SCR_BaseEditorAttributeVar var, SCR_AttributesManagerEditorComponent manager, bool isInit = false)
	{			
		bool useAdvanced = false;
	
		if (var)
	 		useAdvanced = var.GetBool();
		
		manager.SetAttributeEnabled(SCR_WeatherInstantTransitionTimeEditorAttribute, var && !useAdvanced);
		manager.SetAttributeEnabled(SCR_WeatherInstantEditorAttribute, var && !useAdvanced);
	}
	
	override void WriteVariable(Managed item, SCR_BaseEditorAttributeVar var, SCR_AttributesManagerEditorComponent manager, int playerID)
	{
		if (!var) 
			return;
		
		BaseGameMode gameMode = GetGame().GetGameMode();
		if (!gameMode)
			return;
		
		SCR_TimeAndWeatherEditorComponent editorWeatherComponent = SCR_TimeAndWeatherEditorComponent.Cast(gameMode.FindComponent(SCR_TimeAndWeatherEditorComponent));
		if (!editorWeatherComponent)
			return;
		
		editorWeatherComponent.SetUseAdvancedWeather(var.GetBool());
		
	}*/
};

class SCR_WeatherState: WeatherState
{
	//~ Add any custom info for weather states
};

//
/**
Respawn attribute to enable/disable respawn and respawn time, for getting and setting varriables in Editor Attribute window
*/
// Script File 
[BaseContainerProps(), SCR_BaseEditorAttributeCustomTitle()]
class SCR_WeatherInstantTransitionTimeEditorAttribute : SCR_BaseValueListEditorAttribute
{
	override SCR_BaseEditorAttributeVar ReadVariable(Managed item, SCR_AttributesManagerEditorComponent manager)
	{
		//~Todo: Disabled for now until instant transition can have time assigned to it
		return null;
		
		//If opened in global attributes
		if (!IsGameMode(item)) 
			return null;

		BaseGameMode gameMode = GetGame().GetGameMode();
		if (!gameMode)
			return null;
		
		/*SCR_TimeAndWeatherEditorComponent editorWeatherComponent = SCR_TimeAndWeatherEditorComponent.Cast(gameMode.FindComponent(SCR_TimeAndWeatherEditorComponent));
		if (!editorWeatherComponent)
			return null;*/
		
		//~Todo: Not implemented
		return null;
		//return SCR_BaseEditorAttributeVar.CreateInt(editorWeatherComponent.GetWeatherInstantTransitionTime());
	}
	
	override void WriteVariable(Managed item, SCR_BaseEditorAttributeVar var, SCR_AttributesManagerEditorComponent manager, int playerID)
	{
		if (!var) 
			return;

		BaseGameMode gameMode = GetGame().GetGameMode();
		if (!gameMode)
			return;
		
		/*SCR_TimeAndWeatherEditorComponent editorWeatherComponent = SCR_TimeAndWeatherEditorComponent.Cast(gameMode.FindComponent(SCR_TimeAndWeatherEditorComponent));
		if (!editorWeatherComponent)
			return;*/
		
		//~Todo: Not implemented
		//editorWeatherComponent.SetWeatherInstantTransitionTime(var.GetInt());
	}	
	
	override int GetEntries(notnull array<ref SCR_BaseEditorAttributeEntry> outEntries)
	{
		outEntries.Insert(new SCR_BaseEditorAttributeEntryTimeSlider(1, false));
		return super.GetEntries(outEntries);
	}
};
/**
Weather Attribute for getting and setting varriables in Editor Attribute window
*/
[BaseContainerProps(), SCR_BaseEditorAttributeCustomTitle()]
class SCR_WeatherInstantEditorAttribute: SCR_BasePresetsEditorAttribute
{	
	[Attribute("MISSING NAME", desc: "Text shown if weather State has no weather name assigned")]
	protected LocalizedString m_sUnknownWeatherName;
	
	[Attribute("{4B4B51FACB828BF9}UI/Textures/Tasks/TaskIcons/96/Icon_Task_Unknown.edds", desc: "Icon used when weather is unknown")]
	protected ResourceName m_sUnknownWeatherIcon;
	
	override SCR_BaseEditorAttributeVar ReadVariable(Managed item, SCR_AttributesManagerEditorComponent manager)
	{		
		//If opened in global attributes
		if (!IsGameMode(item)) 
			return null;
		
		GenericEntity ent = GenericEntity.Cast(item);
		ChimeraWorld world = ent.GetWorld();
		TimeAndWeatherManagerEntity weatherManager = world.GetTimeAndWeatherManager();
		if (!weatherManager) 
			return null;
		
		BaseWeatherStateTransitionManager weatherTransitionManager = weatherManager.GetTransitionManager();
		if (!weatherTransitionManager)
			return null;
		
		array<ref WeatherState> weatherStates = new array<ref WeatherState>;
		
		//Get weather states
		weatherManager.GetWeatherStatesList(weatherStates);
		if (weatherStates.IsEmpty()) 
			return null;
		
		WeatherState currentState = weatherManager.GetCurrentWeatherState();
		return SCR_BaseEditorAttributeVar.CreateInt(currentState.GetStateID());
	}
	
	override void WriteVariable(Managed item, SCR_BaseEditorAttributeVar var, SCR_AttributesManagerEditorComponent manager, int playerID)
	{
		if (!var) 
			return;
		
		BaseGameMode gameMode = GetGame().GetGameMode();
		if (!gameMode)
			return;
		
		ChimeraWorld world = ChimeraWorld.CastFrom(gameMode.GetWorld());
		if (!world)
			return;

		TimeAndWeatherManagerEntity weatherManager = world.GetTimeAndWeatherManager();
		if (!weatherManager) 
			return;
		
		int stateIndex = var.GetInt();
		
		array<ref WeatherState> weatherStates = new array<ref WeatherState>;
		weatherManager.GetWeatherStatesList(weatherStates);
		
		//Valid state
		if (weatherStates.IsEmpty() || stateIndex >= weatherStates.Count())
			return;
		
		WeatherState weatherToSet = weatherStates[stateIndex];
				
		//Preview Weather
		if (!item)
		{
			weatherManager.SetWeatherStatePreview(true, weatherToSet.GetStateName());
			return;
		}
		
		float transitionTime = 0;
		
		SCR_BaseEditorAttributeVar transitionVar;
		if (manager && manager.GetAttributeVariable(SCR_WeatherInstantTransitionTimeEditorAttribute, transitionVar))
			transitionTime = transitionVar.GetInt();
		
		weatherManager.ForceWeatherTo(true, weatherToSet.GetStateName(), transitionTime / 3600, 0.001, playerID);
	}
	
	override void PreviewVariable(bool setPreview, SCR_AttributesManagerEditorComponent manager)
	{
		//Preview weather. Note that if advanced is turned on preview should disapear
		if (setPreview)
		{
			WriteVariable(null, GetVariable(), manager, -1);
		}
		else 
		{
			ChimeraWorld world = GetGame().GetWorld();
			TimeAndWeatherManagerEntity weatherManager = world.GetTimeAndWeatherManager();
			if (!weatherManager) 
				return;
		
			BaseWeatherStateTransitionManager weatherTransitionManager = weatherManager.GetTransitionManager();
			if (!weatherTransitionManager)
				return;
			
			//Remove preview
			if (weatherTransitionManager.IsPreviewingState())
				weatherManager.SetWeatherStatePreview(false);
		}
	}
	
	protected override void CreatePresets()
	{
		m_aValues.Clear();
		
		SCR_EditorAttributeFloatStringValueHolder value;
		
		array<ref WeatherState> weatherStates = new array<ref WeatherState>;
		ChimeraWorld world = GetGame().GetWorld();
		TimeAndWeatherManagerEntity weatherManager = world.GetTimeAndWeatherManager();
		if (!weatherManager)
			return;
		
		weatherManager.GetWeatherStatesList(weatherStates);
		
		int count = weatherStates.Count();
		string weatherName, weatherIconPath;
		
		//Create preset list
		for (int i = 0; i < count; i++)
		{
			value = new SCR_EditorAttributeFloatStringValueHolder();
			
			weatherName = weatherStates[i].GetLocalizedName();
			weatherIconPath = weatherStates[i].GetIconPath();
			
			if (SCR_StringHelper.IsEmptyOrWhiteSpace(weatherName))
			{
				weatherName = m_sUnknownWeatherName;
				Print("WeatherState: '" +  weatherStates[i].GetStateID() + "' does not have weather localization name assigned!", LogLevel.ERROR);
			}
			
			
			if (SCR_StringHelper.IsEmptyOrWhiteSpace(weatherIconPath))
			{
				weatherIconPath = m_sUnknownWeatherIcon;
				Print("WeatherState: '" +  weatherStates[i].GetStateID() + "' does not have weather icon assigned!", LogLevel.ERROR);
			}
				
			value.SetName(weatherName);
			value.SetIcon(weatherIconPath);
			value.SetFloatValue(weatherStates[i].GetStateID());
			
			m_aValues.Insert(value);
		}
	}
};

class SCR_WeatherForecastUIComponent: ScriptedWidgetComponent
{	
	[Attribute("Current_Icon")]
	protected string m_sCurrentWeatherIconName;
	
	[Attribute("Current_Name")] 
	protected string m_sCurrentWeatherTextName;
	
	[Attribute("Forecast_Icon")]
	protected string m_sNextWeatherIconName;
	
	[Attribute("Forecast_Title")] 
	protected string m_sNextWeatherTimeName;
	
	[Attribute("Forecast_Name")] 
	protected string m_sNextWeatherTextName;
	
	[Attribute("GameInfo_Weather_Forecast")] 
	protected string m_sNextWeatherHolderName;
	
	[Attribute("#AR-Weather_Forecast_Looping", uiwidget: UIWidgets.LocaleEditBox)]
	protected LocalizedString m_sLoopingWeatherText;
	
	[Attribute("1", "Update freq of weather UI in seconds")]
	protected float m_fUIUpdateFreq;
	
	[Attribute("MISSING NAME", desc: "Text shown if weather State has no weather name assigned")]
	protected LocalizedString m_sUnknownWeatherName;
	
	[Attribute("{4B4B51FACB828BF9}UI/Textures/Tasks/TaskIcons/96/Icon_Task_Unknown.edds", desc: "Icon used when weather is unknown")]
	protected ResourceName m_sUnknownWeatherIcon;
	
	protected bool m_bListeningToUpdate;
	
	protected TimeAndWeatherManagerEntity m_TimeAndWeatherEntity;
	protected BaseWeatherStateTransitionManager m_WeatherStateManager;
	protected ref array<ref WeatherState> m_WeatherStates = new array<ref WeatherState>;
	
	protected ImageWidget m_wCurrentWeatherIcon;
	protected TextWidget m_wCurrentWeatherText;
	protected TextWidget m_wNextWeatherText;
	protected TextWidget m_wNextWeatherTimeText;
	protected ImageWidget m_wNextWeatherIcon;
	protected Widget m_wNextWeatherHolder;
	protected Widget m_wRoot;
	
	//~Todo: Update using TimeAndWeather callback once implemented
	protected void CheckWeatherUpdate()
	{	
		if (m_WeatherStateManager.IsPreviewingState())
			return;
		
		WeatherState currentWeather = m_WeatherStateManager.GetCurrentState();		

		//~ Get weather name
		string weatherName = currentWeather.GetLocalizedName();
		if (SCR_StringHelper.IsEmptyOrWhiteSpace(weatherName))
			weatherName = m_sUnknownWeatherName;
			
		//~ Get weather Icon
		string weatherIcon = currentWeather.GetIconPath();
		if (SCR_StringHelper.IsEmptyOrWhiteSpace(weatherIcon))
			weatherIcon = m_sUnknownWeatherIcon;
		
		m_wCurrentWeatherText.SetText(weatherName);
		m_wCurrentWeatherIcon.LoadImageTexture(0, weatherIcon);
		
		WeatherState nextWeather = m_WeatherStateManager.GetNextState();
		if (!nextWeather)
		{
			m_wNextWeatherHolder.SetVisible(false);
			return;
		}
		else 
		{
			m_wNextWeatherHolder.SetVisible(true);
		}
		

		//~ Looping weather or Time progression disabled
		if (m_TimeAndWeatherEntity.IsWeatherLooping() || !m_TimeAndWeatherEntity.GetIsDayAutoAdvanced())
		{
			m_wNextWeatherTimeText.SetText(m_sLoopingWeatherText);
		}
		else 
		{
			float duration = m_WeatherStateManager.GetTimeLeftUntilNextState();
			float changeTime = duration + m_TimeAndWeatherEntity.GetTimeOfTheDay();
			while (changeTime >= 24)
				changeTime -= 24;
			int nextWeatherHour = Math.Floor(changeTime);
			int nextWeatherMinutes = (changeTime - nextWeatherHour) * 60;
			
			if (nextWeatherMinutes >= 0 && nextWeatherMinutes <= 15)
				nextWeatherMinutes = 15;
			else if (nextWeatherMinutes > 15 && nextWeatherMinutes <= 30)
				nextWeatherMinutes = 30;
			else if (nextWeatherMinutes > 30 && nextWeatherMinutes <= 45)
				nextWeatherMinutes = 45;
			else if (nextWeatherMinutes > 45)
			{
				nextWeatherMinutes = 0;
				nextWeatherHour++;
				
				if (nextWeatherHour >= 24)
					nextWeatherHour -= 24;
			}
			
			m_wNextWeatherTimeText.SetTextFormat(SCR_FormatHelper.GetTimeFormattingHoursMinutes(nextWeatherHour, nextWeatherMinutes));
		}
		
		weatherName = nextWeather.GetLocalizedName();
		if (SCR_StringHelper.IsEmptyOrWhiteSpace(weatherName))
			weatherName = m_sUnknownWeatherName;
			
		
		weatherIcon = nextWeather.GetIconPath();
		if (SCR_StringHelper.IsEmptyOrWhiteSpace(weatherIcon))
			weatherIcon = m_sUnknownWeatherIcon;

		m_wNextWeatherText.SetText(weatherName); 
		m_wNextWeatherIcon.LoadImageTexture(0, weatherIcon);
	}
	
	protected void ShowWeatherUI(bool show)
	{
		m_wRoot.SetVisible(show);
	}
	
	
	override void HandlerAttached(Widget w)
	{
		if (SCR_Global.IsEditMode())
			return;
		
		m_wRoot = w;
		m_wCurrentWeatherIcon = ImageWidget.Cast(w.FindAnyWidget(m_sCurrentWeatherIconName));
		m_wCurrentWeatherText = TextWidget.Cast(w.FindAnyWidget(m_sCurrentWeatherTextName));
		
		if (!m_wCurrentWeatherIcon || !m_wCurrentWeatherText)
		{
			Print("'SCR_WeatherForecastUIComponent' is missing current weather widgets and won't work.", LogLevel.WARNING);
			return;
		}
		
		m_wNextWeatherIcon  = ImageWidget.Cast(w.FindAnyWidget(m_sNextWeatherIconName));
		m_wNextWeatherText = TextWidget.Cast(w.FindAnyWidget(m_sNextWeatherTextName));
		m_wNextWeatherTimeText = TextWidget.Cast(w.FindAnyWidget(m_sNextWeatherTimeName));
		
		if (!m_wNextWeatherIcon || !m_wNextWeatherText || !m_wNextWeatherTimeText)
		{
			Print("'SCR_WeatherForecastUIComponent' is missing next weather widgets and won't work.", LogLevel.WARNING);
			return;
		}
		
		m_wNextWeatherHolder = w.FindAnyWidget(m_sNextWeatherHolderName);	
		
		ChimeraWorld world = GetGame().GetWorld();	
		m_TimeAndWeatherEntity = world.GetTimeAndWeatherManager();
		
		if (!m_TimeAndWeatherEntity)
		{
			ShowWeatherUI(false);
			return;
		}
			
		
		m_TimeAndWeatherEntity.GetWeatherStatesList(m_WeatherStates);
		if (m_WeatherStates.IsEmpty())
		{
			ShowWeatherUI(false);
			return;
		}
		
		m_WeatherStateManager = m_TimeAndWeatherEntity.GetTransitionManager();
		
		if (!m_WeatherStateManager)
		{
			ShowWeatherUI(false);
			return;
		}
		
		CheckWeatherUpdate();
		m_bListeningToUpdate = true;
		GetGame().GetCallqueue().CallLater(CheckWeatherUpdate, m_fUIUpdateFreq * 1000, true);
	}
	override void HandlerDeattached(Widget w)
	{
		if (m_bListeningToUpdate)
			GetGame().GetCallqueue().Remove(CheckWeatherUpdate);
	}
};
[BaseContainerProps()]
class SCR_TimeAndWeatherState
{
	[Attribute(desc: "The name of the weather preference as it can be found in weatherStates.conf.")]
	protected string m_sWeatherPresetName;
	
	[Attribute("8", UIWidgets.Slider, desc: "Starting time of day (hour)", "0 23 1")]
	protected int m_iStartingHour;

	[Attribute("0", UIWidgets.Slider, "Starting time of day (minutes)", "0 59 1")]
	protected int m_iStartingMinutes;
	
	//------------------------------------------------------------------------------------------------
	int GetStartingHour()
	{
		return m_iStartingHour;
	}
	
	//------------------------------------------------------------------------------------------------
	int GetStartingMinutes()
	{
		return m_iStartingMinutes;
	}
	
	//------------------------------------------------------------------------------------------------
	string GetWeatherPresetName()
	{
		return m_sWeatherPresetName;
	}
}

class SCR_TimeAndWeatherHandlerComponentClass : SCR_BaseGameModeComponentClass
{
}

class SCR_TimeAndWeatherHandlerComponent : SCR_BaseGameModeComponent
{
	[Attribute("8", UIWidgets.Slider, "Starting time of day (hours)", "0 23 1")]
	protected int m_iStartingHours;

	[Attribute("0", UIWidgets.Slider, "Starting time of day (minutes)", "0 59 1")]
	protected int m_iStartingMinutes;

	[Attribute("0")]
	protected bool m_bRandomStartingDaytime;
	
	[Attribute("0", desc: "Random time range is superior to random time. When both are set to true, random range will be used.")]
	protected bool m_bRandomStartingDaytimeRange;
	
	[Attribute("8", UIWidgets.Slider, "Starting range of starting time of day \n (hours)", "0 23 1")]
	protected int m_iRangeHoursStart;

	[Attribute("0", UIWidgets.Slider, "Starting range of starting time of day \n (minutes)", "0 59 1")]
	protected int m_iRangeMinutesStart;
	
	[Attribute("8", UIWidgets.Slider, "Ending range of starting time of day \n (hours)", "0 23 1")]
	protected int m_iRangeHoursEnd;

	[Attribute("0", UIWidgets.Slider, "Ending range of starting time of day \n (minutes)", "0 59 1")]
	protected int m_iRangeMinutesEnd;
	
	[Attribute("1", UIWidgets.Slider, "Time acceleration during the day (1 = 100%, 2 = 200% etc)", "0.1 12 0.1")]
	protected float m_fDayTimeAcceleration;

	[Attribute("1", UIWidgets.Slider, "Time acceleration during the night (1 = 100%, 2 = 200% etc)", "0.1 12 0.1")]
	protected float m_fNightTimeAcceleration;

	[Attribute("0")]
	protected bool m_bRandomStartingWeather;
	
	[Attribute("0", desc: "Use predefine sets of weather and time.")]
	protected bool m_bUsePredefineStartingTimeAndWeather;
	
	[Attribute(desc: "List of predefine time and weather settings.")]
	protected ref array<ref SCR_TimeAndWeatherState> m_aStartingWeatherAndTime;

	[Attribute("0", desc: "Weather can change during gameplay")]
	protected bool m_bRandomWeatherChanges;

	[Attribute("0", desc: "Scenario header setting will overwrite these values.")]
	protected bool m_bAllowHeaderSettings;

	const int DAYTIME_CHECK_PERIOD = 60000;	//ms
	const float DEFAULT_DAYTIME_START = 5.0;
	const float DEFAULT_DAYTIME_END = 19.0;
	const int DAY_DURATION = 24 * 60 * 60;

	protected bool m_bDaytimeAcceleration = true;
	protected bool m_bSavedSettingApplied = false;

	protected static SCR_TimeAndWeatherHandlerComponent s_Instance;

	//------------------------------------------------------------------------------------------------
	//! \return
	static SCR_TimeAndWeatherHandlerComponent GetInstance()
	{
		return s_Instance;
	}

	//------------------------------------------------------------------------------------------------
	//! \param[in] hours
	//! \param[in] minutes
	//! \param[in] seconds
	//! \param[in] loadedWeatherState
	//! \param[in] loadDone
	void SetupDaytimeAndWeather(int hours, int minutes, int seconds = 0, string loadedWeatherState = "", bool loadDone = false)
	{
		if (m_bSavedSettingApplied)
			return;

		m_bSavedSettingApplied = loadDone;

		ChimeraWorld world = ChimeraWorld.CastFrom(GetOwner().GetWorld());
		if (!world)
			return;
		
		TimeAndWeatherManagerEntity manager = world.GetTimeAndWeatherManager();
		if (!manager)
			return;

		float sunrise, morning, evening, sunset;

		// Use world-calculated sunrise and sunset values if possible, otherwise use defaults
		if (manager.GetSunriseHour(sunrise))
		{
			manager.GetSunsetHour(sunset);
		}
		else
		{
			sunrise = DEFAULT_DAYTIME_START;
			sunset = DEFAULT_DAYTIME_END;
		}

		if (m_bRandomStartingDaytime && !loadDone && !m_bRandomStartingDaytimeRange)
		{
			// Compile a list of presets based on the sunrise and sunset times of current world if we're randomizing
			morning = sunrise + 0.25;	// Just so it's not still completely dark at the start
			float noon = (sunrise + sunset) * 0.5;
			float afternoon = (noon + sunset) * 0.5;
			evening = sunset - 0.5;
			float night = noon + 12;

			if (night >= 24)
				night -= 24;

			array<float> startingTimes = {morning, noon, afternoon, evening, night};

			// Add weights so evening / night is a bit more rare
			Math.Randomize(-1);
			int index = SCR_ArrayHelper.GetWeightedIndex({25, 25, 25, 15, 10}, Math.RandomFloat01());
			float startingTime;

			if (startingTimes.IsIndexValid(index))
				startingTime = startingTimes[index];
			else
				startingTime = startingTimes.GetRandomElement();

			manager.TimeToHoursMinutesSeconds(startingTime, hours, minutes, seconds);
		}
		
		if (m_bRandomStartingDaytimeRange && !loadDone)
		{			
			if (m_iRangeHoursStart <= m_iRangeHoursEnd)
			{
				hours = Math.RandomInt(m_iRangeHoursStart, m_iRangeHoursEnd);
			}
			else
			{
				hours = Math.RandomInt(m_iRangeHoursStart, m_iRangeHoursEnd + 24) - 24;
			}
			
			if (m_iRangeMinutesStart <= m_iRangeMinutesEnd)
			{
				minutes = Math.RandomInt(m_iRangeMinutesStart, m_iRangeMinutesEnd);
			}
			else
			{
				minutes = Math.RandomInt(m_iRangeHoursStart, m_iRangeHoursEnd + 60) - 60;
			}
		}

		if (m_bRandomStartingWeather && !loadDone)
		{
			array<ref WeatherState> weatherStates = {};
			manager.GetWeatherStatesList(weatherStates);

			if (!weatherStates.IsEmpty())
				manager.ForceWeatherTo(!m_bRandomWeatherChanges, weatherStates.GetRandomElement().GetStateName());
		}
		
		if (m_bUsePredefineStartingTimeAndWeather && !m_aStartingWeatherAndTime.IsEmpty())
		{
			Math.Randomize(-1);
			SCR_TimeAndWeatherState timeAndWEatherState = m_aStartingWeatherAndTime.GetRandomElement();			
			manager.ForceWeatherTo(!m_bRandomWeatherChanges, timeAndWEatherState.GetWeatherPresetName());
			hours = timeAndWEatherState.GetStartingHour();
			minutes = timeAndWEatherState.GetStartingMinutes();
		}

		if (!loadedWeatherState.IsEmpty())
			manager.ForceWeatherTo(!m_bRandomWeatherChanges, loadedWeatherState);

		manager.SetHoursMinutesSeconds(hours, minutes, seconds);

		// Periodically check if the acceleration is correct, based on time of day
		// SetTimeEvent is not usable since it requires changing Periodicity attribute directly in the manager entity in the world layer
		if (m_fDayTimeAcceleration != 1 || m_fNightTimeAcceleration != 1)
		{
			HandleDaytimeAcceleration(true);
			GetGame().GetCallqueue().Remove(HandleDaytimeAcceleration);
			GetGame().GetCallqueue().CallLater(HandleDaytimeAcceleration, DAYTIME_CHECK_PERIOD, true, false);
		}
	}

	//------------------------------------------------------------------------------------------------
	protected void HandleDaytimeAcceleration(bool setup = false)
	{
		ChimeraWorld world = ChimeraWorld.CastFrom(GetOwner().GetWorld());
		if (!world)
			return;
		
		TimeAndWeatherManagerEntity manager = world.GetTimeAndWeatherManager();
		if (!manager)
			return;

		if (manager.IsNightHour(manager.GetTimeOfTheDay()))
		{
			if (m_bDaytimeAcceleration || setup)
			{
				m_bDaytimeAcceleration = false;
				manager.SetDayDuration(DAY_DURATION / m_fNightTimeAcceleration);
			}
		}
		else
		{
			if (!m_bDaytimeAcceleration || setup)
			{
				m_bDaytimeAcceleration = true;
				manager.SetDayDuration(DAY_DURATION / m_fDayTimeAcceleration);
			}
		}
	}

	//------------------------------------------------------------------------------------------------
	override void OnWorldPostProcess(World world)
	{
		super.OnWorldPostProcess(world);

		if (!Replication.IsServer() || !GetGame().InPlayMode())
			return;

		if (s_Instance != this)
		{
			Print("Multiple instances of SCR_TimeAndWeatherHandlerComponent detected.", LogLevel.WARNING);
			return;
		}

		SetupDaytimeAndWeather(m_iStartingHours, m_iStartingMinutes);
	}

	//------------------------------------------------------------------------------------------------
	override void OnPostInit(IEntity owner)
	{
		// Allow only one instance
		if (s_Instance || !GetGame().InPlayMode())
			return;

		// Allow permanent startign daytime & weather for debugging purposes
#ifdef TDM_CLI_SELECTION
		return;
#endif

		s_Instance = this;

		if (!Replication.IsServer())
			return;

		SCR_MissionHeader header = SCR_MissionHeader.Cast(GetGame().GetMissionHeader());

		if (m_bAllowHeaderSettings && header && header.m_bOverrideScenarioTimeAndWeather)
		{
			m_iStartingHours = header.m_iStartingHours;
			m_iStartingMinutes = header.m_iStartingMinutes;
			m_bRandomStartingDaytime = header.m_bRandomStartingDaytime;
			m_fDayTimeAcceleration = header.m_fDayTimeAcceleration;
			m_fNightTimeAcceleration = header.m_fNightTimeAcceleration;
			m_bRandomStartingWeather = header.m_bRandomStartingWeather;
			m_bRandomWeatherChanges = header.m_bRandomWeatherChanges;
		}
	}
}
[BaseContainerProps()]
class SCR_ScenarioFrameworkWeatherCondition : SCR_ScenarioFrameworkActivationConditionBase
{
	[Attribute(defvalue: "0", desc: "Minimal wind speed in meters per second", params: "0 100 0.001", precision: 3, category: "Wind")]
	float m_fMinWindSpeed;

	[Attribute(defvalue: "20", desc: "Maximal wind speed in meters per second", params: "0 100 0.001", precision: 3, category: "Wind")]
	float m_fMaxWindSpeed;

	[Attribute(defvalue: "0", desc: "Minimal rain intensity", params: "0 1 0.001", precision: 3, category: "Rain")]
	float m_fMinRainIntensity;

	[Attribute(defvalue: "1", desc: "Maximal rain intensity", params: "0 1 0.001", precision: 3, category: "Rain")]
	float m_fMaxRainIntensity;

	//------------------------------------------------------------------------------------------------
	override bool Init(IEntity entity)
	{
		// Here you can debug specific Condition instance.
		// This can be also adjusted during runtime via Debug Menu > ScenarioFramework > Condition Inspector
		if (m_bDebug)
			Print("[SCR_ScenarioFrameworkWeatherCondition.Init] debug line (" + __FILE__ + " L" + __LINE__ + ")", LogLevel.WARNING);
		
		ChimeraWorld world = ChimeraWorld.CastFrom(entity.GetWorld());
		if (!world)
			return true;

		TimeAndWeatherManagerEntity manager = world.GetTimeAndWeatherManager();
		if (!manager)
			return true;

		float currentWindSpeed = manager.GetWindSpeed();
		if (currentWindSpeed < m_fMinWindSpeed || currentWindSpeed > m_fMaxWindSpeed)
			return false;

		float currentRainIntensity = manager.GetRainIntensity();
		if (currentRainIntensity < m_fMinRainIntensity || currentRainIntensity > m_fMaxRainIntensity)
			return false;

		return true;
	}
}
/*!
Notification Player
Displays a notification: %1 = PlayerID name
SCR_NotificationData: m_iParam1 = PlayerID
Can be used for: Player (m_iParam1) requests something
Can be used for: Player (m_iParam1) dies (ENotificationSetPositionData = AUTO_SET_POSITION_ONCE)
Can be used for: Player (m_iParam1) pings at position(ENotificationSetPositionData = NEVER_AUTO_SET_POSITION, SCR_NotificationData.SetPosition() to ping location)
*/
[BaseContainerProps(), SCR_BaseContainerCustomTitleEnum(ENotification, "m_NotificationKey")]
class SCR_NotificationWeatherChanged : SCR_NotificationPlayer
{
	override string GetText(SCR_NotificationData data)
	{	
		int playerID, weatherIndex;
		data.GetParams(playerID, weatherIndex);
		
		string playerName;
		data.GetNotificationTextEntries(playerName);
		if (!GetPlayerName(playerID, playerName))
			return string.Empty;
		
		ChimeraWorld world = GetGame().GetWorld();
		TimeAndWeatherManagerEntity weatherManager = world.GetTimeAndWeatherManager();
		if (!weatherManager)
			return string.Empty;
		
		array<ref WeatherState> weatherStates = new array<ref WeatherState>;
		weatherManager.GetWeatherStatesList(weatherStates);
		if (weatherIndex >= weatherStates.Count() )
			return string.Empty;

		data.SetNotificationTextEntries(playerName, weatherStates[weatherIndex].GetLocalizedName());
			
		return super.GetText(data);
	}	
};

[ComponentEditorProps(category: "GameScripted/Misc", description: "")]
class SCR_InitWeatherComponentClass : SCR_BaseGameModeComponentClass
{
}

class SCR_InitWeatherComponent : SCR_BaseGameModeComponent
{
	[Attribute(defvalue: "", desc: "Weather IDs are the same as used in the TimeAndWeatherManager. This sets the weather as soon as the game has been started. This weather will loop and never change automatically. If this is empty then the automated weather system will run instead")]
	protected string m_sInitialStartingWeatherId;
	
	[Attribute(defvalue: "0", desc: "If true it will make sure that the set weather will stay that weather state until the GM changes this")]
	protected bool m_iSetWeatherConstant;
	
	[Attribute(defvalue: "0.8", desc: "Takes float up to 24 (hours) and is used to randomize the inital weather duration. Must be lower then m_initialWeatherDurationMax. Is ignored if weather is constant.", params: "0.1 24")]
	protected float m_initialWeatherDurationMin; 
	
	[Attribute(defvalue: "1.2", desc: "Takes float up to 24 (hours) and is used to randomize the inital weather duration. Must be higher then m_initialWeatherDurationMin. Is ignored if weather is constant.", params: "0.1 24")]
	protected float m_initialWeatherDurationMax; 
	
	//------------------------------------------------------------------------------------------------
	//! Sets initial weather state when server is first loaded. This state will loop and never change automatically
	protected void InitWeatherServer()
	{
		if (!Replication.IsServer())
			return;
		
		if (m_sInitialStartingWeatherId.IsEmpty())
			return;
		
		ChimeraWorld world = ChimeraWorld.CastFrom(GetOwner().GetWorld());
		if (!world) 
		{
			Print("SCR_InitWeatherComponent is not inside a ChimeraWorld", LogLevel.WARNING);
			return;
		}
		
		TimeAndWeatherManagerEntity weatherManager = world.GetTimeAndWeatherManager();
		if (!weatherManager) 
		{
			Print("SCR_InitWeatherComponent could not find TimeAndWeatherManagerEntity", LogLevel.WARNING);
			return;
		}
		
		float weatherDuration = 0;
		if (!m_iSetWeatherConstant)
		{
			if (m_initialWeatherDurationMin > m_initialWeatherDurationMax)
				m_initialWeatherDurationMin = m_initialWeatherDurationMax;
			
			weatherDuration = Math.RandomFloat(m_initialWeatherDurationMin, m_initialWeatherDurationMax);
		}
		
		weatherManager.ForceWeatherTo(m_iSetWeatherConstant, m_sInitialStartingWeatherId, weatherDuration * 0.5, weatherDuration * 0.5);
	}
	
	//------------------------------------------------------------------------------------------------
	override void EOnInit(IEntity owner)
	{
		InitWeatherServer();
	}
	
	//------------------------------------------------------------------------------------------------
	override void OnPostInit(IEntity owner)
	{
		SetEventMask(owner, EntityEvent.INIT);
	}
}
enum SCR_EWeatherStates
{
	CLEAR,
	CLOUDY,
	OVERCAST,
	RAINY,
	NO_CHANGE
}

// Script File 
[BaseContainerProps(), SCR_BaseEditorAttributeCustomTitle()]
class SCR_AutomatedWeatherEditorAttribute : SCR_BaseEditorAttribute
{	
	override SCR_BaseEditorAttributeVar ReadVariable(Managed item, SCR_AttributesManagerEditorComponent manager)
	{
		//If opened in global attributes
		if (!IsGameMode(item)) 
			return null;
		
		GenericEntity ent = GenericEntity.Cast(item);
		ChimeraWorld world = ent.GetWorld();
		TimeAndWeatherManagerEntity weatherManager = world.GetTimeAndWeatherManager();
		if (!weatherManager) 
			return null;
		
		BaseWeatherStateTransitionManager weatherTransitionManager = weatherManager.GetTransitionManager();
		if (!weatherTransitionManager)
			return null;
		
		array<ref WeatherState> weatherStates = new array<ref WeatherState>;
		
		//Get weather states
		weatherManager.GetWeatherStatesList(weatherStates);
		if (weatherStates.IsEmpty()) 
			return null;

		WeatherStateTransitionNode currentStateTransition = weatherTransitionManager.GetCurrentStateTransitionNode();
		
		return SCR_BaseEditorAttributeVar.CreateBool(!currentStateTransition.IsLooping());
	}
	
	override void UpdateInterlinkedVariables(SCR_BaseEditorAttributeVar var, SCR_AttributesManagerEditorComponent manager, bool isInit = false)
	{		
		//Set sub labels
		if (isInit)
			manager.SetAttributeAsSubAttribute(SCR_WeatherInstantEditorAttribute);
		
		manager.SetAttributeEnabled(SCR_WeatherInstantEditorAttribute, var && !var.GetBool());
	}
	
	override void WriteVariable(Managed item, SCR_BaseEditorAttributeVar var, SCR_AttributesManagerEditorComponent manager, int playerID)
	{
		//~ Ignore previews (!item)
		if (!var || !item) 
			return;
		
		GenericEntity ent = GenericEntity.Cast(item);
		ChimeraWorld world = ent.GetWorld();
		TimeAndWeatherManagerEntity weatherManager = world.GetTimeAndWeatherManager();
		if (!weatherManager) 
			return;
		
		BaseWeatherStateTransitionManager weatherTransitionManager = weatherManager.GetTransitionManager();
		if (!weatherTransitionManager)
			return;
		
		if (!manager)
			return;
		
		WeatherStateTransitionNode currentStateTransition = weatherTransitionManager.GetCurrentStateTransitionNode();
		
		bool setAutomatic = var.GetBool();

		//Remove preview if any was set
		if (weatherTransitionManager.IsPreviewingState())
			weatherManager.SetWeatherStatePreview(false);
		
		//~ Set looping false
		if (setAutomatic)
		{
			weatherManager.ForceWeatherTo(!setAutomatic, string.Empty, 0, 0.001, playerID);
		}
		//~ Set looping true
		else 
		{
			float transitionTime = 0;
			
			SCR_BaseEditorAttributeVar transitionVar;
			if (manager.GetAttributeVariable(SCR_WeatherInstantTransitionTimeEditorAttribute, transitionVar))
				transitionTime = transitionVar.GetInt();
			
			weatherManager.ForceWeatherTo(!setAutomatic, string.Empty, transitionTime / 3600, 0.001, playerID);
		}
	}
	
	override void PreviewVariable(bool setPreview, SCR_AttributesManagerEditorComponent manager)
	{
		if (!GetVariable())
			return;
		
		bool SetAutomatic = GetVariable().GetBool();
		
		if (SetAutomatic || !setPreview)
		{
			ChimeraWorld world = GetGame().GetWorld();
			TimeAndWeatherManagerEntity weatherManager = world.GetTimeAndWeatherManager();
			if (!weatherManager) 
				return;
	
			BaseWeatherStateTransitionManager weatherTransitionManager = weatherManager.GetTransitionManager();
			if (!weatherTransitionManager)
				return;
			
			//Remove preview if any was set
			if (weatherTransitionManager.IsPreviewingState())
				weatherManager.SetWeatherStatePreview(false);
		}
		else 
		{
			SCR_BaseEditorAttribute weatherInstantAttribute = manager.GetAttributeRef(SCR_WeatherInstantEditorAttribute);
			if (!weatherInstantAttribute)
				return;
		
			weatherInstantAttribute.PreviewVariable(setPreview, manager);
		}
	}
};
/*
===========================================
Do not modify, this script is generated
===========================================
*/

/*!
\addtogroup World
\{
*/

class LocalWeatherSituation: ScriptAndConfig
{
	proto external float GetGlobalWindDir();
	proto external float GetGlobalWindSpeed();
	proto external vector GetLocalWindSway();
	proto external float GetRainIntensity();
	proto external float GetWetness();
	proto external float GetWaterAccumulation();
	proto external float GetOvercast();
	proto external float GetFog();
}

/*!
\}
*/
/*
===========================================
Do not modify, this script is generated
===========================================
*/

/*!
\addtogroup World
\{
*/

class BaseTimeAndWeatherManagerEntityClass: BaseWeatherManagerEntityClass
{
}

/*!
Manager entity responsible for managing in-game time and weather,
providing the script and gamecode with usable in-game API.
*/
class BaseTimeAndWeatherManagerEntity: BaseWeatherManagerEntity
{
	//Returns true if the hour is inside the nighttime.
	proto external bool IsNightHour(float hour24);
	//Returns true if the hour is inside the daytime.
	proto external bool IsDayHour(float hour24);
	// Defines a callback that should be invoked at the specified time (format should be "HHMMSS" and TimeAndWeatherManager periodicity should be set accordingly)
	proto void SetTimeEvent(string time, Managed inst, func callback, bool delayed = true, bool singleUse = false);
	/*!
	Returns all information about current weather - rain, fog, overcast, wind.
	If swayFrequency and location are set, sway is calculated as well (works as with trees and grass).
	Mind that wetness and water accumulation effects are WIP and they will not be set yet.
	You can use
	ref LocalWeatherSituation weatherSituation = new LocalWeatherSituation();
	to create the object and pass it as an argument.
	*/
	proto external bool TryGetCompleteLocalWeather(LocalWeatherSituation lws, float swayFrequency, vector location);
}

/*!
\}
*/
void SCR_HintManagerComponent_OnHint(SCR_HintUIInfo info, bool isSilent);
typedef func SCR_HintManagerComponent_OnHint;

[ComponentEditorProps(category: "GameScripted/GameMode/Components", description: "")]
class SCR_HintManagerComponentClass : SCR_BaseGameModeComponentClass
{
	[Attribute()]
	protected ref array<ref SCR_HintConditionList> m_aConditionLists;

	//------------------------------------------------------------------------------------------------
	//!
	//! \param[in] owner
	void InitConditionLists(IEntity owner)
	{
		for (int i, count = m_aConditionLists.Count(); i < count; i++)
		{
			m_aConditionLists[i].Init(owner);
		}
	}

	//------------------------------------------------------------------------------------------------
	//!
	//! \param[in] owner
	void ExitConditionLists(IEntity owner)
	{
		for (int i, count = m_aConditionLists.Count(); i < count; i++)
		{
			m_aConditionLists[i].Exit(owner);
		}
	}
}

class SCR_HintManagerComponent : SCR_BaseGameModeComponent
{
	[Attribute("4")]
	protected float m_fDefaultDuration;
	
	[Attribute("1", desc: "Mark the hint as shown only if it was display for this duration (seconds).\nIf the hint duration is shorter, mark it as shown when it's hidden.")]
	protected float m_fPersistentDelay;
	
	[Attribute("0", desc: "When enabled, hints will be shown in this scenario even when they're disabled in game settings.\nUseful for tutorial scenarios.")]
	protected bool m_bIgnoreHintSettings;
	
	protected bool m_bIsShown;
	protected float m_fDurationOverride;
	protected SCR_HintUIInfo m_LatestHint;
	protected BaseContainer m_SettingsContainer;
	protected ref SCR_HintSettings m_Settings;
	protected ref SCR_HintUIInfo m_CustomHint; //--- Strong reference to hint info created in run-time from texts
	protected ref set<EHint> m_aSessionShownHints = new set<EHint>();
	protected ref ScriptInvokerBase<SCR_HintManagerComponent_OnHint> m_OnHintShow = new ScriptInvokerBase<SCR_HintManagerComponent_OnHint>();
	protected ref ScriptInvokerBase<SCR_HintManagerComponent_OnHint> m_OnHintHide = new ScriptInvokerBase<SCR_HintManagerComponent_OnHint>();
	
	////////////////////////////////////////////////////////////////////////////////////////////////////
	//--- Public functions
	////////////////////////////////////////////////////////////////////////////////////////////////////

	//------------------------------------------------------------------------------------------------
	//! Show hint based on existing configuration.
	//! \param[in] info Hint UI info
	//! \param[in] isSilent True to show the hint without any sound effect
	//! \param[in] ignoreShown When true, the hint will be shown even if it was shown previously
	//! \return True if the hint was shown
	bool Show(SCR_HintUIInfo info, bool isSilent = false, bool ignoreShown = false)
	{
		//--- Ignore if hints are disabled in gameplay settings (not for sequence hints, because they're triggered manually)
		if ((!CanShow() || (!ignoreShown && WasShown(info))) && !info.IsInSequence())
			return false;
		
		//--- Ignore if the new hint has lower priority than the current one
		if (m_bIsShown && m_LatestHint)
		{
			if (info.GetPriority() < m_LatestHint.GetPriority())
				return false;
		}
		
		//--- Check if timer is visible, if yes, set the timestamp of start.
		
		if (info.IsTimerVisible())
		{
			info.SetTimeStamp();
		}
		
		//--- Always silent when refreshing the same hint
		isSilent |= m_bIsShown && info == m_LatestHint;
		
		//--- Hide current hint (need to call associated event)
		Hide();
		
		//--- Set new current hint
		m_bIsShown = true;
		m_LatestHint = info;
		
		//--- Call an event for GUI systems which will actually show the hint (no GUI here!)
		m_OnHintShow.Invoke(info, isSilent);
		
		//--- Set duration (only when the value is *not* negative, which means endless hint)
		float duration;
		if (m_fDurationOverride != 0)
			duration = m_fDurationOverride;
		else
			duration = info.GetDuration();
		
		GetGame().GetCallqueue().Remove(Hide);
		if (duration >= 0)
		{
			//--- Use default duration when the value is 0
			if (duration == 0)
				duration = m_fDefaultDuration;
			
			GetGame().GetCallqueue().CallLater(Hide, duration * 1000, false, info);
		}
		
		//--- Mark the hint as shown after a delay (multiple hints may be triggered on the same frame, delay will make sure only the actually shown one will be saved)
		GetGame().GetCallqueue().Remove(SetShown);
		int type = info.GetType();
		if (type > 0)
		{
			//--- Make sure the delay is shorter than duration
			float delay = m_fPersistentDelay;
			if (duration > 0)
				delay = Math.Min(delay, duration);
			
			GetGame().GetCallqueue().CallLater(SetShown, delay * 1000, false, info);
		}
		
		//info.Log("SCR_HintManagerComponent.Show: ");
		return true;
	}

	//------------------------------------------------------------------------------------------------
	//! Show hint made of custom texts.
	//!
	//! *************************************************************************************************
	//! ## WARNING! ##
	//!
	//! Use only for quick debugging.
	//! For legit use, please configure the hint as SCR_UIInfo attribute on your entity/component/config!
	//! That will allow you to set all hint properties, as well as to localize it using LocParserPlugin.
	//!
	//! *************************************************************************************************
	//!
	//! \param[in] description Hint text
	//! \param[in] name Hint title
	//! \param[in] duration For how long should the hint be shown (in seconds)
	//! \param[in] isSilent True to show the hint without any sound effect
	//! \param[in] type Hint type. When defined, the hint will be shown only once and never again.
	//! \return True if the hint was shown
	//!
	bool ShowCustom(string description, string name = string.Empty, float duration = 0, bool isSilent = false, EHint type = EHint.UNDEFINED, EFieldManualEntryId fieldManualEntry = EFieldManualEntryId.NONE, bool isTimerVisible = false)
	{
		m_CustomHint = SCR_HintUIInfo.CreateInfo(description, name, duration, type, fieldManualEntry, isTimerVisible);
		return Show(m_CustomHint, isSilent);
	}

	//------------------------------------------------------------------------------------------------
	//!
	//! \return
	bool ClearHint()
	{
		if(m_LatestHint)
		{
			m_LatestHint = null;
			return true;
		}
		else
			return false;
	}

	//------------------------------------------------------------------------------------------------
	//! Repeat previously shown hint.
	//! \param[in] isSilent
	//! \return True if the hint was shown
	bool Repeat(bool isSilent = false)
	{
		if (m_LatestHint)
			return Show(m_LatestHint, isSilent, true);
		else
			return false;
	}

	//------------------------------------------------------------------------------------------------
	//! Silently refresh currently shown hint.
	//! \return True if the hint was refreshed
	bool Refresh()
	{
		if (m_bIsShown)
			return Show(m_LatestHint, true, true);
		else
			return false;
	}

	//------------------------------------------------------------------------------------------------
	//! Hide currently shown hint.
	//! \param[in] info When defined, clear only this hint. If other hint is shown, do nothing.
	//! \return True if a hint was cleared
	bool Hide(SCR_HintUIInfo info = null)
	{
		//--- Nothing to clear
		if (!m_bIsShown)
			return false;
		
		//--- Check if it's the hint passed in a param
		if (info && info != m_LatestHint)
			return false;
		
		GetGame().GetCallqueue().Remove(Hide);
		
		m_bIsShown = false;
		m_OnHintHide.Invoke(m_LatestHint, false);
		return true;
	}

	//------------------------------------------------------------------------------------------------
	//! Toggle hint. Hide it if it's shown, and open it again if it's hidden.
	void Toggle()
	{
		if (m_Settings && !m_Settings.AreHintsEnabled())
			return;
		
		if (IsShown())
			Hide();
		else
			Repeat();
	}

	//------------------------------------------------------------------------------------------------
	//! Open context to currently shown hint.
	void OpenContext()
	{
		if (!IsShown() || !m_LatestHint || (m_Settings && !m_Settings.AreHintsEnabled()))
			return;
		
		EFieldManualEntryId link = m_LatestHint.GetFieldManualLink();
		if (link != EFieldManualEntryId.NONE)
			SCR_FieldManualUI.Open(link);
	}

	//------------------------------------------------------------------------------------------------
	//! Get the most recent hint.
	//! \return Hint UI info
	SCR_HintUIInfo GetLatestHint()
	{
		return m_LatestHint;
	}

	//------------------------------------------------------------------------------------------------
	//! Get thecurrently shown hint.
	//! \return Hint UI info
	SCR_HintUIInfo GetCurrentHint()
	{
		if (m_bIsShown)
			return m_LatestHint;
		else
			return null;
	}

	//------------------------------------------------------------------------------------------------
	//! Check if a hint is shown at this moment.
	//! \return True when shown
	bool IsShown()
	{
		return m_bIsShown;
	}

	//------------------------------------------------------------------------------------------------
	//! Check if hints are enabled in gameplay settings.
	//! \return True when enabled
	bool CanShow()
	{
		return m_bIgnoreHintSettings || !m_Settings || m_Settings.AreHintsEnabled();
	}

	//------------------------------------------------------------------------------------------------
	//! Check if hint type was shown previously (even in previous game sessions; the information is stored persistently).
	//! \param[in] hint Hint type
	//! \param[in] limit How many times can the hint be shown
	//! \return True when shown
	bool WasShown(EHint hint, int limit = 1)
	{
		return hint > 0 //--- Is type defined (hints without type are never remembered)?
				&& (
					(m_Settings && m_Settings.GetCount(hint) >= limit //--- How many times was the hint shown across instances?
					|| m_aSessionShownHints.Contains(hint)) //--- Was the hint shown in this instance?
				)
				&& !DiagMenu.GetBool(SCR_DebugMenuID.DEBUGUI_HINT_IGNORE_SHOWN); //--- Is debug mode suppressing this check?
	}

	//------------------------------------------------------------------------------------------------
	//! Check if hint info was shown previously (even in previous game sessions; the information is stored persistently).
	//! \return True when shown
	bool WasShown(SCR_HintUIInfo info)
	{
		return info && WasShown(info.GetType(), info.GetShowLimit());
	}

	//------------------------------------------------------------------------------------------------
	//! Override hint duration.
	//! \param[in] duration. When 0, override is reset.
	void SetDurationOverride(float duration)
	{
		m_fDurationOverride = duration;
	}
	//------------------------------------------------------------------------------------------------
	//! Get override of hint duration.
	//! \return Duration. When 0, no override is active.
	float GetDurationOverride()
	{
		return m_fDurationOverride;
	}

	//------------------------------------------------------------------------------------------------
	//! Get the event called when a hint is shown.
	//! \return Script invoker
	ScriptInvokerBase<SCR_HintManagerComponent_OnHint> GetOnHintShow()
	{
		return m_OnHintShow;
	}

	//------------------------------------------------------------------------------------------------
	//! Get the event called when a hint is hidden.
	//! \return Script invoker
	ScriptInvokerBase<SCR_HintManagerComponent_OnHint> GetOnHintHide()
	{
		return m_OnHintHide;
	}
	
	////////////////////////////////////////////////////////////////////////////////////////////////////
	//--- Static functions
	////////////////////////////////////////////////////////////////////////////////////////////////////

	//------------------------------------------------------------------------------------------------
	//! Get instance of the hint manager.
	//! \return Hint manager
	static SCR_HintManagerComponent GetInstance()
	{
		BaseGameMode gameMode = GetGame().GetGameMode();
		if (gameMode)
			return SCR_HintManagerComponent.Cast(gameMode.FindComponent(SCR_HintManagerComponent));
		else
			return null;
	}

	//------------------------------------------------------------------------------------------------
	//! Show hint based on existing configuration.
	//! \param[in] info Hint UI info
	//! \param[in] isSilent True to show the hint without any sound effect
	//! \param[in] ignoreShown When true, the hint will be shown even if it was shown previously
	//! \return True if the hint was shown
	static bool ShowHint(SCR_HintUIInfo info, bool isSilent = false, bool ignoreShown = false)
	{
		SCR_HintManagerComponent hintManager = GetInstance();
		if (hintManager)
			return hintManager.Show(info, isSilent, ignoreShown);
		else
			return false;
	}

	//------------------------------------------------------------------------------------------------
	//! Show hint made of custom texts.
	//!
	//! *************************************************************************************************
	//! ## WARNING! ##
	//!
	//! Use only for quick debugging.
	//! For legit use, please configure the hint as SCR_UIInfo attribute on your entity/component/config!
	//! That will allow you to set all hint properties, as well as to localize it using LocParserPlugin.
	//!
	//! *************************************************************************************************
	//!
	//! \param[in] description Hint text
	//! \param[in] name Hint title
	//! \param[in] duration For how long should the hint be shown (in seconds)
	//! \param[in] isSilent True to show the hint without any sound effect
	//! \return True if the hint was shown
	//!
	static bool ShowCustomHint(string description, string name = string.Empty, float duration = 0, bool isSilent = false, EFieldManualEntryId fieldManualEntry = EFieldManualEntryId.NONE, bool isTimerVisible = false)
	{
		SCR_HintManagerComponent hintManager = GetInstance();
		if (hintManager)
			return hintManager.ShowCustom(description, name, duration, isSilent, EHint.UNDEFINED, fieldManualEntry, isTimerVisible);
		else
			return false;
	}

	//------------------------------------------------------------------------------------------------
	//! Clear the last used hint so it no longer shows.
	static bool ClearLatestHint()
	{
		SCR_HintManagerComponent hintManager = GetInstance();
		if (hintManager)
			return hintManager.ClearHint();
		else
			return false;
	}

	//------------------------------------------------------------------------------------------------
	//! Repeat previously shown hint.
	//! \param[in] isSilent
	//! \return True if the hint was shown
	static bool RepeatHint(bool isSilent = false)
	{
		SCR_HintManagerComponent hintManager = GetInstance();
		if (hintManager)
			return hintManager.Repeat(isSilent);
		else
			return false;
	}

	//------------------------------------------------------------------------------------------------
	//! Clear currently shown hint.
	//! \param[in] info When defined, clear only this hint. If other hint is shown, do nothing.
	//! \return True if a hint was cleared
	static bool HideHint(SCR_HintUIInfo info = null)
	{
		SCR_HintManagerComponent hintManager = GetInstance();
		if (hintManager)
			return hintManager.Hide(info);
		else
			return false;
	}

	//------------------------------------------------------------------------------------------------
	//! Check if a hint is shown at this moment.
	//! \return True when shown
	static bool IsHintShown()
	{
		SCR_HintManagerComponent hintManager = GetInstance();
		if (hintManager)
			return hintManager.IsShown();
		else
			return false;
	}

	//------------------------------------------------------------------------------------------------
	//! Check if hints are enabled in gameplay settings.
	//! \return True when enabled
	static bool CanShowHints()
	{
		SCR_HintManagerComponent hintManager = GetInstance();
		if (hintManager)
			return hintManager.CanShow();
		else
			return false;
	}
	
	////////////////////////////////////////////////////////////////////////////////////////////////////
	//--- Protected functions
	////////////////////////////////////////////////////////////////////////////////////////////////////

	//------------------------------------------------------------------------------------------------
	protected void LoadSettings()
	{
		SCR_HUDManagerComponent hudManager = GetGame().GetHUDManager();
		if (!hudManager)
			return;
		
		BaseContainer interfaceSettings = GetGame().GetGameUserSettings().GetModule(hudManager.GetInterfaceSettingsClass());
		if (!interfaceSettings)
			return;
		
		bool state;
		interfaceSettings.Get("m_bShowHints", state);

		m_SettingsContainer = GetGame().GetGameUserSettings().GetModule("SCR_HintSettings");
		m_Settings.SetHintsEnabled(state);
		m_Settings.LoadShownHints(m_SettingsContainer);
		
		if (m_bIsShown && !m_Settings.AreHintsEnabled())
			Hide();
	}

	//------------------------------------------------------------------------------------------------
	protected void SetShown(SCR_HintUIInfo info)
	{
		if (!info || WasShown(info) || DiagMenu.GetBool(SCR_DebugMenuID.DEBUGUI_HINT_IGNORE_SHOWN))
			return;
		
		EHint type = info.GetType();
		m_aSessionShownHints.Insert(type);
		int count = m_Settings.AddCount(type);
		m_Settings.SaveShownHints(m_SettingsContainer);
		
		Print(string.Format("Hint %1 = %2 saved persistently, count = %3.", typename.EnumToString(EHint, type), type, count), LogLevel.VERBOSE);
	}
	
	////////////////////////////////////////////////////////////////////////////////////////////////////
	//--- Default functions
	////////////////////////////////////////////////////////////////////////////////////////////////////

	//------------------------------------------------------------------------------------------------
	override void OnPostInit(IEntity owner)
	{
		if (System.IsConsoleApp())
			return;
		
		DiagMenu.RegisterBool(SCR_DebugMenuID.DEBUGUI_HINT_IGNORE_SHOWN, "", "Ignore hint persistency", "UI");
		
		if (SCR_Global.IsEditMode(owner))
			return;
		
		//--- Call only for the owner, not server (disabled, called before ownership is transferred)
		//RplComponent rplComponent = RplComponent.Cast(owner.FindComponent(RplComponent));
		//if (rplComponent && !rplComponent.IsOwner())
		//	return;
		
		SCR_HintManagerComponentClass componentPrefab = SCR_HintManagerComponentClass.Cast(GetComponentData(owner));
		componentPrefab.InitConditionLists(owner);
		
		m_Settings = new SCR_HintSettings();
		
		// Call later so the HUDManager gets Initialized first and doesn't return null	
		GetGame().GetCallqueue().Call(LoadSettings);	
		GetGame().OnUserSettingsChangedInvoker().Insert(LoadSettings);
		
		GetGame().GetInputManager().AddActionListener("HintToggle", EActionTrigger.DOWN, Toggle);
		GetGame().GetInputManager().AddActionListener("HintContext", EActionTrigger.DOWN, OpenContext);
	}

	//------------------------------------------------------------------------------------------------
	override void OnDelete(IEntity owner)
	{		
		if (System.IsConsoleApp())
			return;
		
		DiagMenu.Unregister(SCR_DebugMenuID.DEBUGUI_HINT_IGNORE_SHOWN);
		
		SCR_HintManagerComponentClass componentPrefab = SCR_HintManagerComponentClass.Cast(GetComponentData(owner));
		componentPrefab.ExitConditionLists(owner);
		
		GetGame().OnUserSettingsChangedInvoker().Remove(LoadSettings);
		
		GetGame().GetInputManager().RemoveActionListener("HintToggle", EActionTrigger.DOWN, Toggle);
		GetGame().GetInputManager().RemoveActionListener("HintContext", EActionTrigger.DOWN, OpenContext);
	}
}
