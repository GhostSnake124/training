//////////////////// MUZZLE ATTACHMENTS PER CALIBER ////////////////////

class AttachmentMuzzlePistolClass {}
AttachmentMuzzlePistolClass AttachmentMuzzlePistolSource;
class AttachmentMuzzlePistol : AttachmentMuzzle
{
};

class AttachmentMuzzle9_18Class {}

AttachmentMuzzle9_18Class AttachmentMuzzle9_18Source;
class AttachmentMuzzle9_18 : AttachmentMuzzlePistol
{
};

class AttachmentMuzzle9_19Class {}

AttachmentMuzzle9_19Class AttachmentMuzzle9_19Source;
class AttachmentMuzzle9_19 : AttachmentMuzzlePistol
{
};

class AttachmentMuzzle45Class {}

AttachmentMuzzle45Class AttachmentMuzzle45Source;
class AttachmentMuzzle45 : AttachmentMuzzlePistol
{
};

class AttachmentMuzzle556_45Class {}

AttachmentMuzzle556_45Class AttachmentMuzzle556_45Source;
class AttachmentMuzzle556_45 : AttachmentMuzzle
{
};

class AttachmentMuzzle545_39Class {}

AttachmentMuzzle545_39Class AttachmentMuzzle545_39Source;
class AttachmentMuzzle545_39 : AttachmentMuzzle
{
};

class AttachmentMuzzle762_54Class {}

AttachmentMuzzle762_54Class AttachmentMuzzle762_54Source;
class AttachmentMuzzle762_54 : AttachmentMuzzle
{
};

class AttachmentMuzzle762_51Class {}

AttachmentMuzzle762_51Class AttachmentMuzzle762_51Source;
class AttachmentMuzzle762_51 : AttachmentMuzzle
{
};

class AttachmentMuzzle762_39Class {}

AttachmentMuzzle762_39Class AttachmentMuzzle762_39Source;
class AttachmentMuzzle762_39 : AttachmentMuzzle
{
};

class AttachmentMuzzle308Class {}

AttachmentMuzzle308Class AttachmentMuzzle308Source;
class AttachmentMuzzle308 : AttachmentMuzzle
{
};

class AttachmentSuppressorClass {}

AttachmentSuppressorClass AttachmentSuppressorSource;
class AttachmentSuppressor : AttachmentMuzzle
{
};

class AttachmentSuppressorMark3Class {}

AttachmentSuppressorMark3Class AttachmentSuppressorMark3Source;
class AttachmentSuppressorMark3 : AttachmentMuzzle556_45
{
};

class AttachmentSuppressorPBS4Class {}

AttachmentSuppressorPBS4Class AttachmentSuppressorPBS4Source;
class AttachmentSuppressorPBS4 : AttachmentMuzzle545_39
{
};

class AttachmentFlashHiderClass {}

AttachmentFlashHiderClass AttachmentFlashHiderSource;
class AttachmentFlashHider : AttachmentMuzzle
{
};

class AttachmentFlashHiderA2Class {}

AttachmentFlashHiderA2Class AttachmentFlashHiderA2Source;
class AttachmentFlashHiderA2 : AttachmentMuzzle556_45
{
};

class AttachmentFlashHider6P26Class {}

AttachmentFlashHider6P26Class AttachmentFlashHider6P26Source;
class AttachmentFlashHider6P26 : AttachmentMuzzle545_39
{
};

class AttachmentFlashHider6P20Class {}

AttachmentFlashHider6P20Class AttachmentFlashHider6P20Source;
class AttachmentFlashHider6P20 : AttachmentMuzzle545_39
{
};

/*
===========================================
Do not modify, this script is generated
===========================================
*/

/*!
\addtogroup Weapon
\{
*/

class BaseMuzzleComponent: GameComponent
{
	// Returns true if muzzle is suppressed
	proto external bool IsMuzzleSuppressed();
	proto external EMuzzleType GetMuzzleType();
	proto external int GetNextFireModeIndex();
	proto external int GetFireModesCount();
	proto external int GetFireModeIndex();
	proto external int GetFireModesList(out notnull array<BaseFireMode> outFireModes);
	proto external BaseFireMode GetCurrentFireMode();
	// Barrels
	proto external int GetBarrelsCount();
	proto external int GetCurrentBarrelIndex();
	proto external bool IsBarrelChambered(int barrelIndex);
	proto external bool IsCurrentBarrelChambered();
	proto external bool IsChamberingPossible();
	//Deletes the bullet from selected chamber as well as Invoking OnAmmoCountChanged
	proto external bool ClearChamber(int barrelIndex);
	// Disposable
	proto external bool IsDisposable();
	// Magazines
	proto external int GetAmmoCount();
	proto external int GetMaxAmmoCount();
	proto external BaseMagazineComponent GetMagazine();
	proto external BaseMagazineWell GetMagazineWell();
	// Returns ResourceName of default magazine if the muzzle takes magazines or ResourceName of default projectile if muzzle takes projectiles.
	proto external ResourceName GetDefaultMagazineOrProjectileName();
	// UI Info
	proto external UIInfo GetUIInfo();
	// Open Bolt Info
	proto external bool GetOpenBoltState();
	// Get gamepad effect context name
	proto external owned string GetGamepadEffectContext();
	proto external void SetGamepadEffectsEnabled(bool val);
	proto external WeaponGamepadEffectsManagerComponent GetGamepadEffectsManager();
	proto external IEntity GetOwner();
}

/*!
\}
*/

/*
===========================================
Do not modify, this script is generated
===========================================
*/

/*!
\addtogroup Weapon
\{
*/

class BaseMuzzleComponentClass: GameComponentClass
{
}

/*!
\}
*/
/*
===========================================
Do not modify, this script is generated
===========================================
*/

/*!
\addtogroup Weapon
\{
*/

enum EMuzzleType
{
	MT_BaseMuzzle,
	MT_RPGMuzzle,
	MT_UGLMuzzle,
}

/*!
\}
*/
/*
===========================================
Do not modify, this script is generated
===========================================
*/

/*!
\addtogroup Weapon
\{
*/

class MortarMuzzleComponentClass: MuzzleInMagComponentClass
{
}

class MortarMuzzleComponent: MuzzleInMagComponent
{
	proto external void LoadMortar(IEntity shell);

	// callbacks

	event void OnPostInit(IEntity owner);
	event void EOnInit(IEntity owner);
}

/*!
\}
*/
/*
===========================================
Do not modify, this script is generated
===========================================
*/

/*!
\addtogroup Weapon
\{
*/

class MuzzleComponentClass: BaseMuzzleComponentClass
{
}

class MuzzleComponent: BaseMuzzleComponent
{
	proto external BaseContainer GetDefaultMagazinePrefab();
}

/*!
\}
*/
/*
===========================================
Do not modify, this script is generated
===========================================
*/

/*!
\addtogroup Effects
\{
*/

class MuzzleEffectComponentClass: BaseEffectComponentClass
{
}

class MuzzleEffectComponent: BaseEffectComponent
{
	proto external bool IsOverridenByAttachment();

	// callbacks

	/*!
	Called during EOnInit.
	\param owner Entity this component is attached to.
	*/
	event void OnInit(IEntity owner);
	event void OnFired(IEntity effectEntity, BaseMuzzleComponent muzzle, IEntity projectileEntity);
}

/*!
\}
*/
/*
===========================================
Do not modify, this script is generated
===========================================
*/

/*!
\addtogroup Weapon
\{
*/

class MuzzleInMagComponentClass: BaseMuzzleComponentClass
{
}

class MuzzleInMagComponent: BaseMuzzleComponent
{
}

/*!
\}
*/
//! Forward declaration of UIInfo
//! Serves as a container of data to be displayed on player UI
class MuzzleUIInfo : UIInfo
{
	// Show caliber indicator in weapon UI
	[Attribute("false", UIWidgets.CheckBox, "Show caliber indicator in weapon UI.")]
	protected bool m_bShowCaliber;	

	bool ShowCaliber()
	{
		return m_bShowCaliber;
	}	
	
	//! Firemode texture - full auto
	[Attribute("", "auto", "Caliber identification, e.g. 7.62Ã—39mm")]
	protected string m_sCaliber;		

	string GetCaliber()
	{
		return m_sCaliber;
	}		
		
	// Magazine icon behaviour in weapon UI
	[Attribute("true", UIWidgets.CheckBox, "Show firemode indicator.")]
	protected bool m_bShowFiremode;	

	bool ShowFiremodeIcon()
	{
		return m_bShowFiremode;
	}		

			
	//! Firemode imageset with foreground icons
	[Attribute("{CDA6C73DFD789999}UI/Imagesets/WeaponInfo/WeaponInfo.imageset", UIWidgets.ResourceNamePicker, "Imageset with most of weapon info textures", "imageset")]
	protected ResourceName m_sFiremodeIconImageset;

	ResourceName GetFiremodeIconImageset()
	{
		return m_sFiremodeIconImageset;
	}	
	
	//! Firemode imageset with glow icons
	[Attribute("{C6D15495F684E841}UI/Imagesets/WeaponInfo/WeaponInfo_Glow.imageset", UIWidgets.ResourceNamePicker, "Imageset with most of weapon info textures", "imageset")]
	protected ResourceName m_sFiremodeGlowImageset;	

	ResourceName GetFiremodeGlowImageset()
	{
		return m_sFiremodeGlowImageset;
	}	

	//! Firemode texture - single shot
	[Attribute("firemode-rifle-single", "auto", "Firemode indicator - single shot")]
	protected string m_sFiremodeSingle;

	//! Firemode texture - burst
	[Attribute("firemode-rifle-burst3", "auto", "Firemode indicator - burst")]
	protected string m_sFiremodeBurst;	

	//! Firemode texture - full auto
	[Attribute("firemode-rifle-auto", "auto", "Firemode indicator - full auto")]
	protected string m_sFiremodeAuto;	
			
	//! Firemode texture - safety
	[Attribute("firemode-safety", "auto", "Firemode indicator - safety", "edds")]
	protected string m_sFiremodeSafety;
	
	string GetFiremodeIconName(EWeaponFiremodeType firemode)
	{
		string icon = "";
		
		switch (firemode)
		{
			case EWeaponFiremodeType.Semiauto:
				icon = m_sFiremodeSingle;
				break;
			
			case EWeaponFiremodeType.Burst:
				icon = m_sFiremodeBurst;
				break;

			case EWeaponFiremodeType.Auto:
				icon = m_sFiremodeAuto;
				break;		
										
			case EWeaponFiremodeType.Safety:
				icon = 	m_sFiremodeSafety;
				break;
			
			default:
				icon = m_sFiremodeSingle;
				break;
		}		
		
		return icon;
	}
	
	[Attribute("", UIWidgets.Object)]
	ref SCR_MagazineIndicatorConfiguration m_MagIndicator;
};

class SCR_AIGetMuzzleMagazineWell: AITaskScripted
{
	protected const static string WEAPON_COMPONENT_PORT = "WeaponComponent";	
	protected const static string MUZZLE_ID_PORT = "MuzzleId";
	
	static const string MAGAZINE_WELL_PORT = "MagazineWell";
	static const string MAGAZINE_WELL_TYPE_PORT = "MagazineWellType";
	
	//------------------------------------------------------------------------------------------------
	override bool VisibleInPalette() {return true;}
	
	//------------------------------------------------------------------------------------------------
	override ENodeResult EOnTaskSimulate(AIAgent owner, float dt)
	{
		BaseWeaponComponent weaponComp;
		int muzzleId;
		
		if (!GetVariableIn(WEAPON_COMPONENT_PORT, weaponComp))
			return ENodeResult.FAIL;
		if (!GetVariableIn(MUZZLE_ID_PORT, muzzleId))
			return ENodeResult.FAIL;
		
		if (!weaponComp)
			return ENodeResult.FAIL;
		
		array<BaseMuzzleComponent> muzzles = {};
		weaponComp.GetMuzzlesList(muzzles);
		
		if (muzzleId < 0 || muzzleId >= muzzles.Count())
			return ENodeResult.FAIL;
		
		BaseMuzzleComponent muzzleComp = muzzles[muzzleId];
		
		if (!muzzleComp)
			return ENodeResult.FAIL;
		
		BaseMagazineWell magWell = muzzleComp.GetMagazineWell();
		if (!magWell)
			return ENodeResult.FAIL;
		
		typename magWellType = magWell.Type();
		SetVariableOut(MAGAZINE_WELL_PORT, magWell);
		SetVariableOut(MAGAZINE_WELL_TYPE_PORT, magWellType);
		return ENodeResult.SUCCESS;
	}
	
	//------------------------------------------------------------------------------------------------
	protected static ref TStringArray s_aVarsOut = { MAGAZINE_WELL_PORT, MAGAZINE_WELL_TYPE_PORT };
	override TStringArray GetVariablesOut() { return s_aVarsOut; }
	
	protected static ref TStringArray s_aVarsIn = { WEAPON_COMPONENT_PORT, MUZZLE_ID_PORT };
	override TStringArray GetVariablesIn() { return s_aVarsIn; }
	

	//------------------------------------------------------------------------------------------------
	override string GetOnHoverDescription() 
	{ 
		return "Returns magazine well and its type of a specific weapon muzzle";	
	};
};
class SCR_AISwitchMuzzle : SCR_AIWeaponHandlingBase
{
	protected static const string PORT_MUZZLE_ID = "MuzzleId";
	
	//--------------------------------------------------------------------------------------------
	override ENodeResult EOnTaskSimulate(AIAgent owner, float dt)
	{
		if (!m_WeaponMgrComp || !m_ControlComp || !m_InventoryMgr)
			return ENodeResult.FAIL;
		
		int newMuzzleId = -1;
		GetVariableIn(PORT_MUZZLE_ID, newMuzzleId);
		if (newMuzzleId == -1)
		{
			#ifdef AI_DEBUG
			AddDebugMessage("Skipped muzzle switch, no muzzle was provided");
			#endif
			return ENodeResult.SUCCESS;
		}
		
		BaseCompartmentSlot compartmentSlot = m_CompartmentAccessComp.GetCompartment();
			
		// Return success if done
		// Ignore if we are in compartment. There are no turret weapons where we can choose a muzzle.
		// And there is no API to switch muzzle in a turret anyway.
		int currentMuzzleId = SCR_AIWeaponHandling.GetCurrentMuzzleId(m_WeaponMgrComp);
		if (currentMuzzleId == newMuzzleId || compartmentSlot)
		{
			#ifdef AI_DEBUG
			AddDebugMessage("Muzzle switch completed");
			#endif
			return ENodeResult.SUCCESS;
		}
			
		#ifdef AI_DEBUG
		AddDebugMessage(string.Format("Start Muzzle Switch: %1", newMuzzleId));
		#endif
		SCR_AIWeaponHandling.StartMuzzleSwitch(m_ControlComp, newMuzzleId);
		
		return ENodeResult.RUNNING;
	}
	
	//--------------------------------------------------------------------------------------------
	protected static ref TStringArray s_aVarsIn = {PORT_MUZZLE_ID};
	override TStringArray GetVariablesIn() { return s_aVarsIn; }
	
	override bool VisibleInPalette() { return true; }
}

//------------------------------------------------------------------------------------------------
[BaseContainerProps()]
class SCR_HasMultipleMuzzles : SCR_AvailableActionCondition
{
	ref array<BaseMuzzleComponent> muzzles = {};

	//------------------------------------------------------------------------------------------------
	override bool IsAvailable(SCR_AvailableActionsConditionData data)
	{
		BaseWeaponComponent weapon = data.GetCurrentWeapon();
		if (!weapon)
			return false;

		int count = weapon.GetMuzzlesList(muzzles);
		return GetReturnResult(count > 1);
	}
};
class SCR_MuzzleEffectComponentClass : MuzzleEffectComponentClass
{
};

class SCR_MuzzleEffectComponent : MuzzleEffectComponent
{
	
};

[ComponentEditorProps(category: "GameScripted/Misc", description: "")]
class SCR_MuzzleInMagComponentClass : MuzzleInMagComponentClass
{
}

class SCR_MuzzleInMagComponent : MuzzleInMagComponent
{
	[Attribute("1", desc: "Some launchers are one off and can never be reloaded. This bool makes sure that the resupply functionality will never try to add magazines/projectiles of the weapon to the inventory on resupply.")]
	protected bool m_bCanBeReloaded;

	//------------------------------------------------------------------------------------------------
	//! If muzzle can be reloaded with projectiles
	//! \return True if can be reloaded
	bool CanBeReloaded()
	{
		return m_bCanBeReloaded;
	}
}
//------------------------------------------------------------------------------------------------
[BaseContainerProps()]
class SCR_WeaponMuzzleChamberedCondition : SCR_AvailableActionCondition
{
	//------------------------------------------------------------------------------------------------
	//! Return true if current weapon has bullet in chamber
	override bool IsAvailable(SCR_AvailableActionsConditionData data)
	{
		if (!data)
			return false;

		BaseMuzzleComponent muzzle = data.GetCurrentMuzzle();
		if (!muzzle)
			return false;

		bool result = muzzle.IsCurrentBarrelChambered();

		return GetReturnResult(result);
	}
};
[BaseContainerProps()]
class SCR_TutorialLogic_SW : SCR_BaseTutorialCourseLogic
{
	ref ScriptInvoker m_OnAmmoDepletedChanged, m_OnAmmoAddedChanged;
	ref array <SCR_PlaceableInventoryItemComponent> m_aPlacedCharges;
	ref array <IEntity> m_aDestructables;
	
	int m_iMisses_M72;
	bool m_bRPGVoiceLinePlayed;
	protected vector m_vCheckOffset = "0 0.5 0";
	
	//------------------------------------------------------------------------------------------------
	override void OnCourseStart()
	{
		SCR_TutorialGamemodeComponent tutorialComponent = SCR_TutorialGamemodeComponent.Cast(GetGame().GetGameMode().FindComponent(SCR_TutorialGamemodeComponent));
		if (!tutorialComponent)
			return;
		
		//respawn TARGETS
		array <IEntity> targets = {};
		targets.Insert(tutorialComponent.SpawnAsset("TARGET_1", "{94803C603CF5651B}Prefabs/Structures/Military/Training/TargetVehicles/TargetBTR_flank.et"));
		targets.Insert(tutorialComponent.SpawnAsset("TARGET_2", "{E1EDC3CC5421436F}Prefabs/Structures/Military/Training/TargetVehicles/TargetBMP_flank.et"));
		targets.Insert(tutorialComponent.SpawnAsset("TARGET_3", "{74EF3F7B90C793AF}Prefabs/Structures/Military/Training/TargetVehicles/TargetUral_flank.et"));
		targets.Insert(tutorialComponent.SpawnAsset("TARGET_4", "{DFD494A96CA95D0B}Prefabs/Structures/Military/Training/TargetVehicles/TargetBTR_front.et"));
		
		SCR_DestructionMultiPhaseComponent destructionComp;
		foreach (IEntity target : targets)
		{
			destructionComp = SCR_DestructionMultiPhaseComponent.Cast(target.GetChildren().FindComponent(SCR_DestructionMultiPhaseComponent));
			if (!destructionComp)
				continue;
			
			destructionComp.EnableDamageHandling(false);
		}
		
		IEntity playerEnt = tutorialComponent.GetPlayer();
		if (playerEnt)
		{
			EventHandlerManagerComponent eventHandlerManager = EventHandlerManagerComponent.Cast(playerEnt.FindComponent(EventHandlerManagerComponent));
			if (eventHandlerManager)
			{
				eventHandlerManager.RegisterScriptHandler("OnProjectileShot", playerEnt, OnPlayerWeaponFired);
				eventHandlerManager.RegisterScriptHandler("OnAmmoCountChanged", playerEnt, OnPlayerAmmoChangeCallback);
			}
		}
		
		if (!m_OnAmmoDepletedChanged)
			m_OnAmmoDepletedChanged = new ScriptInvoker;
		
		if (!m_OnAmmoAddedChanged)
			m_OnAmmoAddedChanged = new ScriptInvoker;
		
		// SETUP Range trigger
		SCR_BaseTriggerEntity rangeTrigger = SCR_BaseTriggerEntity.Cast(GetGame().GetWorld().FindEntityByName("SW_TRIGGER"));
		if (rangeTrigger)
		{
			rangeTrigger.EnablePeriodicQueries(true);
			rangeTrigger.GetOnActivate().Insert(OnCharacterInRange);
			rangeTrigger.SetUpdateRate(1);
		}
		
		// Register destructables for charge setting
		RegisterDestructables();
	}
	
	//------------------------------------------------------------------------------------------------
	protected void RegisterDestructables()
	{
		IEntity ent = GetGame().GetWorld().FindEntityByName("DESTRUCTABLE_OBSTACLE");
		if (!ent)
			return;
		
		SCR_DestructionMultiPhaseComponent destruction;
		ent = ent.GetChildren();
		while (ent)
		{
			destruction = SCR_DestructionMultiPhaseComponent.Cast(ent.FindComponent(SCR_DestructionMultiPhaseComponent));
			if (destruction)
				destruction.EnableDamageHandling(false);
			
			if (ent.FindComponent(DynamicPhysicsObstacleComponent))
			{
				if (!m_aDestructables)
					m_aDestructables = {};
								
				m_aDestructables.Insert(ent);
			}
			
			ent = ent.GetSibling();
		}
	}
	
	//------------------------------------------------------------------------------------------------
	IEntity GetAttachedTo(SCR_PlaceableInventoryItemComponent charge)
	{	
		if (!m_aDestructables)
			return null;
		
		IEntity owner = charge.GetOwner();
		IEntity parent = owner.GetParent();
		IEntity mainParent = SCR_EntityHelper.GetMainParent(owner, true);
		if (mainParent && mainParent.IsInherited(ChimeraCharacter))
			return null;
		
		foreach (IEntity destructable : m_aDestructables)
		{
			if (parent == destructable)
				return destructable;
			
			if (vector.Distance(owner.GetOrigin(), destructable.GetOrigin() + m_vCheckOffset) <= 1.5)
				return destructable;
		}
		
		return null;
	}
	
	//------------------------------------------------------------------------------------------------
	void CheckPlacedCharges()
	{	
		if (!m_aPlacedCharges)
			m_aPlacedCharges = {};
		
		SCR_TutorialGamemodeComponent tutorial = SCR_TutorialGamemodeComponent.GetInstance();
		if (!tutorial)
			return;
		
		if (IsBarricadeDestroyed())
		{
			SCR_HintManagerComponent.HideHint();
			SCR_HintManagerComponent.ClearLatestHint();
			
			tutorial.SetStage("SW_END");
			GetGame().GetCallqueue().Remove(CheckPlacedCharges);
			return;
		}
		
		SCR_BaseTutorialStage stage = tutorial.GetCurrentStage();
		
		IEntity attachedTo;
		for (int i = m_aPlacedCharges.Count()-1; i >= 0; i--)
		{	
			if (!m_aPlacedCharges[i])
			{
				m_aPlacedCharges.Remove(i);
				continue;
			}
			
			attachedTo = GetAttachedTo(m_aPlacedCharges[i]);
			if (attachedTo)
				continue;
			
			m_aPlacedCharges.Remove(i);
		}
		
		if (m_aPlacedCharges.Count() >= m_aDestructables.Count())
		{
			if (stage && stage.Type() == SCR_Tutorial_SW_PLACE_CHARGES)
				stage.FinishStage();
			
			return;
		}
		
		if (stage.IsInherited(SCR_Tutorial_SW_PLACE_CHARGES))
		{
			foreach (IEntity destructable : m_aDestructables)
			{
				if (!destructable)
					continue;
				
				attachedTo = null;
				foreach (SCR_PlaceableInventoryItemComponent charge : m_aPlacedCharges)
				{
					attachedTo = GetAttachedTo(charge);
					
					if (attachedTo == destructable)
						break;
					
					attachedTo = null;
				}
				
				if (!attachedTo)
					stage.RegisterWaypoint(destructable, "", "CUSTOM");
			}
		}
		else
		{
			tutorial.InsertStage("PLACE_CHARGES", tutorial.GetActiveStageIndex());
			tutorial.SetStage("PLACE_CHARGES");
		}
	}
	
	//------------------------------------------------------------------------------------------------
	protected void OnCharacterInRange(IEntity char)
	{
		SCR_TutorialGamemodeComponent tutorialComponent = SCR_TutorialGamemodeComponent.Cast(GetGame().GetGameMode().FindComponent(SCR_TutorialGamemodeComponent));
		if (!tutorialComponent)
			return;
		
		tutorialComponent.InsertStage("PlayerInRange", tutorialComponent.GetActiveStageIndex());
		tutorialComponent.SetStage(tutorialComponent.GetStageIndexByName("PlayerInRange"));
	}

	//------------------------------------------------------------------------------------------------
	//TODO: Clean this up, as it is quite dirty
	protected void OnPlayerWeaponFired(int playerID, BaseWeaponComponent weapon, IEntity entity)
	{	
		if (!weapon || weapon.GetWeaponType() != EWeaponType.WT_ROCKETLAUNCHER)
			return;
		
		if (weapon.GetCurrentMuzzle().GetAmmoCount() == 0)
			m_OnAmmoDepletedChanged.Invoke();
	}
	
	//------------------------------------------------------------------------------------------------
	protected void OnPlayerAmmoChangeCallback(BaseWeaponComponent weapon, BaseMuzzleComponent muzzle, BaseMagazineComponent magazine, int ammoCount, bool isBarrelChambered)
	{	
		//TODO> Check for M72 and RPG
		if (!weapon || !weapon.IsReloadPossible())
			return;
		
		if (m_OnAmmoAddedChanged && ammoCount != 0)
			m_OnAmmoAddedChanged.Invoke();
	}
	
	//------------------------------------------------------------------------------------------------
	bool IsBarricadeDestroyed()
	{
		if (!m_aDestructables)
			return true;
		
		for (int i = m_aDestructables.Count()-1; i >= 0; i--)
		{
			if (!m_aDestructables[i])
				m_aDestructables.Remove(i);
		}
		
		return m_aDestructables.IsEmpty();
	}
	
	//------------------------------------------------------------------------------------------------
	override void OnCourseEnd()
	{
		GetGame().GetCallqueue().Remove(CheckPlacedCharges);
		m_aPlacedCharges = null;
		m_aDestructables = null;
		m_bRPGVoiceLinePlayed = false;
		
		SCR_TutorialGamemodeComponent tutorialComponent = SCR_TutorialGamemodeComponent.Cast(GetGame().GetGameMode().FindComponent(SCR_TutorialGamemodeComponent));
		if (!tutorialComponent)
			return;
		
		tutorialComponent.EnableArsenal("SW_ARSENAL_GRENADES", false);
		tutorialComponent.EnableArsenal("SW_ARSENAL_USSR", false);
		tutorialComponent.EnableArsenal("SW_ARSENAL_M72", false);
		tutorialComponent.EnableArsenal("SW_ARSENAL_AMMO", false);
		tutorialComponent.EnableArsenal("SW_ARSENAL_EXPLOSIVES", false);
		
		IEntity playerEnt = tutorialComponent.GetPlayer();
		if (playerEnt)
		{
			EventHandlerManagerComponent eventHandlerManager = EventHandlerManagerComponent.Cast(playerEnt.FindComponent(EventHandlerManagerComponent));
			if (eventHandlerManager)
				eventHandlerManager.RemoveScriptHandler("OnAmmoCountChanged", playerEnt, OnPlayerAmmoChangeCallback);
		}
		
		m_OnAmmoDepletedChanged = null;
		m_OnAmmoAddedChanged = null;
		
		// SETUP Range trigger
		SCR_BaseTriggerEntity rangeTrigger = SCR_BaseTriggerEntity.Cast(GetGame().GetWorld().FindEntityByName("SW_TRIGGER"));
		if (!rangeTrigger)
			return;
		
		rangeTrigger.EnablePeriodicQueries(false);
		rangeTrigger.GetOnActivate().Clear();
	}
}

[BaseContainerProps()]
class SCR_TutorialLogic_SW : SCR_BaseTutorialCourseLogic
{
	ref ScriptInvoker m_OnAmmoDepletedChanged, m_OnAmmoAddedChanged;
	ref array <SCR_PlaceableInventoryItemComponent> m_aPlacedCharges;
	ref array <IEntity> m_aDestructables;
	
	int m_iMisses_M72;
	bool m_bRPGVoiceLinePlayed;
	protected vector m_vCheckOffset = "0 0.5 0";
	
	//------------------------------------------------------------------------------------------------
	override void OnCourseStart()
	{
		SCR_TutorialGamemodeComponent tutorialComponent = SCR_TutorialGamemodeComponent.Cast(GetGame().GetGameMode().FindComponent(SCR_TutorialGamemodeComponent));
		if (!tutorialComponent)
			return;
		
		//respawn TARGETS
		array <IEntity> targets = {};
		targets.Insert(tutorialComponent.SpawnAsset("TARGET_1", "{94803C603CF5651B}Prefabs/Structures/Military/Training/TargetVehicles/TargetBTR_flank.et"));
		targets.Insert(tutorialComponent.SpawnAsset("TARGET_2", "{E1EDC3CC5421436F}Prefabs/Structures/Military/Training/TargetVehicles/TargetBMP_flank.et"));
		targets.Insert(tutorialComponent.SpawnAsset("TARGET_3", "{74EF3F7B90C793AF}Prefabs/Structures/Military/Training/TargetVehicles/TargetUral_flank.et"));
		targets.Insert(tutorialComponent.SpawnAsset("TARGET_4", "{DFD494A96CA95D0B}Prefabs/Structures/Military/Training/TargetVehicles/TargetBTR_front.et"));
		
		SCR_DestructionMultiPhaseComponent destructionComp;
		foreach (IEntity target : targets)
		{
			destructionComp = SCR_DestructionMultiPhaseComponent.Cast(target.GetChildren().FindComponent(SCR_DestructionMultiPhaseComponent));
			if (!destructionComp)
				continue;
			
			destructionComp.EnableDamageHandling(false);
		}
		
		IEntity playerEnt = tutorialComponent.GetPlayer();
		if (playerEnt)
		{
			EventHandlerManagerComponent eventHandlerManager = EventHandlerManagerComponent.Cast(playerEnt.FindComponent(EventHandlerManagerComponent));
			if (eventHandlerManager)
			{
				eventHandlerManager.RegisterScriptHandler("OnProjectileShot", playerEnt, OnPlayerWeaponFired);
				eventHandlerManager.RegisterScriptHandler("OnAmmoCountChanged", playerEnt, OnPlayerAmmoChangeCallback);
			}
		}
		
		if (!m_OnAmmoDepletedChanged)
			m_OnAmmoDepletedChanged = new ScriptInvoker;
		
		if (!m_OnAmmoAddedChanged)
			m_OnAmmoAddedChanged = new ScriptInvoker;
		
		// SETUP Range trigger
		SCR_BaseTriggerEntity rangeTrigger = SCR_BaseTriggerEntity.Cast(GetGame().GetWorld().FindEntityByName("SW_TRIGGER"));
		if (rangeTrigger)
		{
			rangeTrigger.EnablePeriodicQueries(true);
			rangeTrigger.GetOnActivate().Insert(OnCharacterInRange);
			rangeTrigger.SetUpdateRate(1);
		}
		
		// Register destructables for charge setting
		RegisterDestructables();
	}
	
	//------------------------------------------------------------------------------------------------
	protected void RegisterDestructables()
	{
		IEntity ent = GetGame().GetWorld().FindEntityByName("DESTRUCTABLE_OBSTACLE");
		if (!ent)
			return;
		
		SCR_DestructionMultiPhaseComponent destruction;
		ent = ent.GetChildren();
		while (ent)
		{
			destruction = SCR_DestructionMultiPhaseComponent.Cast(ent.FindComponent(SCR_DestructionMultiPhaseComponent));
			if (destruction)
				destruction.EnableDamageHandling(false);
			
			if (ent.FindComponent(DynamicPhysicsObstacleComponent))
			{
				if (!m_aDestructables)
					m_aDestructables = {};
								
				m_aDestructables.Insert(ent);
			}
			
			ent = ent.GetSibling();
		}
	}
	
	//------------------------------------------------------------------------------------------------
	IEntity GetAttachedTo(SCR_PlaceableInventoryItemComponent charge)
	{	
		if (!m_aDestructables)
			return null;
		
		IEntity owner = charge.GetOwner();
		IEntity parent = owner.GetParent();
		IEntity mainParent = SCR_EntityHelper.GetMainParent(owner, true);
		if (mainParent && mainParent.IsInherited(ChimeraCharacter))
			return null;
		
		foreach (IEntity destructable : m_aDestructables)
		{
			if (parent == destructable)
				return destructable;
			
			if (vector.Distance(owner.GetOrigin(), destructable.GetOrigin() + m_vCheckOffset) <= 1.5)
				return destructable;
		}
		
		return null;
	}
	
	//------------------------------------------------------------------------------------------------
	void CheckPlacedCharges()
	{	
		if (!m_aPlacedCharges)
			m_aPlacedCharges = {};
		
		SCR_TutorialGamemodeComponent tutorial = SCR_TutorialGamemodeComponent.GetInstance();
		if (!tutorial)
			return;
		
		if (IsBarricadeDestroyed())
		{
			SCR_HintManagerComponent.HideHint();
			SCR_HintManagerComponent.ClearLatestHint();
			
			tutorial.SetStage("SW_END");
			GetGame().GetCallqueue().Remove(CheckPlacedCharges);
			return;
		}
		
		SCR_BaseTutorialStage stage = tutorial.GetCurrentStage();
		
		IEntity attachedTo;
		for (int i = m_aPlacedCharges.Count()-1; i >= 0; i--)
		{	
			if (!m_aPlacedCharges[i])
			{
				m_aPlacedCharges.Remove(i);
				continue;
			}
			
			attachedTo = GetAttachedTo(m_aPlacedCharges[i]);
			if (attachedTo)
				continue;
			
			m_aPlacedCharges.Remove(i);
		}
		
		if (m_aPlacedCharges.Count() >= m_aDestructables.Count())
		{
			if (stage && stage.Type() == SCR_Tutorial_SW_PLACE_CHARGES)
				stage.FinishStage();
			
			return;
		}
		
		if (stage.IsInherited(SCR_Tutorial_SW_PLACE_CHARGES))
		{
			foreach (IEntity destructable : m_aDestructables)
			{
				if (!destructable)
					continue;
				
				attachedTo = null;
				foreach (SCR_PlaceableInventoryItemComponent charge : m_aPlacedCharges)
				{
					attachedTo = GetAttachedTo(charge);
					
					if (attachedTo == destructable)
						break;
					
					attachedTo = null;
				}
				
				if (!attachedTo)
					stage.RegisterWaypoint(destructable, "", "CUSTOM");
			}
		}
		else
		{
			tutorial.InsertStage("PLACE_CHARGES", tutorial.GetActiveStageIndex());
			tutorial.SetStage("PLACE_CHARGES");
		}
	}
	
	//------------------------------------------------------------------------------------------------
	protected void OnCharacterInRange(IEntity char)
	{
		SCR_TutorialGamemodeComponent tutorialComponent = SCR_TutorialGamemodeComponent.Cast(GetGame().GetGameMode().FindComponent(SCR_TutorialGamemodeComponent));
		if (!tutorialComponent)
			return;
		
		tutorialComponent.InsertStage("PlayerInRange", tutorialComponent.GetActiveStageIndex());
		tutorialComponent.SetStage(tutorialComponent.GetStageIndexByName("PlayerInRange"));
	}

	//------------------------------------------------------------------------------------------------
	//TODO: Clean this up, as it is quite dirty
	protected void OnPlayerWeaponFired(int playerID, BaseWeaponComponent weapon, IEntity entity)
	{	
		if (!weapon || weapon.GetWeaponType() != EWeaponType.WT_ROCKETLAUNCHER)
			return;
		
		if (weapon.GetCurrentMuzzle().GetAmmoCount() == 0)
			m_OnAmmoDepletedChanged.Invoke();
	}
	
	//------------------------------------------------------------------------------------------------
	protected void OnPlayerAmmoChangeCallback(BaseWeaponComponent weapon, BaseMuzzleComponent muzzle, BaseMagazineComponent magazine, int ammoCount, bool isBarrelChambered)
	{	
		//TODO> Check for M72 and RPG
		if (!weapon || !weapon.IsReloadPossible())
			return;
		
		if (m_OnAmmoAddedChanged && ammoCount != 0)
			m_OnAmmoAddedChanged.Invoke();
	}
	
	//------------------------------------------------------------------------------------------------
	bool IsBarricadeDestroyed()
	{
		if (!m_aDestructables)
			return true;
		
		for (int i = m_aDestructables.Count()-1; i >= 0; i--)
		{
			if (!m_aDestructables[i])
				m_aDestructables.Remove(i);
		}
		
		return m_aDestructables.IsEmpty();
	}
	
	//------------------------------------------------------------------------------------------------
	override void OnCourseEnd()
	{
		GetGame().GetCallqueue().Remove(CheckPlacedCharges);
		m_aPlacedCharges = null;
		m_aDestructables = null;
		m_bRPGVoiceLinePlayed = false;
		
		SCR_TutorialGamemodeComponent tutorialComponent = SCR_TutorialGamemodeComponent.Cast(GetGame().GetGameMode().FindComponent(SCR_TutorialGamemodeComponent));
		if (!tutorialComponent)
			return;
		
		tutorialComponent.EnableArsenal("SW_ARSENAL_GRENADES", false);
		tutorialComponent.EnableArsenal("SW_ARSENAL_USSR", false);
		tutorialComponent.EnableArsenal("SW_ARSENAL_M72", false);
		tutorialComponent.EnableArsenal("SW_ARSENAL_AMMO", false);
		tutorialComponent.EnableArsenal("SW_ARSENAL_EXPLOSIVES", false);
		
		IEntity playerEnt = tutorialComponent.GetPlayer();
		if (playerEnt)
		{
			EventHandlerManagerComponent eventHandlerManager = EventHandlerManagerComponent.Cast(playerEnt.FindComponent(EventHandlerManagerComponent));
			if (eventHandlerManager)
				eventHandlerManager.RemoveScriptHandler("OnAmmoCountChanged", playerEnt, OnPlayerAmmoChangeCallback);
		}
		
		m_OnAmmoDepletedChanged = null;
		m_OnAmmoAddedChanged = null;
		
		// SETUP Range trigger
		SCR_BaseTriggerEntity rangeTrigger = SCR_BaseTriggerEntity.Cast(GetGame().GetWorld().FindEntityByName("SW_TRIGGER"));
		if (!rangeTrigger)
			return;
		
		rangeTrigger.EnablePeriodicQueries(false);
		rangeTrigger.GetOnActivate().Clear();
	}
}

/*
===========================================
Do not modify, this script is generated
===========================================
*/

/*!
\addtogroup Effects
\{
*/

class MuzzleEffectComponentClass: BaseEffectComponentClass
{
}

class MuzzleEffectComponent: BaseEffectComponent
{
	proto external bool IsOverridenByAttachment();

	// callbacks

	/*!
	Called during EOnInit.
	\param owner Entity this component is attached to.
	*/
	event void OnInit(IEntity owner);
	event void OnFired(IEntity effectEntity, BaseMuzzleComponent muzzle, IEntity projectileEntity);
}

/*!
\}
*/
[BaseContainerProps()]
class SCR_DataCollectorShootingModule : SCR_DataCollectorModule
{
	//TODO: Remove this map
	protected ref map<int, IEntity> m_mTrackedPossibleShooters = new map<int, IEntity>();

	//------------------------------------------------------------------------------------------------
	protected override void AddInvokers(IEntity player)
	{
		super.AddInvokers(player);
		if (!player)
			return;

		SCR_CompartmentAccessComponent compartmentAccessComponent = SCR_CompartmentAccessComponent.Cast(player.FindComponent(SCR_CompartmentAccessComponent));

		if (!compartmentAccessComponent)
			return;

		compartmentAccessComponent.GetOnCompartmentEntered().Insert(OnCompartmentEntered);
		compartmentAccessComponent.GetOnCompartmentLeft().Insert(OnCompartmentLeft);

		EventHandlerManagerComponent eventHandlerManager = EventHandlerManagerComponent.Cast(player.FindComponent(EventHandlerManagerComponent));
		if (!eventHandlerManager)
			return;

		eventHandlerManager.RegisterScriptHandler("OnProjectileShot", this, OnWeaponFired);
		eventHandlerManager.RegisterScriptHandler("OnGrenadeThrown", this, OnGrenadeThrown);
	}

	//------------------------------------------------------------------------------------------------
	protected void OnWeaponFired(int playerID, BaseWeaponComponent weapon, IEntity entity)
	{
		SCR_PlayerData playerData = GetGame().GetDataCollector().GetPlayerData(playerID);

		//In the future we will use Weapon.GetWeaponType() and Weapon.GetWeaponSubtype() to determine the weapon shot and add it to the player's profile
		//For now, simply count a shot
		playerData.AddStat(SCR_EDataStats.SHOTS, 1);
	}

	//------------------------------------------------------------------------------------------------
	protected void OnGrenadeThrown(int playerID, BaseWeaponComponent weapon, IEntity entity)
	{
		if (!weapon)
			return;

		SCR_PlayerData playerData = GetGame().GetDataCollector().GetPlayerData(playerID);

		//Not counting smoke grenade 'cause it deals no damage. TO DO: Count it as a different specialization operation
		if (weapon.GetWeaponType() == EWeaponType.WT_SMOKEGRENADE)
			return;

		playerData.AddStat(SCR_EDataStats.GRENADES_THROWN, 1);
	}

	//------------------------------------------------------------------------------------------------
	protected override void RemoveInvokers(IEntity player)
	{
		super.RemoveInvokers(player);
		if (!player)
			return;

		SCR_CompartmentAccessComponent compartmentAccessComponent = SCR_CompartmentAccessComponent.Cast(player.FindComponent(SCR_CompartmentAccessComponent));

		if (!compartmentAccessComponent)
			return;

		compartmentAccessComponent.GetOnCompartmentEntered().Remove(OnCompartmentEntered);
		compartmentAccessComponent.GetOnCompartmentLeft().Remove(OnCompartmentLeft);

		EventHandlerManagerComponent eventHandlerManager = EventHandlerManagerComponent.Cast(player.FindComponent(EventHandlerManagerComponent));
		if (!eventHandlerManager)
			return;

		eventHandlerManager.RemoveScriptHandler("OnProjectileShot", this, OnWeaponFired);
		eventHandlerManager.RemoveScriptHandler("OnGrenadeThrown", this, OnGrenadeThrown);
	}

	//Players who enter a vehicle do not need to be tracked as possible shooters, unless using a turret
	//------------------------------------------------------------------------------------------------
	protected void OnCompartmentEntered(IEntity targetEntity, BaseCompartmentManagerComponent manager, int mgrID, int slotID, bool move)
	{
		BaseCompartmentSlot compartment = manager.FindCompartment(slotID, mgrID);

		//Turrets can shoot
		if (!compartment || !compartment.GetOccupant() || compartment.GetType() == ECompartmentType.TURRET)
			return;

		PlayerManager playerManager = GetGame().GetPlayerManager();

		int playerID = playerManager.GetPlayerIdFromControlledEntity(compartment.GetOccupant());

		m_mTrackedPossibleShooters.Remove(playerID);
	}

	//Players who leave a vehicle can be shooters
	//------------------------------------------------------------------------------------------------
	protected void OnCompartmentLeft(IEntity targetEntity, BaseCompartmentManagerComponent manager, int mgrID, int slotID, bool move)
	{
		BaseCompartmentSlot compartment = manager.FindCompartment(slotID, mgrID);
		if (!compartment)
			return;

		if (!compartment.GetOccupant())
			return;

		PlayerManager playerManager = GetGame().GetPlayerManager();

		int playerID = playerManager.GetPlayerIdFromControlledEntity(compartment.GetOccupant());
		if (playerID == 0) // Non-player character
			return;

		m_mTrackedPossibleShooters.Insert(playerID, compartment.GetOccupant());
	}

	//------------------------------------------------------------------------------------------------
	override void OnPlayerDisconnected(int playerID, IEntity controlledEntity = null)
	{
		controlledEntity = m_mTrackedPossibleShooters.Get(playerID);
		super.OnPlayerDisconnected(playerID, controlledEntity);

		m_mTrackedPossibleShooters.Remove(playerID);
	}

	//------------------------------------------------------------------------------------------------
	override void OnPlayerSpawned(int playerID, IEntity controlledEntity)
	{
		super.OnPlayerSpawned(playerID, controlledEntity);
		m_mTrackedPossibleShooters.Insert(playerID, controlledEntity);
	}

#ifdef ENABLE_DIAG
	//------------------------------------------------------------------------------------------------
	override void OnControlledEntityChanged(IEntity from, IEntity to)
	{
		super.OnControlledEntityChanged(from, to);

		if (to)
		{
			int playerID = GetGame().GetPlayerManager().GetPlayerIdFromControlledEntity(to);
			m_mTrackedPossibleShooters.Insert(playerID, to);
		}
		else if (from)
		{
			int playerID = GetGame().GetPlayerManager().GetPlayerIdFromControlledEntity(from);
			m_mTrackedPossibleShooters.Remove(playerID);
		}
	}
#endif

	override void OnAIKilled(IEntity AIEntity, IEntity killerEntity, notnull Instigator instigator, notnull SCR_InstigatorContextData instigatorContextData)
	{
		super.OnAIKilled(AIEntity, killerEntity, instigator, instigatorContextData);
		
		//This method adds a kill no matter the mean by which the AI was killed.
		//The name of the module is a little bit misleading		
		if (instigator.GetInstigatorType() != InstigatorType.INSTIGATOR_PLAYER)
			return;
		
		//~ Not a player kill so ignore (Like suicide)
		if (!instigatorContextData.HasAnyVictimKillerRelation(SCR_ECharacterDeathStatusRelations.KILLED_BY_ENEMY_PLAYER | SCR_ECharacterDeathStatusRelations.KILLED_BY_FRIENDLY_PLAYER))
			return;
		
		int killerId = instigator.GetInstigatorPlayerID();

		SCR_PlayerData killerData = GetGame().GetDataCollector().GetPlayerData(killerId);
		if (!killerData)
			return;
		
		//~ Add an AI kill or friendly kill stats
		if (instigatorContextData.HasAnyVictimKillerRelation(SCR_ECharacterDeathStatusRelations.KILLED_BY_ENEMY_PLAYER))
		{
			killerData.AddStat(SCR_EDataStats.AI_KILLS);
			return;
		}
		else
		{
			//~ Friendly kills do not count for admins, GMs and possessed AI by GM
			SCR_ECharacterControlType killerControlType = instigatorContextData.GetKillerCharacterControlType();
			if (killerControlType == SCR_ECharacterControlType.UNLIMITED_EDITOR || killerControlType == SCR_ECharacterControlType.POSSESSED_AI)
				return;
			
			//~ Friendly kills only counted if friendly fire is punished else the player can rank up a massive crime score
			SCR_AdditionalGameModeSettingsComponent additionalGameModeSettings = SCR_AdditionalGameModeSettingsComponent.GetInstance();
			if (additionalGameModeSettings && !additionalGameModeSettings.IsTeamKillingPunished())
				return;
				
			killerData.AddStat(SCR_EDataStats.FRIENDLY_AI_KILLS);
			return;
		}	
	}

	//------------------------------------------------------------------------------------------------
	override void OnPlayerKilled(int playerId, IEntity playerEntity, IEntity killerEntity, notnull Instigator instigator, notnull SCR_InstigatorContextData instigatorContextData)
	{
		super.OnPlayerKilled(playerId, playerEntity, killerEntity, instigator, instigatorContextData);
		m_mTrackedPossibleShooters.Remove(playerId);

		SCR_PlayerData playerData = GetGame().GetDataCollector().GetPlayerData(playerId);
		playerData.AddStat(SCR_EDataStats.DEATHS);
		
		//~ Also tracks Possessed AI as if player kill as the data is not seen by player
		if (instigator.GetInstigatorType() != InstigatorType.INSTIGATOR_PLAYER)
			return;
		
		//~ Not a player kill so ignore (Like suicide)
		if (!instigatorContextData.HasAnyVictimKillerRelation(SCR_ECharacterDeathStatusRelations.KILLED_BY_ENEMY_PLAYER | SCR_ECharacterDeathStatusRelations.KILLED_BY_FRIENDLY_PLAYER))
			return;
		
		int killerId = instigator.GetInstigatorPlayerID();
		
		SCR_PlayerData killerData = GetGame().GetDataCollector().GetPlayerData(killerId);
		if (!killerData)
			return;
		
		SCR_ECharacterControlType victimControlType = instigatorContextData.GetVictimCharacterControlType();
		
		//~ Possessed AI count towards AI kills
		if (victimControlType == SCR_ECharacterControlType.POSSESSED_AI)
		{
			//~ Add an AI kill or friendly kill stats
			if (instigatorContextData.HasAnyVictimKillerRelation(SCR_ECharacterDeathStatusRelations.KILLED_BY_ENEMY_PLAYER))
			{
				killerData.AddStat(SCR_EDataStats.AI_KILLS);
				return;
			}
			else
			{
				//~ Friendly kills do not count for admins, GMs and possessed AI by GM
				SCR_ECharacterControlType killerControlType = instigatorContextData.GetKillerCharacterControlType();
				if (killerControlType == SCR_ECharacterControlType.UNLIMITED_EDITOR || killerControlType == SCR_ECharacterControlType.POSSESSED_AI)
					return;
				
				//~ Friendly kills only counted if friendly fire is punished else the player can rank up a massive crime score
				SCR_AdditionalGameModeSettingsComponent additionalGameModeSettings = SCR_AdditionalGameModeSettingsComponent.GetInstance();
				if (additionalGameModeSettings && !additionalGameModeSettings.IsTeamKillingPunished())
					return;
				
				killerData.AddStat(SCR_EDataStats.FRIENDLY_AI_KILLS);
				return;
			}
		}
		
		//~ Add kill or friendly kill stats
		if (instigatorContextData.HasAnyVictimKillerRelation(SCR_ECharacterDeathStatusRelations.KILLED_BY_ENEMY_PLAYER))
		{
			killerData.AddStat(SCR_EDataStats.KILLS);
			return;
		}
		else
		{
			//~ Friendly kills do not count for admins, GMs and possessed AI by GM
			SCR_ECharacterControlType killerControlType = instigatorContextData.GetKillerCharacterControlType();
			if (killerControlType == SCR_ECharacterControlType.UNLIMITED_EDITOR || killerControlType == SCR_ECharacterControlType.POSSESSED_AI)
				return;
			
			//~ Friendly kills only counted if friendly fire is punished else the player can rank up a massive crime score
			SCR_AdditionalGameModeSettingsComponent additionalGameModeSettings = SCR_AdditionalGameModeSettingsComponent.GetInstance();
			if (additionalGameModeSettings && !additionalGameModeSettings.IsTeamKillingPunished())
				return;
			
			killerData.AddStat(SCR_EDataStats.FRIENDLY_KILLS);
			return;
		}
			
	}

	//------------------------------------------------------------------------------------------------
	override void Update(float timeTick)
	{
		//If there's no data collector, do nothing
		if (!GetGame().GetDataCollector())
			return;

		m_fTimeSinceUpdate += timeTick;

		if (m_fTimeSinceUpdate < m_fUpdatePeriod)
			return;

		SCR_PlayerData playerData;
		int playerId;

		for (int i = m_mTrackedPossibleShooters.Count() - 1; i >= 0; i--)
		{

			playerId = m_mTrackedPossibleShooters.GetKey(i);
			playerData = GetGame().GetDataCollector().GetPlayerData(playerId);

			//DEBUG display
#ifdef ENABLE_DIAG
			if (m_StatsVisualization)
			{
				m_StatsVisualization.Get(SCR_EShootingModuleStats.DEATHS).SetText((playerData.GetStat(SCR_EDataStats.DEATHS) - playerData.GetStat(SCR_EDataStats.DEATHS, false)).ToString());
				m_StatsVisualization.Get(SCR_EShootingModuleStats.PLAYERKILLS).SetText((playerData.GetStat(SCR_EDataStats.KILLS) - playerData.GetStat(SCR_EDataStats.KILLS, false)).ToString());
				m_StatsVisualization.Get(SCR_EShootingModuleStats.AIKILLS).SetText((playerData.GetStat(SCR_EDataStats.AI_KILLS) - playerData.GetStat(SCR_EDataStats.AI_KILLS, false)).ToString());
				m_StatsVisualization.Get(SCR_EShootingModuleStats.FRIENDLYPLAYERKILLS).SetText((playerData.GetStat(SCR_EDataStats.FRIENDLY_KILLS) - playerData.GetStat(SCR_EDataStats.FRIENDLY_KILLS, false)).ToString());
				m_StatsVisualization.Get(SCR_EShootingModuleStats.FRIENDLYAIKILLS).SetText((playerData.GetStat(SCR_EDataStats.FRIENDLY_AI_KILLS) - playerData.GetStat(SCR_EDataStats.FRIENDLY_AI_KILLS, false)).ToString());
				m_StatsVisualization.Get(SCR_EShootingModuleStats.BULLETSSHOT).SetText((playerData.GetStat(SCR_EDataStats.SHOTS) - playerData.GetStat(SCR_EDataStats.SHOTS, false)).ToString());
				m_StatsVisualization.Get(SCR_EShootingModuleStats.GRENADESTHROWN).SetText((playerData.GetStat(SCR_EDataStats.GRENADES_THROWN) - playerData.GetStat(SCR_EDataStats.GRENADES_THROWN, false)).ToString());
			}
#endif
		}
		m_fTimeSinceUpdate = 0;
	}

#ifdef ENABLE_DIAG
	//------------------------------------------------------------------------------------------------
	override void CreateVisualization()
	{
		super.CreateVisualization();
		if (!m_StatsVisualization)
			return;

		CreateEntry("Deaths: ", 0, SCR_EShootingModuleStats.DEATHS);
		CreateEntry("Player Kills: ", 0, SCR_EShootingModuleStats.PLAYERKILLS);
		CreateEntry("AI Kills: ", 0, SCR_EShootingModuleStats.AIKILLS);
		CreateEntry("Friendly Player Kills: ", 0, SCR_EShootingModuleStats.FRIENDLYPLAYERKILLS);
		CreateEntry("Friendly AI Kills: ", 0, SCR_EShootingModuleStats.FRIENDLYAIKILLS);
		CreateEntry("Bullets Shot: ", 0, SCR_EShootingModuleStats.BULLETSSHOT);
		CreateEntry("Grenades Thrown: ", 0, SCR_EShootingModuleStats.GRENADESTHROWN);
	}
#endif
};

#ifdef ENABLE_DIAG
enum SCR_EShootingModuleStats
{
	DEATHS,
	PLAYERKILLS,
	AIKILLS,
	FRIENDLYPLAYERKILLS,
	FRIENDLYAIKILLS,
	BULLETSSHOT,
	GRENADESTHROWN
};
#endif

void SCR_HintManagerComponent_OnHint(SCR_HintUIInfo info, bool isSilent);
typedef func SCR_HintManagerComponent_OnHint;

[ComponentEditorProps(category: "GameScripted/GameMode/Components", description: "")]
class SCR_HintManagerComponentClass : SCR_BaseGameModeComponentClass
{
	[Attribute()]
	protected ref array<ref SCR_HintConditionList> m_aConditionLists;

	//------------------------------------------------------------------------------------------------
	//!
	//! \param[in] owner
	void InitConditionLists(IEntity owner)
	{
		for (int i, count = m_aConditionLists.Count(); i < count; i++)
		{
			m_aConditionLists[i].Init(owner);
		}
	}

	//------------------------------------------------------------------------------------------------
	//!
	//! \param[in] owner
	void ExitConditionLists(IEntity owner)
	{
		for (int i, count = m_aConditionLists.Count(); i < count; i++)
		{
			m_aConditionLists[i].Exit(owner);
		}
	}
}

class SCR_HintManagerComponent : SCR_BaseGameModeComponent
{
	[Attribute("4")]
	protected float m_fDefaultDuration;
	
	[Attribute("1", desc: "Mark the hint as shown only if it was display for this duration (seconds).\nIf the hint duration is shorter, mark it as shown when it's hidden.")]
	protected float m_fPersistentDelay;
	
	[Attribute("0", desc: "When enabled, hints will be shown in this scenario even when they're disabled in game settings.\nUseful for tutorial scenarios.")]
	protected bool m_bIgnoreHintSettings;
	
	protected bool m_bIsShown;
	protected float m_fDurationOverride;
	protected SCR_HintUIInfo m_LatestHint;
	protected BaseContainer m_SettingsContainer;
	protected ref SCR_HintSettings m_Settings;
	protected ref SCR_HintUIInfo m_CustomHint; //--- Strong reference to hint info created in run-time from texts
	protected ref set<EHint> m_aSessionShownHints = new set<EHint>();
	protected ref ScriptInvokerBase<SCR_HintManagerComponent_OnHint> m_OnHintShow = new ScriptInvokerBase<SCR_HintManagerComponent_OnHint>();
	protected ref ScriptInvokerBase<SCR_HintManagerComponent_OnHint> m_OnHintHide = new ScriptInvokerBase<SCR_HintManagerComponent_OnHint>();
	
	////////////////////////////////////////////////////////////////////////////////////////////////////
	//--- Public functions
	////////////////////////////////////////////////////////////////////////////////////////////////////

	//------------------------------------------------------------------------------------------------
	//! Show hint based on existing configuration.
	//! \param[in] info Hint UI info
	//! \param[in] isSilent True to show the hint without any sound effect
	//! \param[in] ignoreShown When true, the hint will be shown even if it was shown previously
	//! \return True if the hint was shown
	bool Show(SCR_HintUIInfo info, bool isSilent = false, bool ignoreShown = false)
	{
		//--- Ignore if hints are disabled in gameplay settings (not for sequence hints, because they're triggered manually)
		if ((!CanShow() || (!ignoreShown && WasShown(info))) && !info.IsInSequence())
			return false;
		
		//--- Ignore if the new hint has lower priority than the current one
		if (m_bIsShown && m_LatestHint)
		{
			if (info.GetPriority() < m_LatestHint.GetPriority())
				return false;
		}
		
		//--- Check if timer is visible, if yes, set the timestamp of start.
		
		if (info.IsTimerVisible())
		{
			info.SetTimeStamp();
		}
		
		//--- Always silent when refreshing the same hint
		isSilent |= m_bIsShown && info == m_LatestHint;
		
		//--- Hide current hint (need to call associated event)
		Hide();
		
		//--- Set new current hint
		m_bIsShown = true;
		m_LatestHint = info;
		
		//--- Call an event for GUI systems which will actually show the hint (no GUI here!)
		m_OnHintShow.Invoke(info, isSilent);
		
		//--- Set duration (only when the value is *not* negative, which means endless hint)
		float duration;
		if (m_fDurationOverride != 0)
			duration = m_fDurationOverride;
		else
			duration = info.GetDuration();
		
		GetGame().GetCallqueue().Remove(Hide);
		if (duration >= 0)
		{
			//--- Use default duration when the value is 0
			if (duration == 0)
				duration = m_fDefaultDuration;
			
			GetGame().GetCallqueue().CallLater(Hide, duration * 1000, false, info);
		}
		
		//--- Mark the hint as shown after a delay (multiple hints may be triggered on the same frame, delay will make sure only the actually shown one will be saved)
		GetGame().GetCallqueue().Remove(SetShown);
		int type = info.GetType();
		if (type > 0)
		{
			//--- Make sure the delay is shorter than duration
			float delay = m_fPersistentDelay;
			if (duration > 0)
				delay = Math.Min(delay, duration);
			
			GetGame().GetCallqueue().CallLater(SetShown, delay * 1000, false, info);
		}
		
		//info.Log("SCR_HintManagerComponent.Show: ");
		return true;
	}

	//------------------------------------------------------------------------------------------------
	//! Show hint made of custom texts.
	//!
	//! *************************************************************************************************
	//! ## WARNING! ##
	//!
	//! Use only for quick debugging.
	//! For legit use, please configure the hint as SCR_UIInfo attribute on your entity/component/config!
	//! That will allow you to set all hint properties, as well as to localize it using LocParserPlugin.
	//!
	//! *************************************************************************************************
	//!
	//! \param[in] description Hint text
	//! \param[in] name Hint title
	//! \param[in] duration For how long should the hint be shown (in seconds)
	//! \param[in] isSilent True to show the hint without any sound effect
	//! \param[in] type Hint type. When defined, the hint will be shown only once and never again.
	//! \return True if the hint was shown
	//!
	bool ShowCustom(string description, string name = string.Empty, float duration = 0, bool isSilent = false, EHint type = EHint.UNDEFINED, EFieldManualEntryId fieldManualEntry = EFieldManualEntryId.NONE, bool isTimerVisible = false)
	{
		m_CustomHint = SCR_HintUIInfo.CreateInfo(description, name, duration, type, fieldManualEntry, isTimerVisible);
		return Show(m_CustomHint, isSilent);
	}

	//------------------------------------------------------------------------------------------------
	//!
	//! \return
	bool ClearHint()
	{
		if(m_LatestHint)
		{
			m_LatestHint = null;
			return true;
		}
		else
			return false;
	}

	//------------------------------------------------------------------------------------------------
	//! Repeat previously shown hint.
	//! \param[in] isSilent
	//! \return True if the hint was shown
	bool Repeat(bool isSilent = false)
	{
		if (m_LatestHint)
			return Show(m_LatestHint, isSilent, true);
		else
			return false;
	}

	//------------------------------------------------------------------------------------------------
	//! Silently refresh currently shown hint.
	//! \return True if the hint was refreshed
	bool Refresh()
	{
		if (m_bIsShown)
			return Show(m_LatestHint, true, true);
		else
			return false;
	}

	//------------------------------------------------------------------------------------------------
	//! Hide currently shown hint.
	//! \param[in] info When defined, clear only this hint. If other hint is shown, do nothing.
	//! \return True if a hint was cleared
	bool Hide(SCR_HintUIInfo info = null)
	{
		//--- Nothing to clear
		if (!m_bIsShown)
			return false;
		
		//--- Check if it's the hint passed in a param
		if (info && info != m_LatestHint)
			return false;
		
		GetGame().GetCallqueue().Remove(Hide);
		
		m_bIsShown = false;
		m_OnHintHide.Invoke(m_LatestHint, false);
		return true;
	}

	//------------------------------------------------------------------------------------------------
	//! Toggle hint. Hide it if it's shown, and open it again if it's hidden.
	void Toggle()
	{
		if (m_Settings && !m_Settings.AreHintsEnabled())
			return;
		
		if (IsShown())
			Hide();
		else
			Repeat();
	}

	//------------------------------------------------------------------------------------------------
	//! Open context to currently shown hint.
	void OpenContext()
	{
		if (!IsShown() || !m_LatestHint || (m_Settings && !m_Settings.AreHintsEnabled()))
			return;
		
		EFieldManualEntryId link = m_LatestHint.GetFieldManualLink();
		if (link != EFieldManualEntryId.NONE)
			SCR_FieldManualUI.Open(link);
	}

	//------------------------------------------------------------------------------------------------
	//! Get the most recent hint.
	//! \return Hint UI info
	SCR_HintUIInfo GetLatestHint()
	{
		return m_LatestHint;
	}

	//------------------------------------------------------------------------------------------------
	//! Get thecurrently shown hint.
	//! \return Hint UI info
	SCR_HintUIInfo GetCurrentHint()
	{
		if (m_bIsShown)
			return m_LatestHint;
		else
			return null;
	}

	//------------------------------------------------------------------------------------------------
	//! Check if a hint is shown at this moment.
	//! \return True when shown
	bool IsShown()
	{
		return m_bIsShown;
	}

	//------------------------------------------------------------------------------------------------
	//! Check if hints are enabled in gameplay settings.
	//! \return True when enabled
	bool CanShow()
	{
		return m_bIgnoreHintSettings || !m_Settings || m_Settings.AreHintsEnabled();
	}

	//------------------------------------------------------------------------------------------------
	//! Check if hint type was shown previously (even in previous game sessions; the information is stored persistently).
	//! \param[in] hint Hint type
	//! \param[in] limit How many times can the hint be shown
	//! \return True when shown
	bool WasShown(EHint hint, int limit = 1)
	{
		return hint > 0 //--- Is type defined (hints without type are never remembered)?
				&& (
					(m_Settings && m_Settings.GetCount(hint) >= limit //--- How many times was the hint shown across instances?
					|| m_aSessionShownHints.Contains(hint)) //--- Was the hint shown in this instance?
				)
				&& !DiagMenu.GetBool(SCR_DebugMenuID.DEBUGUI_HINT_IGNORE_SHOWN); //--- Is debug mode suppressing this check?
	}

	//------------------------------------------------------------------------------------------------
	//! Check if hint info was shown previously (even in previous game sessions; the information is stored persistently).
	//! \return True when shown
	bool WasShown(SCR_HintUIInfo info)
	{
		return info && WasShown(info.GetType(), info.GetShowLimit());
	}

	//------------------------------------------------------------------------------------------------
	//! Override hint duration.
	//! \param[in] duration. When 0, override is reset.
	void SetDurationOverride(float duration)
	{
		m_fDurationOverride = duration;
	}
	//------------------------------------------------------------------------------------------------
	//! Get override of hint duration.
	//! \return Duration. When 0, no override is active.
	float GetDurationOverride()
	{
		return m_fDurationOverride;
	}

	//------------------------------------------------------------------------------------------------
	//! Get the event called when a hint is shown.
	//! \return Script invoker
	ScriptInvokerBase<SCR_HintManagerComponent_OnHint> GetOnHintShow()
	{
		return m_OnHintShow;
	}

	//------------------------------------------------------------------------------------------------
	//! Get the event called when a hint is hidden.
	//! \return Script invoker
	ScriptInvokerBase<SCR_HintManagerComponent_OnHint> GetOnHintHide()
	{
		return m_OnHintHide;
	}
	
	////////////////////////////////////////////////////////////////////////////////////////////////////
	//--- Static functions
	////////////////////////////////////////////////////////////////////////////////////////////////////

	//------------------------------------------------------------------------------------------------
	//! Get instance of the hint manager.
	//! \return Hint manager
	static SCR_HintManagerComponent GetInstance()
	{
		BaseGameMode gameMode = GetGame().GetGameMode();
		if (gameMode)
			return SCR_HintManagerComponent.Cast(gameMode.FindComponent(SCR_HintManagerComponent));
		else
			return null;
	}

	//------------------------------------------------------------------------------------------------
	//! Show hint based on existing configuration.
	//! \param[in] info Hint UI info
	//! \param[in] isSilent True to show the hint without any sound effect
	//! \param[in] ignoreShown When true, the hint will be shown even if it was shown previously
	//! \return True if the hint was shown
	static bool ShowHint(SCR_HintUIInfo info, bool isSilent = false, bool ignoreShown = false)
	{
		SCR_HintManagerComponent hintManager = GetInstance();
		if (hintManager)
			return hintManager.Show(info, isSilent, ignoreShown);
		else
			return false;
	}

	//------------------------------------------------------------------------------------------------
	//! Show hint made of custom texts.
	//!
	//! *************************************************************************************************
	//! ## WARNING! ##
	//!
	//! Use only for quick debugging.
	//! For legit use, please configure the hint as SCR_UIInfo attribute on your entity/component/config!
	//! That will allow you to set all hint properties, as well as to localize it using LocParserPlugin.
	//!
	//! *************************************************************************************************
	//!
	//! \param[in] description Hint text
	//! \param[in] name Hint title
	//! \param[in] duration For how long should the hint be shown (in seconds)
	//! \param[in] isSilent True to show the hint without any sound effect
	//! \return True if the hint was shown
	//!
	static bool ShowCustomHint(string description, string name = string.Empty, float duration = 0, bool isSilent = false, EFieldManualEntryId fieldManualEntry = EFieldManualEntryId.NONE, bool isTimerVisible = false)
	{
		SCR_HintManagerComponent hintManager = GetInstance();
		if (hintManager)
			return hintManager.ShowCustom(description, name, duration, isSilent, EHint.UNDEFINED, fieldManualEntry, isTimerVisible);
		else
			return false;
	}

	//------------------------------------------------------------------------------------------------
	//! Clear the last used hint so it no longer shows.
	static bool ClearLatestHint()
	{
		SCR_HintManagerComponent hintManager = GetInstance();
		if (hintManager)
			return hintManager.ClearHint();
		else
			return false;
	}

	//------------------------------------------------------------------------------------------------
	//! Repeat previously shown hint.
	//! \param[in] isSilent
	//! \return True if the hint was shown
	static bool RepeatHint(bool isSilent = false)
	{
		SCR_HintManagerComponent hintManager = GetInstance();
		if (hintManager)
			return hintManager.Repeat(isSilent);
		else
			return false;
	}

	//------------------------------------------------------------------------------------------------
	//! Clear currently shown hint.
	//! \param[in] info When defined, clear only this hint. If other hint is shown, do nothing.
	//! \return True if a hint was cleared
	static bool HideHint(SCR_HintUIInfo info = null)
	{
		SCR_HintManagerComponent hintManager = GetInstance();
		if (hintManager)
			return hintManager.Hide(info);
		else
			return false;
	}

	//------------------------------------------------------------------------------------------------
	//! Check if a hint is shown at this moment.
	//! \return True when shown
	static bool IsHintShown()
	{
		SCR_HintManagerComponent hintManager = GetInstance();
		if (hintManager)
			return hintManager.IsShown();
		else
			return false;
	}

	//------------------------------------------------------------------------------------------------
	//! Check if hints are enabled in gameplay settings.
	//! \return True when enabled
	static bool CanShowHints()
	{
		SCR_HintManagerComponent hintManager = GetInstance();
		if (hintManager)
			return hintManager.CanShow();
		else
			return false;
	}
	
	////////////////////////////////////////////////////////////////////////////////////////////////////
	//--- Protected functions
	////////////////////////////////////////////////////////////////////////////////////////////////////

	//------------------------------------------------------------------------------------------------
	protected void LoadSettings()
	{
		SCR_HUDManagerComponent hudManager = GetGame().GetHUDManager();
		if (!hudManager)
			return;
		
		BaseContainer interfaceSettings = GetGame().GetGameUserSettings().GetModule(hudManager.GetInterfaceSettingsClass());
		if (!interfaceSettings)
			return;
		
		bool state;
		interfaceSettings.Get("m_bShowHints", state);

		m_SettingsContainer = GetGame().GetGameUserSettings().GetModule("SCR_HintSettings");
		m_Settings.SetHintsEnabled(state);
		m_Settings.LoadShownHints(m_SettingsContainer);
		
		if (m_bIsShown && !m_Settings.AreHintsEnabled())
			Hide();
	}

	//------------------------------------------------------------------------------------------------
	protected void SetShown(SCR_HintUIInfo info)
	{
		if (!info || WasShown(info) || DiagMenu.GetBool(SCR_DebugMenuID.DEBUGUI_HINT_IGNORE_SHOWN))
			return;
		
		EHint type = info.GetType();
		m_aSessionShownHints.Insert(type);
		int count = m_Settings.AddCount(type);
		m_Settings.SaveShownHints(m_SettingsContainer);
		
		Print(string.Format("Hint %1 = %2 saved persistently, count = %3.", typename.EnumToString(EHint, type), type, count), LogLevel.VERBOSE);
	}
	
	////////////////////////////////////////////////////////////////////////////////////////////////////
	//--- Default functions
	////////////////////////////////////////////////////////////////////////////////////////////////////

	//------------------------------------------------------------------------------------------------
	override void OnPostInit(IEntity owner)
	{
		if (System.IsConsoleApp())
			return;
		
		DiagMenu.RegisterBool(SCR_DebugMenuID.DEBUGUI_HINT_IGNORE_SHOWN, "", "Ignore hint persistency", "UI");
		
		if (SCR_Global.IsEditMode(owner))
			return;
		
		//--- Call only for the owner, not server (disabled, called before ownership is transferred)
		//RplComponent rplComponent = RplComponent.Cast(owner.FindComponent(RplComponent));
		//if (rplComponent && !rplComponent.IsOwner())
		//	return;
		
		SCR_HintManagerComponentClass componentPrefab = SCR_HintManagerComponentClass.Cast(GetComponentData(owner));
		componentPrefab.InitConditionLists(owner);
		
		m_Settings = new SCR_HintSettings();
		
		// Call later so the HUDManager gets Initialized first and doesn't return null	
		GetGame().GetCallqueue().Call(LoadSettings);	
		GetGame().OnUserSettingsChangedInvoker().Insert(LoadSettings);
		
		GetGame().GetInputManager().AddActionListener("HintToggle", EActionTrigger.DOWN, Toggle);
		GetGame().GetInputManager().AddActionListener("HintContext", EActionTrigger.DOWN, OpenContext);
	}

	//------------------------------------------------------------------------------------------------
	override void OnDelete(IEntity owner)
	{		
		if (System.IsConsoleApp())
			return;
		
		DiagMenu.Unregister(SCR_DebugMenuID.DEBUGUI_HINT_IGNORE_SHOWN);
		
		SCR_HintManagerComponentClass componentPrefab = SCR_HintManagerComponentClass.Cast(GetComponentData(owner));
		componentPrefab.ExitConditionLists(owner);
		
		GetGame().OnUserSettingsChangedInvoker().Remove(LoadSettings);
		
		GetGame().GetInputManager().RemoveActionListener("HintToggle", EActionTrigger.DOWN, Toggle);
		GetGame().GetInputManager().RemoveActionListener("HintContext", EActionTrigger.DOWN, OpenContext);
	}
}

