class SCR_PlayerControllerClass : PlayerControllerClass
{
}

//------------------------------------------------------------------------------------------------
void OnControlledEntityChangedPlayerController(IEntity from, IEntity to);
typedef func OnControlledEntityChangedPlayerController;
typedef ScriptInvokerBase<OnControlledEntityChangedPlayerController> OnControlledEntityChangedPlayerControllerInvoker;

//------------------------------------------------------------------------------------------------
void OwnershipChangedDelegate(bool isChanging, bool becameOwner);
typedef func OwnershipChangedDelegate;
typedef ScriptInvokerBase<OwnershipChangedDelegate> OnOwnershipChangedInvoker;

//------------------------------------------------------------------------------------------------
void OnDestroyedPlayerController(Instigator killer, IEntity killerEntity);
typedef func OnDestroyedPlayerController;
typedef ScriptInvokerBase<OnDestroyedPlayerController> OnDestroyedPlayerControllerInvoker;

//------------------------------------------------------------------------------------------------
void OnPossessed(IEntity entity);
typedef func OnPossessed;
typedef ScriptInvokerBase<OnPossessed> OnPossessedInvoker;

//------------------------------------------------------------------------------------------------
void OnBeforePossessed(IEntity entity);
typedef func OnBeforePossessed;
typedef ScriptInvokerBase<OnBeforePossessed> OnBeforePossessedInvoker;

class SCR_PlayerController : PlayerController
{
	static PlayerController s_pLocalPlayerController;
	protected static const float WALK_SPEED = 0.5;
	protected static const float FOCUS_ACTIVATION = 0.1;
	protected static const float FOCUS_DEACTIVATION = 0.05;
	protected static const float FOCUS_TIMEOUT = 0.3;
	protected static const float FOCUS_TOLERANCE = 0.005;
	protected static const float FOCUS_ANALOGUE_SCALE = 3.0;
	protected static float s_fADSFocus = 0.5;
	protected static float s_fPIPFocus = 1;
	protected static float s_fFocusTimeout;
	protected static float s_fFocusAnalogue;
	protected static bool s_bWasADS;

	protected CharacterControllerComponent m_CharacterController;
	protected bool m_bIsLocalPlayerController;
	protected bool m_bIsPaused;
	bool m_bRetain3PV;
	protected bool m_bGadgetFocus;
	protected SCR_EFocusToggleMode m_eFocusToggle;
	protected float m_fCharacterSpeed;


	[RplProp(onRplName: "OnRplMainEntityFromID")]
	protected RplId m_MainEntityID;
	protected IEntity m_MainEntity;

	[RplProp()]
	protected bool m_bIsPossessing;

	ref OnBeforePossessedInvoker m_OnBeforePossess = new OnBeforePossessedInvoker();		// Before an entity becomes possesed.
	ref OnPossessedInvoker m_OnPossessed = new OnPossessedInvoker();		// when entity becomes possessed or control returns to the main entity
	ref OnControlledEntityChangedPlayerControllerInvoker m_OnControlledEntityChanged = new OnControlledEntityChangedPlayerControllerInvoker();
	ref OnDestroyedPlayerControllerInvoker m_OnDestroyed = new OnDestroyedPlayerControllerInvoker();		// main entity is destroyed
	ref OnOwnershipChangedInvoker m_OnOwnershipChangedInvoker = new OnOwnershipChangedInvoker();
	//------------------------------------------------------------------------------------------------
	/*!
		\see PlayerController.OnOwnershipChanged for more information.
	*/
	OnOwnershipChangedInvoker GetOnOwnershipChangedInvoker()
	{
		return m_OnOwnershipChangedInvoker;
	}

	//------------------------------------------------------------------------------------------------
	/*!
		\see PlayerController.OnOwnershipChanged for more information.
	*/
	protected override void OnOwnershipChanged(bool changing, bool becameOwner)
	{
		super.OnOwnershipChanged(changing, becameOwner);
		
		if (becameOwner)
		{
			SocialComponent socialComp = SocialComponent.Cast(FindComponent(SocialComponent));
			if (socialComp)
				socialComp.m_OnBlockedPlayerJoinedInvoker.Insert(OnBlockedPlayerJoined);
			
			if (!changing)
			{
				SCR_EditorManagerCore managerCore = SCR_EditorManagerCore.Cast(SCR_EditorManagerCore.GetInstance(SCR_EditorManagerCore));
				managerCore.Event_OnEditorManagerInitOwner.Insert(OnPlayerRegistered);
			}
		}			
		
		m_OnOwnershipChangedInvoker.Invoke(changing, becameOwner);
	}

	//------------------------------------------------------------------------------------------------
	void OnPlayerRegistered(SCR_EditorManagerEntity managerEntity)
	{
		SCR_EditorManagerCore managerCore = SCR_EditorManagerCore.Cast(SCR_EditorManagerCore.GetInstance(SCR_EditorManagerCore));
		managerCore.Event_OnEditorManagerInitOwner.Remove(OnPlayerRegistered);

		// Wait for blocklist to be updated by SocialComponent.
		// Reinitiate blocklist update (if possible)
		SocialComponent.s_OnBlockListUpdateInvoker.Insert(OnBlockedListUpdated);
		SocialComponent.UpdateBlockList();
	}

	//------------------------------------------------------------------------------------------------
	void OnBlockedListUpdated(bool success)
	{
		if (!success)
		{
			// Some logging would be nice
			return;
		}

		// Remove only when it succeeds
		SocialComponent.s_OnBlockListUpdateInvoker.Remove(OnBlockedListUpdated);

		// Request all the authors
		SCR_EditableEntityCore core = SCR_EditableEntityCore.Cast(SCR_EditableEntityCore.GetInstance(SCR_EditableEntityCore));
		if (!core)
			return;
		
		core.Event_OnAuthorsRegisteredFinished.Insert(OnAuthorsRequestFinished);
		core.RequestAllAuthors();
	}
	
	//------------------------------------------------------------------------------------------------
	void OnAuthorsRequestFinished(set<SCR_EditableEntityAuthor> activeUGCAuthors)
	{	
		SCR_EditableEntityCore core = SCR_EditableEntityCore.Cast(SCR_EditableEntityCore.GetInstance(SCR_EditableEntityCore));
		if (!core)
			return;
		
		core.Event_OnAuthorsRegisteredFinished.Remove(OnAuthorsRequestFinished);
		
		PrintFormat("SCR_PlayerController::OnAuthorsRequestFinished - Number of UGC Authors: %1", activeUGCAuthors.Count(), level: LogLevel.VERBOSE);

		SocialComponent socialComp = SocialComponent.Cast(FindComponent(SocialComponent));
		if (!socialComp)
		{
			PrintFormat("SCR_PlayerController::OnAuthorsRequestFinished - Missing SocialComponent", level: LogLevel.VERBOSE);
			return;
		}
		
		array<string> identityIDs = {};
		foreach (SCR_EditableEntityAuthor author : activeUGCAuthors)
		{
			identityIDs.Insert(author.m_sAuthorUID);
		}
		PlayerManager.s_OnPlayerNameCacheUpdateInvoker.Insert(OnPlayerNameCacheUpdate);
		PlayerManager.RequestPlayerNameCacheUpdate(identityIDs);
		
		bool isBlockedAuthorPresent;
		foreach (SCR_EditableEntityAuthor author : activeUGCAuthors)
		{
			const bool isBlocked = socialComp.IsBlockedIdentity(author.m_sAuthorUID, author.m_ePlatform, author.m_sAuthorPlatformID);
			if (isBlocked)
			{
				PrintFormat(
					"Blocked user left UGC in this world {identity: %1; account: %2; platform: %3}",
					author.m_sAuthorUID,
					author.m_sAuthorPlatformID,
					author.m_ePlatform,
					level: LogLevel.VERBOSE
				);
				isBlockedAuthorPresent = true;
				break;
			}
		}
		
		if (isBlockedAuthorPresent)
		{					
			SCR_ConfigurableDialogUi dialog = SCR_ConfigurableDialogUi.CreateFromPreset(SCR_CommonDialogs.DIALOGS_CONFIG, "blocked_ugc_present");
			dialog.m_OnCancel.Insert(DisconnectFromGame);
		}
	}
	
	//------------------------------------------------------------------------------------------------
	void OnPlayerNameCacheUpdate(bool success)
	{
		Print("SCR_PlayerController - Name Cache Updated!", LogLevel.VERBOSE);
		PlayerManager.s_OnPlayerNameCacheUpdateInvoker.Remove(OnPlayerNameCacheUpdate);
	}
	
	//------------------------------------------------------------------------------------------------
	void DisconnectFromGame()
	{
		ChimeraWorld world = GetGame().GetWorld();
		world.PauseGameTime(false);
		
		GameStateTransitions.RequestGameplayEndTransition();
	}
	
	//------------------------------------------------------------------------------------------------
	void OnBlockedPlayerJoined(int playerID)
	{
		SCR_NotificationsComponent.SendLocal(ENotification.PLAYER_ON_BLOCKLIST_JOINED, playerID);
	}

	//------------------------------------------------------------------------------------------------
	override void OnControlledEntityChanged(IEntity from, IEntity to)
	{
		m_OnControlledEntityChanged.Invoke(from, to);

		ChimeraCharacter character = ChimeraCharacter.Cast(to);
		if (character)
			m_CharacterController = character.GetCharacterController();
		else
			m_CharacterController = null;

		SetGameUserSettings();
	}

	//------------------------------------------------------------------------------------------------
	static void SetGameUserSettings()
	{
		BaseContainer aimSensitivitySettings = GetGame().GetGameUserSettings().GetModule("SCR_AimSensitivitySettings");

		if (aimSensitivitySettings)
		{
			float aimSensitivityMouse;
			float aimSensitivityGamepad;
			float aimMultipADS;

			if (aimSensitivitySettings.Get("m_fMouseSensitivity", aimSensitivityMouse) &&
				aimSensitivitySettings.Get("m_fStickSensitivity", aimSensitivityGamepad) &&
				aimSensitivitySettings.Get("m_fAimADS", aimMultipADS))
			{
				CharacterControllerComponent.SetAimingSensitivity(aimSensitivityMouse, aimSensitivityGamepad, aimMultipADS);
				SCR_CharacterCameraHandlerComponent.SetADSSensitivity(aimMultipADS);
			}

			// Input curve: 0 = constant, 1 = linear
			float inputCurveMouse;
			float inputCurveStick;
			float inputCurveGyro;

			if (aimSensitivitySettings.Get("m_fFOVInputCurveMouse", inputCurveMouse) &&
				aimSensitivitySettings.Get("m_fFOVInputCurveStick", inputCurveStick) &&
				aimSensitivitySettings.Get("m_fFOVInputCurveGyro", inputCurveGyro))
			{
				CharacterControllerComponent.SetFOVInputCurve(inputCurveMouse, inputCurveStick, inputCurveGyro);
			}
		}

		BaseContainer gameplaySettings = GetGame().GetGameUserSettings().GetModule("SCR_GameplaySettings");

		if (gameplaySettings)
		{
			bool stickyADS;
			if (gameplaySettings.Get("m_bStickyADS", stickyADS))
				CharacterControllerComponent.SetStickyADS(stickyADS);

			bool stickyGadgets;
			if (gameplaySettings.Get("m_bStickyGadgets", stickyGadgets))
				CharacterControllerComponent.SetStickyGadget(stickyGadgets);

			bool mouseControlAircraft;
			if (gameplaySettings.Get("m_bMouseControlAircraft", mouseControlAircraft))
				CharacterControllerComponent.SetMouseControlAircraft(mouseControlAircraft);

			bool gamepadFreelookInAircraft;
			if (gameplaySettings.Get("m_bGamepadFreelookInAircraft", gamepadFreelookInAircraft))
				CharacterControllerComponent.SetGamepadControlAircraft(!gamepadFreelookInAircraft);

			EVehicleDrivingAssistanceMode drivingAssistance;
			if (gameplaySettings.Get("m_eDrivingAssistance", drivingAssistance))
				VehicleControllerComponent.SetDrivingAssistanceMode(drivingAssistance);
		}

		BaseContainer controllerSettings = GetGame().GetGameUserSettings().GetModule("SCR_ControllerSettings");
		if (controllerSettings)
		{
			bool gyroAlways;
			bool gyroFreelook;
			bool gyroADS;
			if (controllerSettings.Get("m_bGyroAlways", gyroAlways)
				&& controllerSettings.Get("m_bGyroFreelook", gyroFreelook)
				&& controllerSettings.Get("m_bGyroADS", gyroADS))
			{
				CharacterControllerComponent.SetGyroControl(gyroAlways, gyroFreelook, gyroADS);
			}

			float gyroSensitivity;
			float gyroVerticalHorizontalRatio;

			float gyroDirectionYaw;
			float gyroDirectionPitch;
			float gyroDirectionRoll;

			if (controllerSettings.Get("m_fGyroSensitivity", gyroSensitivity)
				&& controllerSettings.Get("m_fGyroVerticalHorizontalRatio", gyroVerticalHorizontalRatio)
				&& controllerSettings.Get("m_fGyroDirectionYaw", gyroDirectionYaw)
				&& controllerSettings.Get("m_fGyroDirectionPitch", gyroDirectionPitch)
				&& controllerSettings.Get("m_fGyroDirectionRoll", gyroDirectionRoll))
			{
				float sensitivityYaw   = gyroSensitivity * (1 - gyroDirectionYaw);
				float sensitivityPitch = gyroSensitivity * (1 - gyroDirectionPitch);
				float sensitivityRoll  = gyroSensitivity * (1 - gyroDirectionRoll);

				if (gyroVerticalHorizontalRatio > 1)
				{
					sensitivityYaw  *= 2 - gyroVerticalHorizontalRatio;
					sensitivityRoll *= 2 - gyroVerticalHorizontalRatio;
				}
				else
				{
					sensitivityPitch *= gyroVerticalHorizontalRatio;
				}

				CharacterControllerComponent.SetGyroSensitivity(sensitivityYaw, sensitivityPitch, sensitivityRoll);
			}
		}

		BaseContainer fovSettings = GetGame().GetGameUserSettings().GetModule("SCR_FieldOfViewSettings");
		if (fovSettings)
		{
			float focusInADS;
			if (fovSettings.Get("m_fFocusInADS", focusInADS))
				s_fADSFocus = focusInADS;

			float focusInPIP;
			if (fovSettings.Get("m_fFocusInPIP", focusInPIP))
				s_fPIPFocus = focusInPIP;
		}
	}

	//------------------------------------------------------------------------------------------------
	/*!
	Set entity which will be possessed by player.
	Possed entity is controlled by player, but it's not *the* player.
	\param entity Entity to be possessed, or null to return control back to the original player
	*/
	void SetPossessedEntity(IEntity entity)
	{
		if (!m_bIsPossessing)
		{
			if (entity)
			{
				m_OnBeforePossess.Invoke(entity);
				//--- Start posessing
				m_bIsPossessing = true;

				//--- Remember previously controlled entity
				IEntity controlledEntity = GetControlledEntity();
				m_MainEntityID = RplId.Invalid();
				if (controlledEntity)
				{
					RplComponent rpl = RplComponent.Cast(controlledEntity.FindComponent(RplComponent));
					if (rpl)
					{
						rpl.GiveExt(RplIdentity.Local(), false);
						m_MainEntityID = rpl.Id();
					}
				}

				OnRplMainEntityFromID(); //--- ToDo: Remove? BumpMe should call it automatically.
				Replication.BumpMe();

				//-- Tell manager we're possessing an entity
				SCR_PossessingManagerComponent possessingManager = SCR_PossessingManagerComponent.GetInstance();
				if (possessingManager)
					possessingManager.SetMainEntity(GetPlayerId(), entity, controlledEntity, m_bIsPossessing);

				//--- Switch control
				RplComponent rpl = RplComponent.Cast(entity.FindComponent(RplComponent));
				if (rpl)
					rpl.GiveExt(GetRplIdentity(), false);
				SetAIActivation(entity, false);
				SetControlledEntity(entity);
				m_OnPossessed.Invoke(entity);
			}
		}
		else
		{
			if (!entity)
			{
				//--- Stop possessing
				m_bIsPossessing = false;

				//--- Forget main entity
				m_MainEntityID = RplId.Invalid();
				OnRplMainEntityFromID(); //--- ToDo: Remove?
				Replication.BumpMe();

				SCR_PossessingManagerComponent possessingManager = SCR_PossessingManagerComponent.GetInstance();
				if (possessingManager)
					possessingManager.SetMainEntity(GetPlayerId(), GetControlledEntity(), m_MainEntity, m_bIsPossessing);

				//--- Switch control
				IEntity controlledEntity = GetControlledEntity();
				if (controlledEntity)
				{
					RplComponent rpl = RplComponent.Cast(controlledEntity.FindComponent(RplComponent));
					if (rpl)
						rpl.GiveExt(RplIdentity.Local(), false);

					SetAIActivation(controlledEntity, true);
				}

				//--- Switch control
				if (m_MainEntity)
				{
					RplComponent rpl = RplComponent.Cast(m_MainEntity.FindComponent(RplComponent));
					if (rpl)
						rpl.GiveExt(GetRplIdentity(), false);
				}
				SetControlledEntity(m_MainEntity);
				m_OnPossessed.Invoke(m_MainEntity);

				//--- SetControlledEntity(null) doesn't work yet. ToDo: Remove this check once it's implemented
				if (GetControlledEntity() != m_MainEntity)
					Print(string.Format("Error when switching control back to m_MainEntity = %1!", m_MainEntity), LogLevel.WARNING);
			}
			else
			{
				//--- Switch possessing
				SetPossessedEntity(null);
				SetPossessedEntity(entity);
				m_OnPossessed.Invoke(entity);
			}
		}
	}

	//------------------------------------------------------------------------------------------------
	/*!
	Set intial main entity of a player, for a case where an existing entity should be assigned instead of spawning a new one
	\param entity is the subject entity
	*/
	void SetInitialMainEntity(notnull IEntity entity)
	{
		RplComponent rpl = RplComponent.Cast(entity.FindComponent(RplComponent));
		if (!rpl)
			return;

		m_MainEntityID = rpl.Id();
		OnRplMainEntityFromID();
		Replication.BumpMe();

		SCR_PossessingManagerComponent possessingManager = SCR_PossessingManagerComponent.GetInstance();
		if (possessingManager)
			possessingManager.SetMainEntity(GetPlayerId(), GetControlledEntity(), entity, m_bIsPossessing);

		rpl.GiveExt(GetRplIdentity(), false); // transfer ownership
		SetAIActivation(entity, false);
		SetControlledEntity(entity);

		m_OnPossessed.Invoke(entity);
	}

	//------------------------------------------------------------------------------------------------
	/*!
	Check if player is currently possessing an entity.
	\return True when possessing
	*/
	bool IsPossessing()
	{
		return m_bIsPossessing;
	}

	//------------------------------------------------------------------------------------------------
	/*!
	Get player's main entity.
	When not possessing, this will be the same as GetControlledEntity()
	When possessing, this will be player's main entity which was controlled before possessing started
	\return Main player entity
	*/
	IEntity GetMainEntity()
	{
		if (m_bIsPossessing)
			return m_MainEntity;
		else
			return GetControlledEntity();
	}

	//------------------------------------------------------------------------------------------------
	protected void OnRplMainEntityFromID()
	{
		//m_MainEntity = IEntity.Cast(Replication.FindItem(m_MainEntityID));
		RplComponent rpl = RplComponent.Cast(Replication.FindItem(m_MainEntityID));
		if (rpl)
			m_MainEntity = rpl.GetEntity();
	}

	//------------------------------------------------------------------------------------------------
	protected void SetAIActivation(IEntity entity, bool activate)
	{
		if (!entity)
			return;

		AIControlComponent aiControl = AIControlComponent.Cast(entity.FindComponent(AIControlComponent));
		if (!aiControl)
			return;

		if (activate)
			aiControl.ActivateAI();
		else
			aiControl.DeactivateAI();
	}

	//------------------------------------------------------------------------------------------------
	//! Returns either a valid ID of local player or 0
	static int GetLocalPlayerId()
	{
		PlayerController pPlayerController = GetGame().GetPlayerController();
		if (!pPlayerController)
			return 0;

		return pPlayerController.GetPlayerId();
	}

	//------------------------------------------------------------------------------------------------
	/*!
	Get entity controlled by player on this machine.
	\return Controlled entity
	*/
	static IEntity GetLocalControlledEntity()
	{
		PlayerController pPlayerController = GetGame().GetPlayerController();
		if (pPlayerController)
			return pPlayerController.GetControlledEntity();

		return null;
	}

	//------------------------------------------------------------------------------------------------
	/*!
	Get player's main entity on this machine.
	When not possessing, this will be the same as GetControlledEntity()
	When possessing, this will be player's main entity which was controlled before possessing started
	\return Main player entity
	*/
	static IEntity GetLocalMainEntity()
	{
		SCR_PlayerController playerController = SCR_PlayerController.Cast(GetGame().GetPlayerController());
		if (playerController)
			return playerController.GetMainEntity();
		else
			return null;
	}

	//---- REFACTOR NOTE START: This code will need to be refactored as current implementation is not conforming to the standards ----
	// TODO: Use getter for faction affiliation component
	//------------------------------------------------------------------------------------------------
	/*!
	Get faction of currently controlled local player entity.
	\return Faction
	*/
	static Faction GetLocalControlledEntityFaction()
	{
		PlayerController playerController = GetGame().GetPlayerController();
		if (!playerController)
			return null;

		IEntity controlledEntity = playerController.GetControlledEntity();
		if (!controlledEntity)
			return null;

		FactionAffiliationComponent factionAffiliation = FactionAffiliationComponent.Cast(controlledEntity.FindComponent(FactionAffiliationComponent));
		if (factionAffiliation)
			return factionAffiliation.GetAffiliatedFaction();
		else
			return null;
	}

	//------------------------------------------------------------------------------------------------
	/*!
	Get faction of local player's main entity.
	When not possessing, the entity will be the same as GetControlledEntity()
	When possessing, the entity will be player's main entity which was controlled before possessing started
	\return Faction
	*/
	static Faction GetLocalMainEntityFaction()
	{
		SCR_PlayerController playerController = SCR_PlayerController.Cast(GetGame().GetPlayerController());
		if (!playerController)
			return null;

		IEntity controlledEntity = playerController.GetMainEntity();
		if (!controlledEntity)
			return null;

		FactionAffiliationComponent factionAffiliation = FactionAffiliationComponent.Cast(controlledEntity.FindComponent(FactionAffiliationComponent));
		if (factionAffiliation)
			return factionAffiliation.GetAffiliatedFaction();
		else
			return null;
	}
	//---- REFACTOR NOTE END ----

	//------------------------------------------------------------------------------------------------
	override void OnDestroyed(notnull Instigator killer)
	{
		super.OnDestroyed(killer);
		IEntity killerEntity = killer.GetInstigatorEntity();
		m_OnDestroyed.Invoke(killer, killerEntity);
	}

	//------------------------------------------------------------------------------------------------
	override void OnUpdate(float timeSlice)
	{
		if (!s_pLocalPlayerController)
			UpdateLocalPlayerController();

		if (m_bIsLocalPlayerController)
		{
			UpdateControls();
			//UpdateUI();
		}
	}

	//------------------------------------------------------------------------------------------------
	//! Find if this is local player controller. We assume that this never changes during scenario.
	protected void UpdateLocalPlayerController()
	{
		m_bIsLocalPlayerController = this == GetGame().GetPlayerController();
		if (!m_bIsLocalPlayerController)
			return;

		s_pLocalPlayerController = this;
		InputManager inputManager = GetGame().GetInputManager();
		if (!inputManager)
			return;

		inputManager.AddActionListener("WeaponChangeMagnification", EActionTrigger.VALUE, ChangeMagnification);
		inputManager.AddActionListener("CharacterWalk", EActionTrigger.DOWN, OnWalk);
		inputManager.AddActionListener("CharacterWalk", EActionTrigger.UP, OnEndWalk);
		inputManager.AddActionListener("FocusToggle", EActionTrigger.DOWN, ActionFocusToggle);
		inputManager.AddActionListener("FocusToggleVehicle", EActionTrigger.DOWN, ActionFocusToggleVehicle);
		inputManager.AddActionListener("FocusToggleUnarmed", EActionTrigger.DOWN, ActionFocusToggleUnarmed);
		inputManager.AddActionListener("Inventory", EActionTrigger.DOWN, ActionOpenInventory);
		inputManager.AddActionListener("TacticalPing", EActionTrigger.DOWN, ActionGesturePing);
		inputManager.AddActionListener("TacticalPingHold", EActionTrigger.DOWN, ActionGesturePingHold);
		inputManager.AddActionListener("TacticalPingHold", EActionTrigger.UP, ActionGesturePingHold);
		inputManager.AddActionListener("WeaponSwitchOptics", EActionTrigger.UP, ChangeWeaponOptics);
	}

	//------------------------------------------------------------------------------------------------
	//! Update disabling of character controls in menus
	protected void UpdateControls()
	{
		bool disableControls = GetGame().GetMenuManager().IsAnyMenuOpen();
		if (m_bIsPaused != disableControls)
		{
			m_bIsPaused = disableControls;
			SetDisableControls(disableControls);
		}
	}

	//---- REFACTOR NOTE START: This code will need to be refactored as current implementation is not conforming to the standards ----
	// TODO: This is obsolete
	//------------------------------------------------------------------------------------------------
	protected void UpdateUI()
	{
		ChimeraCharacter char = ChimeraCharacter.Cast(GetControlledEntity());
		if (!char)
			return;
		CharacterAnimationComponent animComp = char.GetAnimationComponent();
		if (!animComp)
			return;
		// Command ladder is present only when character is using ladder
		CharacterCommandLadder ladderCMD = animComp.GetCommandHandler().GetCommandLadder();
		if (!ladderCMD)
			return;
		int lrExitState = ladderCMD.CanExitLR();
		if (lrExitState & 0x1)
		{
			Print("Can exit right");
		}
		if (lrExitState & 0x2)
		{
			Print("Can exit left");
		}
	}
	//---- REFACTOR NOTE END ----

	//------------------------------------------------------------------------------------------------
	protected void ChangeMagnification(float value)
	{
		SCR_CharacterControllerComponent characterController = GetCharacterController();
		if (characterController)
			characterController.SetNextSightsFOVInfo(value);
	}

	//------------------------------------------------------------------------------------------------
	protected void ChangeWeaponOptics()
	{
		SCR_CharacterControllerComponent characterController = GetCharacterController();
		if (characterController)
			characterController.SetNextSights();
	}

	//------------------------------------------------------------------------------------------------
	protected SCR_CharacterControllerComponent GetCharacterController()
	{
		ChimeraCharacter char = ChimeraCharacter.Cast(GetControlledEntity());
		if (!char)
			return null;

		return SCR_CharacterControllerComponent.Cast(char.GetCharacterController());
	}

	//------------------------------------------------------------------------------------------------
	// Parameter value:
	// TRUE:  Disables the controls
	// FALSE: Enables the controls
	private void SetDisableControls(bool value)
	{
		SCR_CharacterControllerComponent characterController = GetCharacterController();
		if (!characterController)
			return;

		characterController.SetDisableViewControls(value);
		characterController.SetDisableWeaponControls(value);
		characterController.SetDisableMovementControls(value)
	}

	//------------------------------------------------------------------------------------------------
	/*! Focus input degree for analogue input
	\param adsProgress ADS focus percentage
	\param dt Delta time
	\return focus Amount of focus between 0 and 1
	*/
	float GetFocusValue(float adsProgress = 0, float dt = -1)
	{
		if (!m_CharacterController)

			return 0;
		float focus;

		// Autofocus
		if (adsProgress > 0)
		{
			// PIPCQB Separate slider
			if (SCR_2DPIPSightsComponent.IsPIPActive())
				focus = Math.Lerp(s_fADSFocus, 1, s_fPIPFocus);
			else
				focus = s_fADSFocus;

			focus *= Math.Min(adsProgress, 1);

			if (m_CharacterController.IsFreeLookEnabled())
			{
				// Freelook angle effect on ADS focus
				CharacterHeadAimingComponent headAiming = m_CharacterController.GetHeadAimingComponent();
				if (headAiming)
				{
					float freelookAngle = headAiming.GetAimingRotation().Length();
					float freelookFocus = 1 - Math.InverseLerp(1, 6, freelookAngle);
					focus *= Math.Clamp(freelookFocus, 0, 1);
				}
			}
		}

		InputManager inputManager = GetGame().GetInputManager();

		// Cancel toggled focus when focus is held
		bool inputDigital = inputManager.GetActionTriggered("Focus");
		if (inputDigital && m_eFocusToggle != SCR_EFocusToggleMode.DISABLED)
			m_eFocusToggle = SCR_EFocusToggleMode.DISABLED;

		// Conditions must be consistent with ActionFocusToggle and ActionFocusToggleUnarmed
		ChimeraCharacter character = m_CharacterController.GetCharacter();
		if (character && character.IsInVehicle())
		{
			// Vehicle focus toggle mode
			if (m_eFocusToggle == SCR_EFocusToggleMode.VEHICLE)
			{
				// Cancel toggle focus when in vehicle and aiming through gadget (binocular, compass)
				if (m_bGadgetFocus)
					m_eFocusToggle = SCR_EFocusToggleMode.DISABLED;

				// Cancel toggle focus when in vehicle and not in forced freelook
				if (!m_CharacterController.IsFreeLookEnabled() && !m_CharacterController.GetFreeLookInput())
					m_eFocusToggle = SCR_EFocusToggleMode.DISABLED;
			}
		}
		else
		{
			// Unarmed focus toggle mode
			if (m_eFocusToggle == SCR_EFocusToggleMode.UNARMED)
			{
				// Cancel toggle focus when not in vehicle and holding item in hands
				if (m_CharacterController.GetCurrentItemInHands())
					m_eFocusToggle = SCR_EFocusToggleMode.DISABLED;

				// Cancel toggle focus when not in vehicle and holding gadget
				if (m_CharacterController.IsGadgetInHands())
					m_eFocusToggle = SCR_EFocusToggleMode.DISABLED;
			}
		}

		// Vehicles have different focus action to prevent conflict with brakes
		bool isVehicleContextActive = inputManager.IsContextActive("CarContext") || inputManager.IsContextActive("TrackedContext") || inputManager.IsContextActive("HelicopterContext");
		float inputAnalogue;
		if (!isVehicleContextActive)
		{
			// Square root input to focus mapping results in linear change of picture area
			float focusAnalogue = Math.Sqrt(FOCUS_ANALOGUE_SCALE * inputManager.GetActionValue("FocusAnalog"));

			// Tolerance to prevent jittering
			if (focusAnalogue < FOCUS_DEACTIVATION)
				s_fFocusAnalogue = 0;
			else if (!float.AlmostEqual(s_fFocusAnalogue, focusAnalogue, FOCUS_TOLERANCE))
				s_fFocusAnalogue = focusAnalogue;

			inputAnalogue = s_fFocusAnalogue;
		}

		bool isADS = m_CharacterController.GetWeaponADSInput();

		// Check gadget ADS
		if (!isADS && m_CharacterController.IsGadgetInHands())
			isADS = m_CharacterController.IsGadgetRaisedModeWanted();

		// Verify turrets
		if (!isADS && character)
		{
			CompartmentAccessComponent compartmentAccess = character.GetCompartmentAccessComponent();

			BaseCompartmentSlot compartment;
			if (compartmentAccess)
				compartment = compartmentAccess.GetCompartment();

			TurretControllerComponent turretController;
			if (compartment)
				turretController = TurretControllerComponent.Cast(compartment.GetController());

			if (turretController)
				isADS = turretController.IsWeaponADS();
		}

		// Prevent focus warping back while toggling ADS on controller
		// analogue: track timeout as we have no input filter that has thresholds or delays and returns axis value yet
		if (inputAnalogue < FOCUS_DEACTIVATION)
			s_fFocusTimeout = FOCUS_TIMEOUT; // Below deactivation threshold
		else if (s_bWasADS != isADS && s_fFocusTimeout > 0)
			s_fFocusTimeout = FOCUS_TIMEOUT; // ADS toggled
		else if (inputAnalogue < FOCUS_ACTIVATION && s_fFocusTimeout > 0)
			s_fFocusTimeout = FOCUS_TIMEOUT; // Below activation threshold and not active
		else if (s_fFocusTimeout > dt)
			s_fFocusTimeout -= dt; // Not yet active, decrementing
		else
			s_fFocusTimeout = 0; // Activated

		// Cancel toggle focus with analogue input
		if (m_eFocusToggle != SCR_EFocusToggleMode.DISABLED && s_fFocusTimeout == 0)
			m_eFocusToggle = SCR_EFocusToggleMode.DISABLED;

		s_bWasADS = isADS;

		// Combine all valid input sources
		float input;
		if (m_eFocusToggle != SCR_EFocusToggleMode.DISABLED || inputDigital)
			input = 1;
		else if (s_fFocusTimeout == 0)
			input = inputAnalogue;

		if (input > 0)
			focus = Math.Max(focus, input);

		// Ensure return value always within 0-1
		focus = Math.Clamp(focus, 0, 1);
		return focus;
	}

	//------------------------------------------------------------------------------------------------
	//! Automatic focusing while gadget is aimed down sights
	void SetGadgetFocus(bool gadgetFocus)
	{
		m_bGadgetFocus = gadgetFocus;
	}

	//------------------------------------------------------------------------------------------------
	//! Automatic focusing while gadget is aimed down sights
	bool GetGadgetFocus()
	{
		return m_bGadgetFocus;
	}

	//---- REFACTOR NOTE START: This code will need to be refactored as current implementation is not conforming to the standards ----
	//! TODO: Action listener methods should be protected
	//------------------------------------------------------------------------------------------------
	void ActionFocusToggle(float value = 0.0, EActionTrigger reason = 0)
	{
		// If focus toggle was in different mode, it should be disabled first
		if (m_eFocusToggle == SCR_EFocusToggleMode.DISABLED)
			m_eFocusToggle = SCR_EFocusToggleMode.ENABLED;
		else
			m_eFocusToggle = SCR_EFocusToggleMode.DISABLED
	}

	//------------------------------------------------------------------------------------------------
	void ActionFocusToggleVehicle(float value = 0.0, EActionTrigger reason = 0)
	{
		if (!m_CharacterController)
			return;

		// Conditions must be consistent with GetFocusValue logic
		ChimeraCharacter character = m_CharacterController.GetCharacter();
		if (character && !character.IsInVehicle())
			return;

		// Cancel toggle focus when in vehicle and aiming through gadget (binocular, compass)
		if (m_bGadgetFocus)
			return;

		// Cancel toggle focus when in vehicle and not in forced freelook
		if (!m_CharacterController.IsFreeLookEnabled() && !m_CharacterController.GetFreeLookInput())
			return;

		// If focus toggle was in different mode, it should be disabled first
		if (m_eFocusToggle == SCR_EFocusToggleMode.DISABLED)
			m_eFocusToggle = SCR_EFocusToggleMode.VEHICLE;
		else
			m_eFocusToggle = SCR_EFocusToggleMode.DISABLED
	}

	//------------------------------------------------------------------------------------------------
	void ActionFocusToggleUnarmed(float value = 0.0, EActionTrigger reason = 0)
	{
		if (!m_CharacterController)
			return;

		// Conditions must be consistent with GetFocusValue logic
		ChimeraCharacter character = m_CharacterController.GetCharacter();
		if (character && character.IsInVehicle())
			return;

		// Cancel toggle focus when not in vehicle and holding item in hands
		if (m_CharacterController.GetCurrentItemInHands())
			return;

		// Cancel toggle focus when not in vehicle and holding gadget
		if (m_CharacterController.IsGadgetInHands())
			return;

		// Allow cancelling unarmed focus while picking up items
		// Disallow enabling unarmed focus while picking up items, as it may become irreleant quickly
		// Reason is player may want to enter ADS before ready, while intent is unclear
		if (m_eFocusToggle == SCR_EFocusToggleMode.DISABLED && m_CharacterController.IsPlayingItemGesture())
			return;
		
		// If focus toggle was in different mode, it should be disabled first
		if (m_eFocusToggle == SCR_EFocusToggleMode.DISABLED)
			m_eFocusToggle = SCR_EFocusToggleMode.UNARMED;
		else
			m_eFocusToggle = SCR_EFocusToggleMode.DISABLED
	}

	//------------------------------------------------------------------------------------------------
	void OnWalk()
	{
		if (!m_CharacterController || m_CharacterController.GetDynamicSpeed() == WALK_SPEED)
			return;

		m_fCharacterSpeed = m_CharacterController.GetDynamicSpeed();
		m_CharacterController.SetDynamicSpeed(WALK_SPEED);
		m_CharacterController.SetShouldApplyDynamicSpeedOverride(true);
	}

	//------------------------------------------------------------------------------------------------
	void OnEndWalk()
	{
		if (!m_CharacterController || m_CharacterController.GetDynamicSpeed() == m_fCharacterSpeed)
			return;

		m_CharacterController.SetDynamicSpeed(m_fCharacterSpeed);
		m_CharacterController.SetShouldApplyDynamicSpeedOverride(false);
	}

	//------------------------------------------------------------------------------------------------
	void ActionOpenInventory()
	{
		IEntity entity = s_pLocalPlayerController.GetControlledEntity();
		if (!entity)
			return;

		SCR_InventoryStorageManagerComponent inventory = SCR_InventoryStorageManagerComponent.Cast(entity.FindComponent(SCR_InventoryStorageManagerComponent));
		if (inventory)
			inventory.Action_OpenInventory();
	}

	//------------------------------------------------------------------------------------------------
	void ActionGesturePing(float value = 0.0, EActionTrigger reason = 0)
	{
		if (!m_CharacterController)
			return;

		// Press and forget variant... eg press comma once - character will point with it's finger for 1 second (including blending time from animation graph ~300ms)
		m_CharacterController.TryStartCharacterGesture(ECharacterGestures.POINT_WITH_FINGER, 1500);
	}

	//------------------------------------------------------------------------------------------------
	void ActionGesturePingHold(float value = 0.0, EActionTrigger reason = 0)
	{
		if (!m_CharacterController)
			return;

		// Hold key variant... hold period - character will point with it's finger until period key is released
		if (reason == EActionTrigger.DOWN)
		{
			m_CharacterController.TryStartCharacterGesture(ECharacterGestures.POINT_WITH_FINGER);
		} else if (reason == EActionTrigger.UP)
		{
			m_CharacterController.StopCharacterGesture();
		}
	}
	//---- REFACTOR NOTE END ----
	
	//------------------------------------------------------------------------------------------------
	// Set the correct platfrom icon to the provided Image Widget
	//! \param playerID
	//! \param image
	//! \param glowImage
	//! \param set image Visible
	//! \param show on PC
	//! \param show on Xbox
	bool SetPlatformImageTo(int playerID, notnull ImageWidget image, ImageWidget glow = null, bool setVisible = true, bool showOnPC = false, bool showOnXbox = false)
	{		
		PlayerManager playerMgr = GetGame().GetPlayerManager();
		if (!playerMgr)
			return false;
		
		PlatformKind targetPlatformKind = playerMgr.GetPlatformKind(playerID);
		PlatformKind ownPlatformKind = playerMgr.GetPlatformKind(GetLocalPlayerId());
		
		// Always show on PSN
		if (ownPlatformKind == PlatformKind.PSN	)
			SetPlatformImagePSN(targetPlatformKind, image, glow, setVisible);
		
		if (!showOnPC && !showOnXbox)
			return true;
		
		switch (ownPlatformKind)
		{
			case PlatformKind.STEAM:
				if (showOnPC)
					SetPlatformImagePC(targetPlatformKind, image, glow, setVisible);
			break;
			
			case PlatformKind.XBOX:
				if (showOnXbox)
					SetPlatformImageXbox(targetPlatformKind, image, glow, setVisible);
			break;
			
			case PlatformKind.NONE:
				if (showOnPC)
					SetPlatformImagePC(targetPlatformKind, image, glow, setVisible);
			break;
		}
		
		return true;
	}
	
	//------------------------------------------------------------------------------------------------
	// Set the correct platfrom icon to the provided Image Widget based on PlatformKind
	//! \param platform
	//! \param image
	//! \param glowImage
	//! \param set image Visible
	//! \param show on PC
	//! \param show on Xbox
	bool SetPlatformImageToKind(PlatformKind targetPlatform, notnull ImageWidget image, ImageWidget glow = null, bool setVisible = true, bool showOnPC = false, bool showOnXbox = false)
	{
		PlatformKind ownPlatformKind = GetGame().GetPlayerManager().GetPlatformKind(GetLocalPlayerId());
		
		// Always show on PSN
		if (ownPlatformKind == PlatformKind.PSN)
			SetPlatformImagePSN(targetPlatform, image, glow, setVisible);
		
		if (!showOnPC && !showOnXbox)
			return true;
		
		switch (ownPlatformKind)
		{
			case PlatformKind.STEAM:
				if (showOnPC)
					SetPlatformImagePC(targetPlatform, image, glow, setVisible);
			break;
			
			case PlatformKind.XBOX:
				if (showOnXbox)
					SetPlatformImageXbox(targetPlatform, image, glow, setVisible);
			break;
			
			case PlatformKind.NONE:
				if (showOnPC)
					SetPlatformImagePC(targetPlatform, image, glow, setVisible);
			break;
		}
		
		return true;
	}
	
	//------------------------------------------------------------------------------------------------
	protected void SetPlatformImagePSN(PlatformKind targetPlatformKind, notnull ImageWidget image, ImageWidget glow = null, bool setVisible = true)
	{
		if (targetPlatformKind == PlatformKind.PSN)
		{
			image.LoadImageFromSet(0, UIConstants.ICONS_IMAGE_SET, UIConstants.PLATFROM_PLAYSTATION_ICON_NAME);
			
			if (glow)
				glow.LoadImageFromSet(0, UIConstants.ICONS_GLOW_IMAGE_SET, UIConstants.PLATFROM_PLAYSTATION_ICON_NAME);
		}
		else
		{
			image.LoadImageFromSet(0, UIConstants.ICONS_IMAGE_SET, UIConstants.PLATFROM_GENERIC_ICON_NAME);
			
			if (glow)
				glow.LoadImageFromSet(0, UIConstants.ICONS_GLOW_IMAGE_SET, UIConstants.PLATFROM_GENERIC_ICON_NAME);
		}
		
		if (!setVisible)
			return;
		
		image.SetVisible(true);
		if (glow)
			glow.SetVisible(true);
	}
	
	//------------------------------------------------------------------------------------------------
	protected void SetPlatformImagePC(PlatformKind targetPlatformKind, notnull ImageWidget image, ImageWidget glow = null, bool setVisible = true)
	{
		string icon;
		switch (targetPlatformKind)
		{
			case PlatformKind.STEAM:
				icon = UIConstants.PLATFROM_PC_ICON_NAME;
			break;
			case PlatformKind.XBOX:
				icon = UIConstants.PLATFROM_XBOX_ICON_NAME;
			break;
			case PlatformKind.PSN:
				icon = UIConstants.PLATFROM_PLAYSTATION_ICON_NAME;
			break;
			case PlatformKind.NONE:
				icon = UIConstants.PLATFROM_PC_ICON_NAME;
			break;
		}
		
		image.LoadImageFromSet(0, UIConstants.ICONS_IMAGE_SET, icon);
		if (glow)
			glow.LoadImageFromSet(0, UIConstants.ICONS_GLOW_IMAGE_SET, icon);
		
		if (!setVisible)
			return;
		
		image.SetVisible(true);
		if (glow)
			glow.SetVisible(true);
	}
	
	//------------------------------------------------------------------------------------------------
	protected void SetPlatformImageXbox(PlatformKind targetPlatformKind, notnull ImageWidget image, ImageWidget glow = null, bool setVisible = true)
	{
		string icon;
		switch (targetPlatformKind)
		{
			case PlatformKind.STEAM:
				icon = UIConstants.PLATFROM_PC_ICON_NAME;
			break;
			case PlatformKind.XBOX:
				icon = UIConstants.PLATFROM_XBOX_ICON_NAME;
			break;
			case PlatformKind.PSN:
				icon = UIConstants.PLATFROM_PLAYSTATION_ICON_NAME;
			break;
			case PlatformKind.NONE:
				icon = UIConstants.PLATFROM_PC_ICON_NAME;
			break;
		}
		
		image.LoadImageFromSet(0, UIConstants.ICONS_IMAGE_SET, icon);
		if (glow)
			glow.LoadImageFromSet(0, UIConstants.ICONS_GLOW_IMAGE_SET, icon);
		
		if (!setVisible)
			return;
		
		image.SetVisible(true);
		if (glow)
			glow.SetVisible(true);
	}
}

[ComponentEditorProps(category: "GameScripted/Character", description: "Scripted character controller", icon: HYBRID_COMPONENT_ICON)]
class SCR_CharacterControllerComponentClass : CharacterControllerComponentClass
{
}

//------------------------------------------------------------------------------------------------
void OnPlayerDeathWithParam(SCR_CharacterControllerComponent characterController, IEntity killerEntity, notnull Instigator killer);
typedef func OnPlayerDeathWithParam;
typedef ScriptInvokerBase<OnPlayerDeathWithParam> OnPlayerDeathWithParamInvoker;

//------------------------------------------------------------------------------------------------
void OnControlledByPlayer(IEntity ownerEntity, bool controlled);
typedef func OnControlledByPlayer;
typedef ScriptInvokerBase<OnControlledByPlayer> OnControlledByPlayerInvoker;

//------------------------------------------------------------------------------------------------
typedef func OnLifeStateChanged;
typedef ScriptInvokerBase<OnLifeStateChanged> OnLifeStateChangedInvoker;

//------------------------------------------------------------------------------------------------
void OnItemUseBegan(IEntity item, ItemUseParameters animParams);
typedef func OnItemUseBegan;
typedef ScriptInvokerBase<OnItemUseBegan> OnItemUseBeganInvoker;

//------------------------------------------------------------------------------------------------
void OnItemUseEnded(IEntity item, bool successful, ItemUseParameters animParams);
typedef func OnItemUseEnded;
typedef ScriptInvokerBase<OnItemUseEnded> OnItemUseEndedInvoker;

//------------------------------------------------------------------------------------------------
void OnItemUseFinished(IEntity item, bool successful, ItemUseParameters animParams);
typedef func OnItemUseFinished;
typedef ScriptInvokerBase<OnItemUseFinished> OnItemUseFinishedInvoker;

class SCR_CharacterControllerComponent : CharacterControllerComponent
{
	[Attribute(defvalue: "10", uiwidget: UIWidgets.EditBox, params:"1 inf 0.1", desc: "Maximum duration it takes for character to drown\n[s]")]
	protected float m_fDrowningDuration;
	
	[Attribute(defvalue: "4", uiwidget: UIWidgets.EditBox, params:"0 inf 0.1", desc: "Amount of raw damage needed for character to play an animated hitreaction")]
	protected float m_fAnimatedHitReactionThreshold;
	
	protected static ref array<EDamageType> s_aHitReactionDamageTypes = {
		EDamageType.COLLISION,
		EDamageType.MELEE,
		EDamageType.KINETIC,
		EDamageType.FRAGMENTATION,
		EDamageType.EXPLOSIVE
	};
	
	// Private members
	protected SCR_CharacterCameraHandlerComponent m_CameraHandler; // Set from the camera handler itself
	protected SCR_MeleeComponent m_MeleeComponent;
	protected bool m_bOverrideActions = true;
	protected bool m_bInspectionFocus;
	protected bool m_bCharacterIsDrowning;
	protected float m_fDrowningTime;
	protected ref SCR_ScriptedCharacterInputContext m_pScrInputContext;

	// Character event invokers
	ref ScriptInvokerVoid m_OnPlayerDeath = new ScriptInvokerVoid();
	ref OnPlayerDeathWithParamInvoker m_OnPlayerDeathWithParam = new OnPlayerDeathWithParamInvoker(); // has a getter!
	ref OnLifeStateChangedInvoker m_OnLifeStateChanged = new OnLifeStateChangedInvoker();
	ref OnControlledByPlayerInvoker m_OnControlledByPlayer = new OnControlledByPlayerInvoker();
	ref ScriptInvokerFloat2<float> m_OnPlayerDrowning = new ScriptInvokerFloat2();
	ref ScriptInvokerVoid m_OnPlayerStopDrowning = new ScriptInvokerVoid();
	
	// Gadget event invokers
	ref ScriptInvoker<IEntity, bool, bool> m_OnGadgetStateChangedInvoker = new ScriptInvoker<IEntity, bool, bool>();
	ref ScriptInvoker<IEntity, bool> m_OnGadgetFocusStateChangedInvoker = new ScriptInvoker<IEntity, bool>();

	// Item event invokers
	ref OnItemUseBeganInvoker m_OnItemUseBeganInvoker = new OnItemUseBeganInvoker();
	ref OnItemUseEndedInvoker m_OnItemUseEndedInvoker = new OnItemUseEndedInvoker();
	// called when all listeners reacted on ItemUseEnded invoker - may delete the item now thus listerners to ItemUseFinished may get first parameter null! 
	ref OnItemUseFinishedInvoker m_OnItemUseFinishedInvoker = new OnItemUseFinishedInvoker();
	protected ref ScriptInvoker<AnimationEventID, AnimationEventID, int, float, float> m_OnAnimationEvent;

	// Diagnostics, debugging
	#ifdef ENABLE_DIAG
	private static bool s_bDiagRegistered;
	private static bool m_bEnableDebugUI;
	private CharacterAnimationComponent m_AnimComponent;
	private Widget m_wDebugRootWidget;
	private ECharacterStance m_bDebugLastStance = ECharacterStance.STAND;
	#endif

	//------------------------------------------------------------------------------------------------
	//! Get the interaction status of the character
	//! \return true if the character is alive ad not using items or vehicles
	//! not on a ladder, not aiming down sights, not in 3rd person in a vehicle, not already using an item nor weapon-deployed
	bool CanInteract()
	{
		if (GetLifeState() != ECharacterLifeState.ALIVE)
			return false;
		
		if (IsUsingItem())
			return false;
		
		if (IsClimbing())
			return false;

		ChimeraCharacter character = GetCharacter();
		if (!character || character.IsInVehicleADS())
			return false;
		
		// Disable in vehicle 3pp
		if (character.IsInVehicle() && IsInThirdPersonView())
			return false;
		
		if (GetIsWeaponDeployed())
			return false;
		
		return true;
	}
	
	//------------------------------------------------------------------------------------------------
	override void OnConsciousnessChanged(bool conscious)
	{
		if (GetLifeState() != ECharacterLifeState.INCAPACITATED)
			return;

		AIControlComponent aiControl = AIControlComponent.Cast(GetOwner().FindComponent(AIControlComponent));
		if (!aiControl || !aiControl.IsAIActivated())
			return;
		
		IEntity currentWeapon;
		BaseWeaponManagerComponent wpnMan = GetWeaponManagerComponent();
		if (wpnMan && wpnMan.GetCurrentWeapon())
			currentWeapon = wpnMan.GetCurrentWeapon().GetOwner();
				
		if (currentWeapon)
		{
			bool dropGrenade = false;
			
			SCR_CharacterCommandHandlerComponent handler = SCR_CharacterCommandHandlerComponent.Cast(GetAnimationComponent().GetCommandHandler());
			
			EWeaponType wt = wpnMan.GetCurrentWeapon().GetWeaponType();
			if (currentWeapon.FindComponent(GrenadeMoveComponent))
			{
				BaseTriggerComponent triggerComp = BaseTriggerComponent.Cast(currentWeapon.FindComponent(BaseTriggerComponent));
				
				if ((triggerComp && triggerComp.WasTriggered()) || (handler && handler.IsThrowingAction()))
				{
					dropGrenade = true;
				}
			}
			
			if (dropGrenade)
				handler.DropLiveGrenadeFromHand(false); 
			else 
				TryEquipRightHandItem(null, EEquipItemType.EEquipTypeUnarmedContextual, true);
		}
	}
	
	//------------------------------------------------------------------------------------------------
	//! \return a script invoker with method signature (AnimationEventID animEventType, AnimationEventID animUserString, int intParam, float timeFromStart, float timeToEnd)
	ScriptInvoker GetOnAnimationEvent()
	{
		if (!m_OnAnimationEvent)
			m_OnAnimationEvent = new ScriptInvoker();

		return m_OnAnimationEvent;
	}

	//------------------------------------------------------------------------------------------------
	override void OnGadgetStateChanged(IEntity gadget, bool isInHand, bool isOnGround)
	{
		m_OnGadgetStateChangedInvoker.Invoke(gadget, isInHand, isOnGround);
	}

	//------------------------------------------------------------------------------------------------
	override void OnGadgetFocusStateChanged(IEntity gadget, bool isFocused)
	{
		m_OnGadgetFocusStateChangedInvoker.Invoke(gadget, isFocused);
	}

	//------------------------------------------------------------------------------------------------
	override void OnItemUseBegan(ItemUseParameters itemUseParams) 
	{
		m_OnItemUseBeganInvoker.Invoke(itemUseParams.GetEntity(), itemUseParams);
	}

	//------------------------------------------------------------------------------------------------
	override void OnItemUseEnded(ItemUseParameters itemUseParams, bool successful)
	{
		m_OnItemUseEndedInvoker.Invoke(itemUseParams.GetEntity(), successful, itemUseParams);
		// now all interested in non-null item have listened, we can call Finished to delete the item
		m_OnItemUseFinishedInvoker.Invoke(itemUseParams.GetEntity(), successful, itemUseParams);
	}

	//------------------------------------------------------------------------------------------------
	protected override void OnAnimationEvent(AnimationEventID animEventType, AnimationEventID animUserString, int intParam, float timeFromStart, float timeToEnd)
	{
		if (m_OnAnimationEvent)
			m_OnAnimationEvent.Invoke(animEventType, animUserString, intParam, timeFromStart, timeToEnd);
	}

	//------------------------------------------------------------------------------------------------
	// handling of melee events. Sends true if melee started, false, when melee ends
	override void OnMeleeDamage(bool started)
	{
		m_MeleeComponent.SetMeleeAttackStarted(started);
	}
	
	//------------------------------------------------------------------------------------------------
	// play hitreaction when taking momentary physical damage 
	protected override EHitReactionType ComputeHitReaction(float damageValue, EDamageType damageType)
	{
		if (damageValue < m_fAnimatedHitReactionThreshold)
			return EHitReactionType.HIT_REACTION_NONE;
		
		if (!s_aHitReactionDamageTypes.Contains(damageType))
			return EHitReactionType.HIT_REACTION_NONE;
		
		return EHitReactionType.HIT_REACTION_LIGHT;
	}
	
	//------------------------------------------------------------------------------------------------
	//! \return
	ScriptInvokerVoid GetOnPlayerDeath()
	{
		return m_OnPlayerDeath;
	}
	
	//------------------------------------------------------------------------------------------------
	//! \return
	OnPlayerDeathWithParamInvoker GetOnPlayerDeathWithParam()
	{
		return m_OnPlayerDeathWithParam;
	}
	
	//------------------------------------------------------------------------------------------------
	override void OnDeath(IEntity instigatorEntity, notnull Instigator instigator)
	{
		m_OnPlayerDeath.Invoke();
		m_OnPlayerDeathWithParam.Invoke(this, instigatorEntity, instigator);

		SCR_PlayerController pc = SCR_PlayerController.Cast(GetGame().GetPlayerController());
		if (pc && m_CameraHandler && m_CameraHandler.IsInThirdPerson())
			pc.m_bRetain3PV = true;

		IEntity character = GetCharacter();
		auto garbageSystem = SCR_GarbageSystem.GetByEntityWorld(character);
		if (garbageSystem)
			garbageSystem.Insert(character);
	}

	//------------------------------------------------------------------------------------------------
	override void OnLifeStateChanged(ECharacterLifeState previousLifeState, ECharacterLifeState newLifeState)
	{
		m_OnLifeStateChanged.Invoke(previousLifeState, newLifeState);
		
		ChimeraCharacter char = GetCharacter();
		if (!char)
			return;
		
		IEntity vehicle = CompartmentAccessComponent.GetVehicleIn(char);
		if (!vehicle)
			return;
		
		SCR_VehicleFactionAffiliationComponent vehicleFactionAff = SCR_VehicleFactionAffiliationComponent.Cast(vehicle.FindComponent(SCR_VehicleFactionAffiliationComponent));
		if (!vehicleFactionAff)
			return;
		
		vehicleFactionAff.UpdateOccupantsCount();	
	}

	//------------------------------------------------------------------------------------------------
	override bool GetCanMeleeAttack()
	{
		if (!m_MeleeComponent)
			return false;

		if (IsFalling())
			return false;

		if (GetStance() == ECharacterStance.PRONE)
			return false;

		// TODO: Gadget melee weapon properties in case we want to be able to have melee component, like a shovel?
		if (IsGadgetInHands())
			return false;

		//! check presence of MeleeWeaponProperties component to ensure it is an Melee weapon or not
		BaseWeaponManagerComponent weaponManager = GetWeaponManagerComponent();
		if (weaponManager && !SCR_WeaponLib.CurrentWeaponHasComponent(weaponManager, SCR_MeleeWeaponProperties))
			return false;

		return true;
	}
	
	override bool GetCanEquipGadget(IEntity gadget)
	{
		SCR_CharacterCommandHandlerComponent handler = SCR_CharacterCommandHandlerComponent.Cast(GetAnimationComponent().GetCommandHandler());
		if (handler.IsLoitering() || GetScrInputContext().m_iLoiteringType != -1)
			return false;

		return true;		
	}

	//------------------------------------------------------------------------------------------------
	//! Override to handle what happens after pressing F button
	//! \return true to override default behaviour, false to use default behaviour - Perform Action key will immediately perform the action
	override bool OnPerformAction()
	{
		return m_bOverrideActions;
	}

	//------------------------------------------------------------------------------------------------
	override void OnInit(IEntity owner)
	{
		ChimeraCharacter character = GetCharacter();
		if (!character)
			return;

		if (!m_MeleeComponent)
			m_MeleeComponent = SCR_MeleeComponent.Cast(character.FindComponent(SCR_MeleeComponent));
		if (!m_CameraHandler)
			m_CameraHandler = SCR_CharacterCameraHandlerComponent.Cast(character.FindComponent(SCR_CharacterCameraHandlerComponent));

		#ifdef ENABLE_DIAG
		if (!m_AnimComponent)
			m_AnimComponent = CharacterAnimationComponent.Cast(character.FindComponent(CharacterAnimationComponent));
		#endif
		
		m_pScrInputContext = new SCR_ScriptedCharacterInputContext();
	}
	
	//------------------------------------------------------------------------------------------------
	protected override void OnApplyControls(IEntity owner, float timeSlice)
	{
		if (GetScrInputContext().m_iLoiteringType >= 0)
		{
			SCR_CharacterCommandHandlerComponent handler = SCR_CharacterCommandHandlerComponent.Cast(GetAnimationComponent().GetCommandHandler());
			if (!handler.IsLoitering())
			{
				if (TryStartLoiteringInternal())
					return;
			}
		}
	}

	//------------------------------------------------------------------------------------------------
	protected override void UpdateDrowning(float timeSlice, vector waterLevel)
	{
		ChimeraCharacter char = GetCharacter();
		if (!char)
			return;
		
		CompartmentAccessComponent accesComp = char.GetCompartmentAccessComponent();
		bool isInWatertightCompartment = accesComp && accesComp.GetCompartment() && accesComp.GetCompartment().GetIsWaterTight();

		const float drowningTimeStartFX = 4;
		if (waterLevel[2] > 0 && !isInWatertightCompartment)
		{
			if (m_fDrowningTime < drowningTimeStartFX && (m_fDrowningTime + timeSlice) > drowningTimeStartFX)
			{
				m_OnPlayerDrowning.Invoke(m_fDrowningDuration, drowningTimeStartFX);
				m_bCharacterIsDrowning = true;
			}
			
			m_fDrowningTime += timeSlice;
		}
		else
		{
			if (m_fDrowningTime != 0)
			{
				m_OnPlayerStopDrowning.Invoke();
				m_bCharacterIsDrowning = false;
			}

			m_fDrowningTime = 0;
			return;
		}

		SCR_CharacterDamageManagerComponent damageMan = SCR_CharacterDamageManagerComponent.Cast(char.GetDamageManager());
		if (!damageMan || !damageMan.GetResilienceHitZone())
			return;
		
		if (m_fDrowningTime > m_fDrowningDuration)
		{
			vector hitPosDirNorm[3];
			SCR_DamageContext context = new SCR_DamageContext(EDamageType.TRUE, 1000, hitPosDirNorm, char, damageMan.GetResilienceHitZone(), null, null, -1, -1);
			context.damageEffect = new SCR_DrowningDamageEffect();
			damageMan.HandleDamage(context);
			damageMan.Kill(Instigator.CreateInstigator(char));
		}
	}
	
	//------------------------------------------------------------------------------------------------
	//! \return
	float GetDrowningTime()
	{
		return m_fDrowningTime;
	}	
	
	//------------------------------------------------------------------------------------------------
	//! \return
	bool IsCharacterDrowning()
	{
		return m_bCharacterIsDrowning;
	}

	//------------------------------------------------------------------------------------------------
	override bool ShouldAligningAdjustAimingAngles()
	{
		return IsAligningBeforeLoiter();
	}
	
	//------------------------------------------------------------------------------------------------
	//! \return
	bool IsAligningBeforeLoiter()
	{
		return GetScrInputContext().m_iLoiteringType != -1 && GetScrInputContext().m_bLoiteringShouldAlignCharacter && GetAnimationComponent().GetHeadingComponent().IsAligning();
	}
	
	//------------------------------------------------------------------------------------------------
	// why the SCR_ prefix?
	override bool SCR_GetDisableMovementControls()
	{
		SCR_CharacterCommandHandlerComponent handler = SCR_CharacterCommandHandlerComponent.Cast(GetAnimationComponent().GetCommandHandler());
		if (!handler)
			return false;
		
		if (GetScrInputContext().m_iLoiteringType > 0)
		{
			bool isAligningBeforeLoiter = IsAligningBeforeLoiter();
			bool isHolsteringBeforeLoiter = GetScrInputContext().m_iLoiteringShouldHolsterWeapon && IsChangingItem();
			
			if (isAligningBeforeLoiter || isHolsteringBeforeLoiter)
				return true;
		}
		
		return handler.IsLoitering();
	}

	//------------------------------------------------------------------------------------------------
	override void SCR_OnDisabledJumpAction()
	{
		SCR_CharacterCommandHandlerComponent handler = SCR_CharacterCommandHandlerComponent.Cast(GetAnimationComponent().GetCommandHandler());
		if (!handler)
			return;
		
		if (handler.IsLoitering())
		{
			if (m_pScrInputContext.m_bLoiteringDisablePlayerInput)
				return;

			StopLoitering(false);
		}
		
		if (IsAligningBeforeLoiter())
		{
			CharacterHeadingAnimComponent headingComponent = GetAnimationComponent().GetHeadingComponent();
			if (headingComponent)
			{
				headingComponent.ResetAligning();
				GetScrInputContext().m_iLoiteringType = -1;
			}
		}
	}

	//------------------------------------------------------------------------------------------------
	// #ifdef ENABLE_DIAG
	//------------------------------------------------------------------------------------------------
	#ifdef ENABLE_DIAG
		//------------------------------------------------------------------------------------------------
		override void OnDiag(IEntity owner, float timeslice)
		{
			ChimeraCharacter character = GetCharacter();
			if (!character || IsDead())
				return;
			
			if (DiagMenu.GetBool(SCR_DebugMenuID.DEBUGUI_CHARACTER_NOBANKING))
				SetBanking(0);

			bool diagTransform = DiagMenu.GetBool(SCR_DebugMenuID.DEBUGUI_CHARACTER_TRANSFORMATION);
			bool bIsLocalCharacter = SCR_PlayerController.GetLocalControlledEntity() == character;

			// Character Transformation Diag
			if (bIsLocalCharacter && diagTransform)
			{
				DbgUI.Begin("Character Transformation");
				const string CHAR_POS = "X:\t%1\nY:\t%2\nZ:\t%3";
				const string CHAR_ROT = "PITCH:\t%1\nYAW:\t%2\nROLL:\t%3";
				const string CHAR_SCALE = "%1";
				const string CHAR_AIM = "X:\t%1\nY:\t%2\nZ:\t%3";
				vector pos = character.GetOrigin();
				vector rot = character.GetYawPitchRoll();
				float scale = character.GetScale();
				vector aimRot = GetInputContext().GetAimingAngles();
				string strPosition = string.Format(CHAR_POS, pos[0].ToString(), pos[1].ToString(), pos[2].ToString());
				string strRotation = string.Format(CHAR_ROT, rot[1].ToString(), rot[0].ToString(), rot[2].ToString());
				string strScale = string.Format(CHAR_SCALE, scale.ToString());
				string strAiming = string.Format(CHAR_AIM, aimRot[0].ToString(), aimRot[1].ToString(), aimRot[2].ToString());
				DbgUI.Text("POSITION:\n" + strPosition);
				DbgUI.Text("ROTATION:\n" + strRotation);
				DbgUI.Text("SCALE:" + strScale);
				DbgUI.Text("AIMING ANGLES:\n" + strAiming);

				if (DbgUI.Button("Print plaintext to console"))
					Print("TransformInfo:\nPOSITION:\n" + strPosition + "\nROTATION:\n" + strRotation + "\nSCALE:" + strScale + "\nAIMING ANGLES:\n" + strAiming, LogLevel.NORMAL);

				DbgUI.End();
			}

			// Character Controller diag (inputs...)
			m_bEnableDebugUI = bIsLocalCharacter && DiagMenu.GetBool(SCR_DebugMenuID.DEBUGUI_CHARACTER_MENU);
			if (m_bEnableDebugUI && !m_wDebugRootWidget) // Currently controlled player
				CreateDebugUI();
			else if (!m_bEnableDebugUI && m_wDebugRootWidget)
				DeleteDebugUI();

			if (m_bEnableDebugUI)
				UpdateDebugUI();
		}

		//------------------------------------------------------------------------------------------------
		private void ReloadDebugUI()
		{
			if (m_wDebugRootWidget)
				DeleteDebugUI();

			CreateDebugUI();
		}

		//------------------------------------------------------------------------------------------------
		private void DeleteDebugUI()
		{
			m_wDebugRootWidget.RemoveFromHierarchy();
			m_wDebugRootWidget = null;
		}

		//------------------------------------------------------------------------------------------------
		private void UpdateInputCircles()
		{
			if (!m_wDebugRootWidget || !m_AnimComponent)
				return;

			Widget wInput = m_wDebugRootWidget.FindAnyWidget("Input");
			if (!wInput)
				return;

			WorkspaceWidget workspaceWidget = GetGame().GetWorkspace();

			float topSpeed = m_AnimComponent.GetTopSpeed(-1, false);

			TextWidget wMaxSpeed = TextWidget.Cast(wInput.FindAnyWidget("MaxSpeed"));
			if (wMaxSpeed)
			{
				float speed = Math.Ceil(topSpeed * 10) * 0.1;
				wMaxSpeed.SetText(speed.ToString() + "m/s");
			}

			float ringSize = FrameSlot.GetSizeX(wInput);
			float degSizeDivider = topSpeed * ringSize;
			if (degSizeDivider > 0)
			for (int spd = 0; spd < 3; spd++)
			{
				int spdType;
				if (spd == 0)
					spdType = EMovementType.WALK;
				else
				if (spd == 1)
					spdType = EMovementType.RUN;
				else
				if (spd == 2)
					spdType = EMovementType.SPRINT;

				int color;
				if (spd == 0)
					color = ARGB(255, 150, 255, 150);
				else
				if (spd == 1)
					color = ARGB(255, 200, 200, 150);
				else
				if (spd == 2)
					color = ARGB(255, 255, 150, 150);

				for (int deg = 0; deg < 360; deg++)
				{
					vector velInput = GetMovementVelocity();
					float inputForward = velInput[2];
					float inputRight = velInput[0];

					float degSize = m_AnimComponent.GetMaxSpeed(inputForward, inputRight, spdType) / degSizeDivider;
					if (spdType == EMovementType.SPRINT && !IsSprinting())
						degSize = 0;

					float degOff = (ringSize - degSize) * 0.5;

					string iRingname = "iRing_" + spd.ToString() + "_" + deg.ToString();

					ImageWidget wImg = ImageWidget.Cast(wInput.FindAnyWidget(iRingname));
					if (!wImg)
					{
						wImg = ImageWidget.Cast(workspaceWidget.CreateWidget(WidgetType.ImageWidgetTypeID, WidgetFlags.BLEND | WidgetFlags.VISIBLE | WidgetFlags.STRETCH | WidgetFlags.NOWRAP, Color.FromInt(color), spd + 2, wInput));
						wImg.LoadImageTexture(0, "{90DF4F065D08EF4E}UI/Textures/HUD_obsolete/character/input_360ringslice.edds");
						wImg.SetRotation(deg);
						wImg.SetName(iRingname);
					}

					FrameSlot.SetAnchorMax(wImg, 0, 0);
					FrameSlot.SetAnchorMin(wImg, 0, 0);
					FrameSlot.SetSize(wImg, degSize, degSize);
					FrameSlot.SetPos(wImg, degOff, degOff);
				}
			}
		}

		//------------------------------------------------------------------------------------------------
		private void CreateDebugUI()
		{
			m_wDebugRootWidget = GetGame().GetWorkspace().CreateWidgets("{C70DA11469BBAF67}UI/layouts/Debug/HUD_Debug_Character.layout", null);
			UpdateInputCircles();
		}

		//------------------------------------------------------------------------------------------------
		private void UpdateDebugBoolWidget(string textWidgetName, bool isTrue, float time = 0)
		{
			TextWidget wTxt = TextWidget.Cast(m_wDebugRootWidget.FindAnyWidget(textWidgetName));
			if (!wTxt)
				return;

			time = Math.Ceil(time * 10) * 0.1;
			if (isTrue)
			{
				wTxt.SetColorInt(ARGB(255, 160, 210, 255));
				if (time != 0)
					wTxt.SetText("YES (" + time.ToString() + ")");
				else
					wTxt.SetText("YES");
			}
			else
			{
				wTxt.SetColorInt(ARGB(255, 255, 160, 160));
				if (time != 0)
					wTxt.SetText("NO (" + time.ToString() + ")");
				else
					wTxt.SetText("NO");
			}
		}

		//------------------------------------------------------------------------------------------------
		private void UpdateDebugUI()
		{
			ChimeraCharacter character = GetCharacter();

			// Reload debug UI for stance change
			if (m_bDebugLastStance != GetStance())
			{
				m_bDebugLastStance = GetStance();
				UpdateInputCircles();
			}

			float topSpeed = 0;
			if (m_AnimComponent)
				topSpeed = m_AnimComponent.GetTopSpeed(-1, false);

			Widget wCenter = m_wDebugRootWidget.FindAnyWidget("Center");
			Widget wCenter2 = m_wDebugRootWidget.FindAnyWidget("Center2");
			Widget wCenter3 = m_wDebugRootWidget.FindAnyWidget("Center3");

			vector movementInput = GetMovementInput();
			if (movementInput != vector.Zero)
			{
				float inputLength = movementInput.Length();
				if (inputLength > 1)
					movementInput *= 1 / inputLength;
			}

			if (wCenter && wCenter2 && wCenter3 && topSpeed > 0)
			{
				float inputForward = movementInput[0];
				float inputRight = movementInput[2];
				float maxSpeed = m_AnimComponent.GetMaxSpeed(inputForward, inputRight, GetCurrentMovementPhase());
				float moveScale = maxSpeed / topSpeed;
				float x = movementInput[0] * moveScale * 0.5 + 0.5;
				float y = -movementInput[2] * moveScale * 0.5 + 0.5;
				FrameSlot.SetAnchorMin(wCenter, x, y);
				FrameSlot.SetAnchorMax(wCenter, x, y);

				vector moveLocal = m_AnimComponent.GetInertiaSpeed();
				x = (moveLocal[0] / topSpeed) * 0.5 + 0.5;
				y = (-moveLocal[2] / topSpeed) * 0.5 + 0.5;
				FrameSlot.SetAnchorMin(wCenter2, x, y);
				FrameSlot.SetAnchorMax(wCenter2, x, y);

				moveLocal = character.VectorToLocal(GetVelocity());
				x = (moveLocal[0] / topSpeed) * 0.5 + 0.5;
				y = (-moveLocal[2] / topSpeed) * 0.5 + 0.5;
				FrameSlot.SetAnchorMin(wCenter3, x, y);
				FrameSlot.SetAnchorMax(wCenter3, x, y);
			}

			TextWidget wSpeed = TextWidget.Cast(m_wDebugRootWidget.FindAnyWidget("Speed"));
			TextWidget wSpeed2 = TextWidget.Cast(m_wDebugRootWidget.FindAnyWidget("Speed2"));
			if (wSpeed && wSpeed2)
			{
				float speed = Math.Ceil(m_AnimComponent.GetInertiaSpeed().Length() * 10) * 0.1;
				wSpeed.SetText(speed.ToString() + "m/s");

				speed = Math.Ceil(GetVelocity().Length() * 10) * 0.1;
				wSpeed2.SetText(speed.ToString() + "m/s");
			}

			TextWidget wAdjustedSpeed = TextWidget.Cast(m_wDebugRootWidget.FindAnyWidget("AdjustedSpeed"));
			if (wAdjustedSpeed)
				wAdjustedSpeed.SetText(GetDynamicSpeed().ToString());

			TextWidget wAdjustedStance = TextWidget.Cast(m_wDebugRootWidget.FindAnyWidget("AdjustedStance"));
			if (wAdjustedStance)
				wAdjustedStance.SetText(GetDynamicStance().ToString());

			UpdateDebugBoolWidget("ToggleSprint", GetIsSprintingToggle());
			UpdateDebugBoolWidget("IsInADS", IsWeaponADS());
			UpdateDebugBoolWidget("IsWeaponHolstered", !IsWeaponRaised());
			UpdateDebugBoolWidget("CanFireWeapon", GetCanFireWeapon());
			UpdateDebugBoolWidget("CanThrow", GetCanThrow());
			UpdateDebugBoolWidget("InFreeLook", IsFreeLookEnabled());

			TextWidget wMovementAngle = TextWidget.Cast(m_wDebugRootWidget.FindAnyWidget("MovementAngle"));
			CharacterCommandHandlerComponent handler = m_AnimComponent.GetCommandHandler();
			if (!wMovementAngle || !handler)
				return;

			CharacterCommandMove moveCmd = handler.GetCommandMove();
			if (moveCmd)
			{
				float currAngle = moveCmd.GetMovementSlopeAngle();
				wMovementAngle.SetText(currAngle.ToString() + "deg");
			}
		}

	//------------------------------------------------------------------------------------------------
	// #endif ENABLE_DIAG
	//------------------------------------------------------------------------------------------------
	#endif

	//------------------------------------------------------------------------------------------------
	override void OnPrepareControls(IEntity owner, ActionManager am, float dt, bool player)
	{
		if (am.GetActionTriggered("JumpOut") && CanJumpOutVehicleScript())
		{
			ChimeraCharacter character = ChimeraCharacter.Cast(owner);
			CompartmentAccessComponent compAccess = character.GetCompartmentAccessComponent();
			
			BaseCompartmentSlot compartment = compAccess.GetCompartment();
			if (compartment)
			{
				CompartmentUserAction action = compartment.GetJumpOutAction();
				if (action && action.CanBePerformed(GetOwner()))
				{
					action.PerformAction(compartment.GetOwner(), GetOwner());
					return;
				}

				// Add the following once the correct action exists
				//if (!action && compAccess.CanGetOutVehicle())
				//{
				//	compAccess.GetOutVehicle(-1);
				//}
			}			
		}
		
		if (am.GetActionTriggered("GetOut") && CanGetOutVehicleScript())
		{
			ChimeraCharacter character = ChimeraCharacter.Cast(owner);
			CompartmentAccessComponent compAccess = character.GetCompartmentAccessComponent();
			
			BaseCompartmentSlot compartment = compAccess.GetCompartment();
			if (compartment)
			{
				CompartmentUserAction action = compartment.GetGetOutAction();
				if (action && action.CanBePerformed(GetOwner()))
				{
					action.PerformAction(compartment.GetOwner(), GetOwner());
					return;
				}

				if (!action && compAccess.CanGetOutVehicle())
				{
					compAccess.GetOutVehicle(EGetOutType.ANIMATED, -1, ECloseDoorAfterActions.INVALID, false);
				}
			}
		}

		if (GetStance() == ECharacterStance.PRONE)
		{
			float value = am.GetActionValue("CharacterRoll");
			int rollValue = 0;
			if (value < -0.5)
				rollValue = 1;
			else if (value > 0.5)
				rollValue = 2;

			// If one wants to use hold action - it needs too be allowed on CharacterControllerComponent at character prefab or by calling EnableHoldInputForRoll(true) during construction/initialization
			if (ShouldHoldInputForRoll())
				SetRoll(rollValue);
			else if (rollValue != 0)
				SetRoll(rollValue);
		}
	}

	//------------------------------------------------------------------------------------------------
	// constructor
	//! \param[in] src
	//! \param[in] ent
	//! \param[in] parent
	void SCR_CharacterControllerComponent(IEntityComponentSource src, IEntity ent, IEntity parent)
	{
		#ifdef ENABLE_DIAG
		if (System.IsCLIParam("CharacterDebugUI")) // If the startup parameter is set, enable the debug UI
			m_bEnableDebugUI = true;

		if (!s_bDiagRegistered)
		{
			DiagMenu.RegisterBool(SCR_DebugMenuID.DEBUGUI_CHARACTER_MENU, "", "Enable Debug UI", "Character");
			DiagMenu.SetValue(SCR_DebugMenuID.DEBUGUI_CHARACTER_MENU, m_bEnableDebugUI);
			DiagMenu.RegisterBool(SCR_DebugMenuID.DEBUGUI_CHARACTER_NOBANKING, "", "Disable Banking", "Character");
			DiagMenu.RegisterBool(SCR_DebugMenuID.DEBUGUI_CHARACTER_TRANSFORMATION, "", "Enable transform info", "Character");
			DiagMenu.RegisterBool(SCR_DebugMenuID.DEBUGUI_CHARACTER_RECOIL_CAMERASHAKE_DISABLE, "", "Disable recoil cam shake", "Character");
			DiagMenu.RegisterBool(SCR_DebugMenuID.DEBUGUI_CHARACTER_ADDITIONAL_CAMERASHAKE_DISABLE, "", "Disable additional cam shake", "Character");
			DiagMenu.RegisterBool(SCR_DebugMenuID.DEBUGUI_CHARACTER_CAMERASHAKE_TEST_WINDOW, "", "Show shake diag", "Character");
			DiagMenu.RegisterBool(SCR_DebugMenuID.DEBUGUI_WEAPONS_ALLOW_INSPECTION_LOOKAT, "", "Inspection LookAt", "Character");
			s_bDiagRegistered = true;
		}
		#endif
	}

	//------------------------------------------------------------------------------------------------
	// destructor
	void ~SCR_CharacterControllerComponent()
	{
		#ifdef ENABLE_DIAG
		if (m_wDebugRootWidget)
			DeleteDebugUI();
		#endif
	}

	//------------------------------------------------------------------------------------------------
	//! If a weapon with sights is equipped, advances to desired sights FOV info.
	//! \param[in] direction If above zero, advances to next info. If equal to or below zero, advances to previous info.
	//! \param[in] allowCycling If enabled, selection will cycle from end to start and from start to end, otherwise it will be clamped.
	void SetNextSightsFOVInfo(int direction = 1, bool allowCycling = false)
	{
		if (direction == 0)
			return;

		SightsFOVInfo fovInfo = GetSightsFOVInfo();
		if (!fovInfo)
			return;

		SCR_BaseVariableSightsFOVInfo variableFovInfo = SCR_BaseVariableSightsFOVInfo.Cast(fovInfo);
		if (!variableFovInfo)
			return;

		if (direction > 0)
			variableFovInfo.SetNext(allowCycling);
		else
			variableFovInfo.SetPrevious(allowCycling);
	}

	//------------------------------------------------------------------------------------------------
	//! If a weapon with multiple sights is equipped, switch the next or previous sights on the weapon (if any)
	//! \param[in] direction If above zero, advances to next sights. If equal to or below zero, advances to previous sights.
	void SetNextSights(int direction = 1)
	{
		// Check if we are in a turret and switch the turret's optics instead
		SCR_ChimeraCharacter character = SCR_ChimeraCharacter.Cast(GetOwner());
		CompartmentAccessComponent compartmentAccess = character.GetCompartmentAccessComponent();
		if (compartmentAccess)
		{
			BaseCompartmentSlot compartment = compartmentAccess.GetCompartment();
			if (compartment)
			{
				TurretControllerComponent turretController = TurretControllerComponent.Cast(compartment.GetController());
				if (turretController)
				{
					TurretComponent turretComponent = turretController.GetTurretComponent();
					if (turretComponent)
					{
						if (direction > 0)
							turretComponent.SwitchNextSights();
						else 
							turretComponent.SwitchPrevSights();
					
						return;
					}
				}
			}
		}
		
		BaseWeaponManagerComponent weaponManager = GetWeaponManagerComponent();
		if (!weaponManager)
			return;

		BaseWeaponComponent weaponComponent = weaponManager.GetCurrentWeapon();
		if (!weaponComponent)
			return;

		if (direction > 0)
			weaponComponent.SwitchNextSights();
		else
			weaponComponent.SwitchPrevSights();
	}

	//------------------------------------------------------------------------------------------------
	//! \return currently used SightsFOVInfo if any, null otherwise.
	SightsFOVInfo GetSightsFOVInfo()
	{
		BaseWeaponManagerComponent weaponManager = GetWeaponManagerComponent();
		if (!weaponManager)
			return null;

		BaseWeaponComponent weaponComponent = weaponManager.GetCurrentWeapon();
		if (!weaponComponent)
			return null;

		BaseSightsComponent sightsComponent = weaponComponent.GetSights();
		if (!sightsComponent)
			return null;

		return sightsComponent.GetFOVInfo();
	}

	//------------------------------------------------------------------------------------------------
	protected override void OnControlledByPlayer(IEntity owner, bool controlled)
	{
		// Do initialisation/deinitialisation of character that was given/lost control by plyer here
		if (controlled && owner == SCR_PlayerController.GetLocalControlledEntity())
		{
			GetGame().GetInputManager().AddActionListener("CharacterNextWeapon", EActionTrigger.DOWN, ActionNextWeapon);
			GetGame().GetInputManager().AddActionListener("CharacterUnequipItem", EActionTrigger.DOWN, ActionUnequipItem);
			GetGame().GetInputManager().AddActionListener("CharacterDropItem", EActionTrigger.DOWN, ActionDropItem);
			GetGame().GetInputManager().AddActionListener("CharacterWeaponLowReady", EActionTrigger.DOWN, ActionWeaponLowReady);
			GetGame().GetInputManager().AddActionListener("CharacterWeaponRaised", EActionTrigger.DOWN, ActionWeaponRaised);
			GetGame().GetInputManager().AddActionListener("CharacterWeaponBipod", EActionTrigger.DOWN, ActionWeaponBipod);

			// TODO: This should be handled by camera handler itself
			if (m_CameraHandler)
				GetGame().GetInputManager().AddActionListener("SwitchCameraType", EActionTrigger.DOWN, m_CameraHandler.OnCameraSwitchPressed);
		}
		else
		{
			GetGame().GetInputManager().RemoveActionListener("CharacterNextWeapon", EActionTrigger.DOWN, ActionNextWeapon);
			GetGame().GetInputManager().RemoveActionListener("CharacterUnequipItem", EActionTrigger.DOWN, ActionUnequipItem);
			GetGame().GetInputManager().RemoveActionListener("CharacterDropItem", EActionTrigger.DOWN, ActionDropItem);
			GetGame().GetInputManager().RemoveActionListener("CharacterWeaponLowReady", EActionTrigger.DOWN, ActionWeaponLowReady);
			GetGame().GetInputManager().RemoveActionListener("CharacterWeaponRaised", EActionTrigger.DOWN, ActionWeaponRaised);
			GetGame().GetInputManager().RemoveActionListener("CharacterWeaponBipod", EActionTrigger.DOWN, ActionWeaponBipod);

			// TODO: This should be handled by camera handler itself
			if (m_CameraHandler)
				GetGame().GetInputManager().RemoveActionListener("SwitchCameraType", EActionTrigger.DOWN, m_CameraHandler.OnCameraSwitchPressed);
		}

		m_OnControlledByPlayer.Invoke(owner, controlled);

		// diiferentiate the inventory setup for player and AI
		SCR_CharacterInventoryStorageComponent pCharInvComponent = SCR_CharacterInventoryStorageComponent.Cast(owner.FindComponent(SCR_CharacterInventoryStorageComponent));
		if (pCharInvComponent)
			pCharInvComponent.InitAsPlayer(owner, controlled);
	}

	//------------------------------------------------------------------------------------------------
	//! Alternate between primary weapons
	//! \param[in] value
	//! \param[in] trigger
	void ActionNextWeapon(float value = 0.0, EActionTrigger trigger = 0)
	{
		CharacterInputContext inputContext = GetInputContext();
		if (inputContext && inputContext.IsThrowCanceled())
		{
			inputContext.SetThrow(false);
			return;
		}

		SCR_InventoryStorageManagerComponent storageManager = SCR_InventoryStorageManagerComponent.Cast(GetInventoryStorageManager());
		if (!storageManager)
			return;

		SCR_CharacterInventoryStorageComponent storage = storageManager.GetCharacterStorage();
		if (storage)
			storage.SelectNextWeapon();
	}

	//------------------------------------------------------------------------------------------------
	//! Put current item away to inventory/back
	//! \param[in] value
	//! \param[in] trigger
	void ActionUnequipItem(float value = 0.0, EActionTrigger trigger = 0)
	{
		SCR_InventoryStorageManagerComponent storageManager = SCR_InventoryStorageManagerComponent.Cast(GetInventoryStorageManager());
		if (!storageManager)
			return;

		SCR_CharacterInventoryStorageComponent storage = storageManager.GetCharacterStorage();
		if (storage)
			storage.UnequipCurrentItem();
	}

	//------------------------------------------------------------------------------------------------
	//! Drop current item on ground
	//! \param[in] value
	//! \param[in] trigger
	void ActionDropItem(float value = 0.0, EActionTrigger trigger = 0)
	{
		SCR_InventoryStorageManagerComponent storageManager = SCR_InventoryStorageManagerComponent.Cast(GetInventoryStorageManager());
		if (!storageManager)
			return;

		SCR_CharacterInventoryStorageComponent storage = storageManager.GetCharacterStorage();
		if (storage)
			storage.DropCurrentItem();
	}

	//------------------------------------------------------------------------------------------------
	//!
	//! \param[in] value
	//! \param[in] trigger
	void ActionWeaponLowReady(float value = 0.0, EActionTrigger trigger = 0)
	{
		if (GetIsWeaponDeployed())
			return;

		if (GetIsWeaponDeployedBipod())
			return;

		if (CanPartialLower() && !IsPartiallyLowered())
			SetPartialLower(true);
	}

	//------------------------------------------------------------------------------------------------
	//!
	//! \param[in] value
	//! \param[in] trigger
	void ActionWeaponRaised(float value = 0.0, EActionTrigger trigger = 0)
	{
		if (!IsWeaponRaised())
			SetWeaponRaised(true);

		if (IsPartiallyLowered())
			SetPartialLower(false);
	}

	//------------------------------------------------------------------------------------------------
	//!
	//! \param[in] value
	//! \param[in] trigger
	void ActionWeaponBipod(float value = 0.0, EActionTrigger trigger = 0)
	{
		BaseWeaponManagerComponent weaponManager = GetWeaponManagerComponent();
		if (!weaponManager)
			return;

		BaseWeaponComponent weapon = weaponManager.GetCurrentWeapon();
		if (!weapon || !weapon.HasBipod())
			return;

		if (GetIsWeaponDeployed() || GetIsWeaponDeployedBipod())
			StopDeployment();

		weapon.SetBipod(!weapon.GetBipod());
	}

	//------------------------------------------------------------------------------------------------
	protected override void OnInspectionModeChanged(bool newState)
	{
		m_bInspectionFocus = newState;
	}

	protected int m_iTargetContext;

	//------------------------------------------------------------------------------------------------
	protected override float GetInspectTargetLookAt(out vector targetAngles)
	{
		#ifdef ENABLE_DIAG
		if (!DiagMenu.GetBool(SCR_DebugMenuID.DEBUGUI_WEAPONS_ALLOW_INSPECTION_LOOKAT))
			return 0;
		#else
			return 0; // Disabled for now
		#endif

		// Just for testing
		if (Debug.KeyState(KeyCode.KC_ADD))
		{
			++m_iTargetContext;
			Debug.ClearKey(KeyCode.KC_ADD);
			m_bInspectionFocus = true;
		}

		if (Debug.KeyState(KeyCode.KC_SUBTRACT))
		{
			--m_iTargetContext;
			Debug.ClearKey(KeyCode.KC_SUBTRACT);
			m_bInspectionFocus = true;
		}

		if (!m_bInspectionFocus)
			return 0;

		vector aimChange = GetInputContext().GetAimChange();
		const float threshold = 0.001;
		if (Math.AbsFloat(aimChange[0]) > threshold || Math.AbsFloat(aimChange[1]) > threshold)
		{
			m_bInspectionFocus = false;
			return 0;
		} // not now

		IEntity ent = GetInspectEntity();
		if (!ent)
			return 0;

		SCR_InteractionHandlerComponent handler = SCR_InteractionHandlerComponent.Cast(GetGame().GetPlayerController().FindComponent(SCR_InteractionHandlerComponent));
		if (!handler)
			return 0;

		// Update target
		array<UserActionContext> contexts = {};
		vector tmp;
		array<IEntity> ents = handler.GetManualOverrideList(null, tmp);
		ActionsManagerComponent ac;
		array<UserActionContext> buff;
		UserActionContext ctx;
		array<BaseUserAction> actions;
		foreach (IEntity e : ents)
		{
			ac = ActionsManagerComponent.Cast(e.FindComponent(ActionsManagerComponent));
			if (!ac)
				continue;

			buff = {};
			int bc = ac.GetContextList(buff);
			for (int i = 0; i < bc; ++i)
			{
				ctx = buff[i];
				if (ctx.GetActionsCount() == 0)
					continue;

				actions = {};
				int actionsCount = ctx.GetActionsList(actions);
				foreach (BaseUserAction action : actions)
				{
					if (action.CanBeShown(GetCharacter()))
					{
						contexts.Insert(ctx);
						break;
					}
				}
			}
		}

		int nonEmptyCount = contexts.Count();
		m_iTargetContext = Math.Repeat(m_iTargetContext, nonEmptyCount);

		if (nonEmptyCount == 0)
			return 0.0;

		ctx = contexts[m_iTargetContext];
		vector contextPos = ctx.GetOrigin();

		vector localAimDirection = GetHeadAimingComponent().GetAimingDirection();
		vector targetDirection = contextPos - GetCharacter().EyePosition();
		vector localTargetDirection = GetCharacter().VectorToLocal( targetDirection );
		localTargetDirection.Normalize();

		float lookYaw = Math.Sin(localTargetDirection[0]) * Math.RAD2DEG;
		float lookPitch = Math.Sin(localTargetDirection[1]) * Math.RAD2DEG;

		//Shape shape = Shape.CreateSphere(COLOR_RED, ShapeFlags.ONCE | ShapeFlags.NOZBUFFER, contextPos, 0.01);

		lookPitch -= GetAimingComponent().GetAimingDirection()[1];
		targetAngles = Vector(lookYaw, lookPitch, 0) * Math.DEG2RAD;

		return 4.30 * Math.RAD2DEG ; // speed, approx deg/s
	}
	
	//------------------------------------------------------------------------------------------------
	//! \return
	SCR_ScriptedCharacterInputContext GetScrInputContext()
	{
		return m_pScrInputContext;
	}
	
	//------------------------------------------------------------------------------------------------
	//!
	//! \param[in] loiteringType
	//! \param[in] holsterWeapon
	//! \param[in] allowRootMotion
	//! \param[in] alignToPosition
	//! \param[in] targetPosition
	//! \param[in] disableInput - If true, player cannot interrupt the loiter by pressing space. It is the responsibility of the caller to ensure that the action will be finished. If false, action can be cancelled by player input.
	//! \param[in] customAnimData - data for playing custom animation in graph attachment
	void StartLoitering(int loiteringType, bool holsterWeapon, bool allowRootMotion, bool alignToPosition, vector targetPosition[4] = { "1 0 0", "0 1 0", "0 0 1", "0 0 0" }, bool disableInput = false,
		SCR_LoiterCustomAnimData customAnimData = SCR_LoiterCustomAnimData.Default)
	{
		if (GetCharacter().GetRplComponent() && !GetCharacter().GetRplComponent().IsOwner())
			return;
		
		SCR_CharacterCommandHandlerComponent scrCmdHandler = SCR_CharacterCommandHandlerComponent.Cast(GetCharacter().GetAnimationComponent().GetCommandHandler());
		if (!scrCmdHandler)
			return;

		if (!scrCmdHandler.GetCommandMove())
			return;
		
		m_pScrInputContext.m_iLoiteringType = loiteringType;
		m_pScrInputContext.m_iLoiteringShouldHolsterWeapon = holsterWeapon;
		m_pScrInputContext.m_bLoiteringShouldAlignCharacter = alignToPosition;
		m_pScrInputContext.m_bLoiteringDisablePlayerInput = disableInput;
		m_pScrInputContext.m_mLoiteringPosition = targetPosition;
		m_pScrInputContext.m_bLoiteringRootMotion = allowRootMotion;
		m_pScrInputContext.m_CustomAnimData = customAnimData;
		
		if (IsGadgetInHands())
			RemoveGadgetFromHand(true);
		
		if (alignToPosition)
			AlignToPositionFromCurrentPosition(targetPosition);
		
		TryStartLoiteringInternal();
	}
	
	//------------------------------------------------------------------------------------------------
	protected bool AlignToPositionFromCurrentPosition(vector targetPosition[4], float toleranceXZ = 0.01, float toleranceY = 0.01)
	{
		if (GetCharacter().GetRplComponent() && !GetCharacter().GetRplComponent().IsOwner())
			return false;
		
		vector currentTransform[4];
		GetCharacter().GetWorldTransform(currentTransform);
		CharacterHeadingAnimComponent headingComponent = GetAnimationComponent().GetHeadingComponent();
		if (headingComponent)
			headingComponent.AlignPosDirWS(currentTransform[3], currentTransform[2], targetPosition[3], targetPosition[2]); 

		return vector.DistanceSqXZ(currentTransform[3], targetPosition[3]) < (toleranceXZ * toleranceXZ)
			&& Math.AbsFloat(currentTransform[3][2] - targetPosition[3][2]) < toleranceY;
	}
	
	//------------------------------------------------------------------------------------------------
	[RplRpc(RplChannel.Reliable, RplRcver.Server)]
	protected void Rpc_StartLoitering_S(int loiteringType, bool holsterWeapon, bool allowRootMotion, bool alignToPosition, vector targetPosition[4], SCR_LoiterCustomAnimData customAnimData)
	{
		m_pScrInputContext.m_iLoiteringType = loiteringType;
		m_pScrInputContext.m_iLoiteringShouldHolsterWeapon = holsterWeapon;
		m_pScrInputContext.m_bLoiteringShouldAlignCharacter = alignToPosition;
		m_pScrInputContext.m_mLoiteringPosition = targetPosition;
		m_pScrInputContext.m_bLoiteringRootMotion = allowRootMotion;
		m_pScrInputContext.m_CustomAnimData = customAnimData;
		
		SCR_CharacterCommandHandlerComponent scrCmdHandler = SCR_CharacterCommandHandlerComponent.Cast(GetCharacter().GetAnimationComponent().GetCommandHandler());
		scrCmdHandler.StartCommandLoitering(customAnimData);

		Rpc(Rpc_StartLoitering_BCNO,
				m_pScrInputContext.m_iLoiteringType,
				m_pScrInputContext.m_iLoiteringShouldHolsterWeapon,
				m_pScrInputContext.m_bLoiteringRootMotion,
				m_pScrInputContext.m_bLoiteringShouldAlignCharacter,
				m_pScrInputContext.m_mLoiteringPosition,
				m_pScrInputContext.m_CustomAnimData);
	}
	
	//------------------------------------------------------------------------------------------------
	[RplRpc(RplChannel.Reliable, RplRcver.Broadcast, RplCondition.NoOwner)]
	protected void Rpc_StartLoitering_BCNO(int loiteringType, bool holsterWeapon, bool allowRootMotion, bool alignToPosition, vector targetPosition[4],	SCR_LoiterCustomAnimData customAnimData)
	{
		m_pScrInputContext.m_iLoiteringType = loiteringType;
		m_pScrInputContext.m_iLoiteringShouldHolsterWeapon = holsterWeapon;
		m_pScrInputContext.m_bLoiteringShouldAlignCharacter = alignToPosition;
		m_pScrInputContext.m_mLoiteringPosition = targetPosition;
		m_pScrInputContext.m_bLoiteringRootMotion = allowRootMotion;
		m_pScrInputContext.m_CustomAnimData = customAnimData;
		
		SCR_CharacterCommandHandlerComponent scrCmdHandler = SCR_CharacterCommandHandlerComponent.Cast(GetCharacter().GetAnimationComponent().GetCommandHandler());
		scrCmdHandler.StartCommandLoitering(customAnimData);
	}
	
	//------------------------------------------------------------------------------------------------
	protected bool TryStartLoiteringInternal()
	{
		if (IsChangingItem())
			return false;
		
		if (GetScrInputContext().m_iLoiteringShouldHolsterWeapon && GetCurrentItemInHands() != null)
		{
			TryEquipRightHandItem(null, EEquipItemType.EEquipTypeUnarmedContextual);
			return false;
		}
		
		if(m_pScrInputContext.m_bLoiteringShouldAlignCharacter)
		{
			CharacterHeadingAnimComponent headingComponent = GetAnimationComponent().GetHeadingComponent();
			if (headingComponent && headingComponent.IsAligning())
			{
				if (AlignToPositionFromCurrentPosition(GetScrInputContext().m_mLoiteringPosition, 0.02, 0.3)) // distance smaller than 2cm
					return false;
			}
		}
		
		SCR_CharacterCommandHandlerComponent scrCmdHandler = SCR_CharacterCommandHandlerComponent.Cast(GetCharacter().GetAnimationComponent().GetCommandHandler());
		scrCmdHandler.StartCommandLoitering(m_pScrInputContext.m_CustomAnimData);
		
		if (GetCharacter().GetRplComponent() && GetCharacter().GetRplComponent().IsProxy())
			Rpc(Rpc_StartLoitering_S,
				m_pScrInputContext.m_iLoiteringType,
				m_pScrInputContext.m_iLoiteringShouldHolsterWeapon,
				m_pScrInputContext.m_bLoiteringRootMotion,
				m_pScrInputContext.m_bLoiteringShouldAlignCharacter,
				m_pScrInputContext.m_mLoiteringPosition,
				m_pScrInputContext.m_CustomAnimData);
			else
			Rpc(Rpc_StartLoitering_BCNO,
				m_pScrInputContext.m_iLoiteringType,
				m_pScrInputContext.m_iLoiteringShouldHolsterWeapon,
				m_pScrInputContext.m_bLoiteringRootMotion,
				m_pScrInputContext.m_bLoiteringShouldAlignCharacter,
				m_pScrInputContext.m_mLoiteringPosition,
				m_pScrInputContext.m_CustomAnimData);
		
		return true;
	}
	
	//------------------------------------------------------------------------------------------------
	//!
	//! \param[in] terminateFast should be true when going into alerted or combat state.
	[RplRpc(RplChannel.Reliable, RplRcver.Server)]
	void RPC_StopLoitering_S(bool terminateFast)
	{
		SCR_CharacterCommandHandlerComponent scrCmdHandler = SCR_CharacterCommandHandlerComponent.Cast(GetCharacter().GetAnimationComponent().GetCommandHandler());
		scrCmdHandler.StopLoitering(terminateFast);
	}
	
	//------------------------------------------------------------------------------------------------
	//!
	//! \param[in] terminateFast
	//terminateFast should be true when we are going into alerted or combat state.
	void StopLoitering(bool terminateFast)
	{
		if (GetCharacter().GetRplComponent() && !GetCharacter().GetRplComponent().IsOwner())
			return;
		
		SCR_CharacterCommandHandlerComponent scrCmdHandler = SCR_CharacterCommandHandlerComponent.Cast(GetCharacter().GetAnimationComponent().GetCommandHandler());
		scrCmdHandler.StopLoitering(terminateFast);
		
		if (GetCharacter().GetRplComponent() && GetCharacter().GetRplComponent().IsProxy())
			Rpc(RPC_StopLoitering_S, terminateFast);
	}
	
	//------------------------------------------------------------------------------------------------
	bool IsLoitering()
	{
		SCR_CharacterCommandHandlerComponent handler = SCR_CharacterCommandHandlerComponent.Cast(GetAnimationComponent().GetCommandHandler());
		if (!handler)
			return false;
		else
			return handler.IsLoitering();		
	}
}

enum ECharacterGestures // TODO: SCR_
{
	NONE = 0,
	POINT_WITH_FINGER = 1
}

#ifdef GMSTATS 
#define GM_AI_STATS
#endif
#ifdef AISTATS
#define GM_AI_STATS
#endif

/**
@defgroup GameMode Game Mode
Game modes.
*/
class SCR_BaseGameModeClass: BaseGameModeClass
{
};

/// @ingroup GameMode
//------------------------------------------------------------------------------------------------
/*
											SCR_BaseGameMode

Brief:
	SCR_BaseGameMode is the skeleton of all game modes which connects some of the critical aspects of spawning.

Important:
	A. Components and expansion:
		1. SCR_BaseGameMode automatically gathers all attached components of SCR_BaseGameModeComponent type.
		These can be used to receive events from the game mode and expand game mode functionality in modular blocks.

		2. SCR_RespawnSystemComponent is a component that allows to store and select player faction, loadout and spawn points
		This system is closely tied to game modes and also requires FactionManager or LoadoutManager in the world.

		3. SCR_RespawnHandlerComponent is a component that provides a game mode with a way of respawning.
		These can be either very generic (automatic, menu selection) and interchangable or completely game mode specific.

		4. Additional components like
			SCR_RespawnTimerComponent: That allows to add a timer between each respawn
			SCR_ScoringSystemComponent: That allows handling of score when a player kills or is killed


	If you want to make a system which only requires to hook on game mode events, SCR_BaseGameMode is most likely the way to go.
	Inherit the component and implement methods which you require. If you need to have a very game specific implementation that
	cannot work standalone you will have to inherit SCR_BaseGameMode and plug the communication yourself.


	B. Instances and logic:
		1. SCR_BaseGameMode is a unique entity in the world, there can currently be only one game mode.
		2. SCR_RespawnSystemComponent is a unique component attached to the game mode, there can currently be only one respawn system.
		3. SCR_RespawnHandlerComponent is a unique component attached to the game mode, there can currently be only one respawn handler.
		4. SCR_RespawnComponent is a component attached to individual PlayerController instances.
			Due to the nature of PlayerController, only the server can access all RespawnComponent(s).
			The local client will always be only to access their local RespawnComponent.

			For the local component you can use GetGame().GetPlayerController().GetRespawnComponent();
			For other clients as the authority you can use GetGame().GetPlayerManager().GetPlayerRespawnComponent( int playerId );

			This component serves as communication between the authority and client for the SCR_RespawnSystemComponent.
			If you need to request a faction, loadout or spawn point selection as the client, navigate through the component.

			If you need to SET a faction, loadout or spawn point as the AUTHORITY, use SCR_RespawnSystemComponent's
			DoSetPlayerFaction, DoSetPlayerLoadout and DoSetPlayerSpawnPoint method(s).

			If you need to convert object instances to their id/indices, you can use SCR_RespawnSystemComponent's
			GetFactionIndex, GetLoadoutIndex, GetSpawnPointIndex method(s) and/or
			GetFactionByIndex, GetLoadoutByIndex, GetSpawnPointByIdentity.


	C. Game State
		There are three game states in total that you can use, two of which are optional.
			1. Pre-game:
				This state is automatically skipped unless a
					SCR_BaseGameModeStateComponent that has SCR_EGameModeState.PREGAME as its affiliated state
				is attached to the game mode.

				The SCR_PreGameGameModeStateComponent can be used to allow a time-based pre-game duration.

			2. Game
				This is the core game loop.

				By default this state is infinite, unless a
					SCR_BaseGameModeStateComponent that has SCR_EGameModeState.GAME as its affiliated state
				is attached to the game mode with a duration set.

				The SCR_GameGameModeStateComponent can be used to allow a time-based pre-game duration.

			3. Post-game
				This is your game-over state, you can automatically transition into new world, restart the session,
				have player voting, display scoreboard or end-game screens, as desired.

				In addition this transition carries along SCR_GameModeEndData, providing the authority and all
				clients with additional data that can notify the gamemode about e.g. win condition, or end reason
				as implemented per game mode.

				This state can also have its logic expanded similarly to the Pre-game by using
					SCR_BaseGameModeStateComponent that has SCR_EGameModeState.POSTGAME as its affiliated state
				attached to the game mode.

				The SCR_PostGameGameModeStateComponent can be used for this.


		You can always retrieve current game state by calling GetState() (see SCR_GameModeState)
		or IsRunning() if you're interested in the core game loop only.

		On each state change SCR_BaseGameMode.OnGameStateChanged() is called on both the server and all clients.
		In additionaly as implemented in this class it will automatically call OnGameModeStart() and OnGameModeEnd()
		based on the state the game is transitioning into.
*/

//------------------------------------------------------------------------------------------------
//~ ScriptInvokers
void SCR_BaseGameMode_OnPlayerDisconnected(int playerId, KickCauseCode cause = KickCauseCode.NONE, int timeout = -1);
typedef func SCR_BaseGameMode_OnPlayerDisconnected;

//~ Player or controllable entity was killed/destroyed
void SCR_BaseGameMode_OnControllableDestroyed(notnull SCR_InstigatorContextData instigatorContextData);
typedef func SCR_BaseGameMode_OnControllableDestroyed;

//~ Generic Event that sends over player ID
void SCR_BaseGameMode_PlayerId(int playerId);
typedef func SCR_BaseGameMode_PlayerId;

//~ Generic event that sends over player ID and Entity
void SCR_BaseGameMode_PlayerIdAndEntity(int playerId, IEntity player);
typedef func SCR_BaseGameMode_PlayerIdAndEntity;

//~ On Player role changed
void SCR_BaseGameMode_OnPlayerRoleChanged(int playerId, EPlayerRole roleFlags);
typedef func SCR_BaseGameMode_OnPlayerRoleChanged;

void SCR_BaseGameMode_OnResourceEnabledChanged(array<EResourceType> disabledResourceTypes);
typedef func SCR_BaseGameMode_OnResourceEnabledChanged;

void OnPreloadFinished();
typedef func OnPreloadFinished;
typedef ScriptInvokerBase<OnPreloadFinished> OnPreloadFinishedInvoker;


//------------------------------------------------------------------------------------------------
class SCR_BaseGameMode : BaseGameMode
{
	#ifdef ENABLE_DIAG
	#define GAME_MODE_DEBUG
	#endif

	#ifdef GAME_MODE_DEBUG
		static bool s_DebugRegistered = false;
	#endif

	const static string WB_GAME_MODE_CATEGORY = "Game Mode";

	protected ref ScriptInvoker Event_OnGameStart = new ScriptInvoker();
	protected ref ScriptInvoker m_OnGameEnd = new ScriptInvoker();
	
	//~ Player events
	protected ref ScriptInvokerBase<SCR_BaseGameMode_PlayerId> m_OnPlayerAuditSuccess = new ScriptInvokerBase<SCR_BaseGameMode_PlayerId>();
	protected ref ScriptInvokerBase<SCR_BaseGameMode_PlayerId> m_OnPlayerAuditFail = new ScriptInvokerBase<SCR_BaseGameMode_PlayerId>();
	protected ref ScriptInvokerBase<SCR_BaseGameMode_PlayerId> m_OnPlayerAuditTimeouted = new ScriptInvokerBase<SCR_BaseGameMode_PlayerId>();
	protected ref ScriptInvokerBase<SCR_BaseGameMode_PlayerId> m_OnPlayerAuditRevived = new ScriptInvokerBase<SCR_BaseGameMode_PlayerId>();
	protected ref ScriptInvokerBase<SCR_BaseGameMode_PlayerId> m_OnPlayerConnected = new ScriptInvokerBase<SCR_BaseGameMode_PlayerId>();
	protected ref ScriptInvokerBase<SCR_BaseGameMode_PlayerId> m_OnPlayerRegistered = new ScriptInvokerBase<SCR_BaseGameMode_PlayerId>();
	protected ref ScriptInvokerBase<SCR_BaseGameMode_OnPlayerDisconnected> m_OnPlayerDisconnected = new ScriptInvokerBase<SCR_BaseGameMode_OnPlayerDisconnected>();
	protected ref ScriptInvokerBase<SCR_BaseGameMode_OnPlayerDisconnected> m_OnPostCompPlayerDisconnected = new ScriptInvokerBase<SCR_BaseGameMode_OnPlayerDisconnected>(); //~ Called after the GameMode Components are notified that a player was disconnected
	protected ref ScriptInvokerBase<SCR_BaseGameMode_PlayerIdAndEntity> m_OnPlayerSpawned = new ScriptInvokerBase<SCR_BaseGameMode_PlayerIdAndEntity>();
	protected ref ScriptInvokerBase<SCR_BaseGameMode_OnControllableDestroyed> m_OnPlayerKilled = new ScriptInvokerBase<SCR_BaseGameMode_OnControllableDestroyed>();
	protected ref ScriptInvokerBase<SCR_BaseGameMode_OnControllableDestroyed> m_OnControllableDestroyed = new ScriptInvokerBase<SCR_BaseGameMode_OnControllableDestroyed>();
	protected ref ScriptInvokerBase<SCR_BaseGameMode_PlayerIdAndEntity> m_OnPlayerDeleted = new ScriptInvokerBase<SCR_BaseGameMode_PlayerIdAndEntity>();
	protected ref ScriptInvokerBase<SCR_BaseGameMode_OnPlayerRoleChanged> m_OnPlayerRoleChange = new ScriptInvokerBase<SCR_BaseGameMode_OnPlayerRoleChanged>();
	
	protected ref ScriptInvoker m_OnWorldPostProcess = new ScriptInvoker();
	protected ref ScriptInvoker m_OnControllableSpawned = new ScriptInvoker();
	protected ref ScriptInvoker m_OnControllableDeleted = new ScriptInvoker();
	protected ref ScriptInvoker m_OnGameModeEnd = new ScriptInvoker();
	
	protected ref ScriptInvokerBase<SCR_BaseGameMode_OnResourceEnabledChanged> m_OnResourceTypeEnabledChanged;

	protected SCR_EPauseReason m_ePauseReasons;
	
	//-----------------------------------------
	//
	// World Editor attributes meant for Debug or Testing
	//
	[Attribute("0", uiwidget: UIWidgets.Flags, "Test Game Flags for when you run mission via WE.", "", ParamEnumArray.FromEnum(EGameFlags), WB_GAME_MODE_CATEGORY)]
	protected EGameFlags m_eTestGameFlags;

	[Attribute("1", uiwidget: UIWidgets.CheckBox, "When false, then Game mode need to handle its very own spawning. If true, then simple default logic is used to spawn and respawn automatically.", category: WB_GAME_MODE_CATEGORY)]
	protected bool m_bAutoPlayerRespawn;
	
	[Attribute("1", uiwidget: UIWidgets.CheckBox, "When true, allows players to freely swap their faction after initial assignment.", category: WB_GAME_MODE_CATEGORY)]
	protected bool m_bAllowFactionChange;
	
	[Attribute("30", UIWidgets.Slider, params: "0 600 1", desc: "Time in seconds after which the mission is reloaded upon completion or 0 to disable it.", category: WB_GAME_MODE_CATEGORY)]
	private float m_fAutoReloadTime;
	
	//-----------------------------------------
	//
	// Game End Screen States info
	//

	//! Current state of this gamemode.
	[RplProp(onRplName: "OnGameStateChanged")]
	private SCR_EGameModeState m_eGameState = SCR_EGameModeState.PREGAME;

	//! End data provided by the server when game ends.
	[RplProp()]
	private ref SCR_GameModeEndData m_pGameEndData = new SCR_GameModeEndData();

	[Attribute("1", uiwidget: UIWidgets.CheckBox, "If checked the elapsed time will only advance if at least one player is present on the server.", category: WB_GAME_MODE_CATEGORY)]
	protected bool m_bAdvanceTimeRequiresPlayers;

	/*!
		Elapsed time from the beginning of the game mode in seconds.
		NOTE: This does not correspond to the length of session but rather to the length of current game mode loop.
	*/
	[RplProp(condition: RplCondition.NoOwner)]
	protected float m_fTimeElapsed;

	//! If false, controls are disable for the time being.
	[RplProp()]
	protected bool m_bAllowControls = true;

	//! Interval of time synchronization in seconds
	protected float m_fTimeCorrectionInterval = 10.0;

	//! Last timestamp of sent time correction for the server.
	protected float m_fLastTimeCorrection;
	
	//! Is the session hosted by a player?
	[RplProp()]
	protected bool m_bIsHosted;

	//-----------------------------------------
	//
	// Required components
	//
	protected RplComponent m_RplComponent;
	protected SCR_GameModeHealthSettings m_pGameModeHealthSettings;
	protected SCR_RespawnSystemComponent m_pRespawnSystemComponent;
	protected SCR_BaseScoringSystemComponent m_ScoringSystemComponent;
	protected SCR_RespawnTimerComponent m_RespawnTimerComponent;

	/*!
		Additional game mode components attached to this gamemode where we dispatch all our game mode related events to.
	*/
	protected ref array<SCR_BaseGameModeComponent> m_aAdditionalGamemodeComponents = new array<SCR_BaseGameModeComponent>();

	//! Used on server to respawn player on their original position after reconnecting.
	protected ref map<int, vector> m_mPlayerSpawnPosition = new map<int, vector>();

	//! Map of components per state.
	protected ref map<SCR_EGameModeState, SCR_BaseGameModeStateComponent> m_mStateComponents = new map<SCR_EGameModeState, SCR_BaseGameModeStateComponent>();

	//! Spawn location preload
	[Attribute("1", category: WB_GAME_MODE_CATEGORY)]
	protected bool m_bUseSpawnPreload;

	protected ref SCR_SpawnPreload m_SpawnPreload;
	protected ref OnPreloadFinishedInvoker m_OnPreloadFinished;
	
	//~ Any Resource types that is set here is a disabled resource type
	[Attribute(desc: "List of disabled Resource Types in the GameMode.", uiwidget: UIWidgets.SearchComboBox, enums: ParamEnumArray.FromEnum(EResourceType), category: "Game Mode"), RplProp(onRplName: "OnResourceTypeEnabledChanged")]
	protected ref array<EResourceType> m_aDisabledResourceTypes;
	
	//~ Time stamp when end game was called
	protected WorldTimestamp m_GameEndTimeStamp = null;

	//------------------------------------------------------------------------------------------------
	//! \return If resource are enabled or not
	bool IsResourceTypeEnabled(EResourceType resourceType = EResourceType.SUPPLIES)
	{
		return !m_aDisabledResourceTypes.Contains(resourceType);
	}
	
	//------------------------------------------------------------------------------------------------
	//! \param[out] disabledResourceTypes Disabled resource types
	//! \return the count of all disabled resource types
	int GetDisabledResourceTypes(inout notnull array<EResourceType> disabledResourceTypes)
	{
		disabledResourceTypes.Copy(m_aDisabledResourceTypes);
		return disabledResourceTypes.Count();
	}
	
	//------------------------------------------------------------------------------------------------
	//! Change if supplies are enabled or not
	//! \param[in] enable Set true to enable supplies, set false to disable
	//! \param[in] resourceType Type of resource to enable
	//! \param[in] Player ID of player that enabled supplies for the game mode (For notifications)
	void SetResourceTypeEnabled(bool enable, EResourceType resourceType = EResourceType.SUPPLIES, int playerID = -1)
	{
		int index = m_aDisabledResourceTypes.Find(resourceType);
		
		//~ Already Enabled/Disabled
		if ((index < 0) == enable)
			return;
		
		if (!enable)
			m_aDisabledResourceTypes.Insert(resourceType);
		else 
			m_aDisabledResourceTypes.Remove(index);
		
		Replication.BumpMe();
		
		//~ Call on resourceType changed for server as well
		if (IsMaster())
			OnResourceTypeEnabledChanged();
		
		if (resourceType == EResourceType.SUPPLIES)
		{
			if (enable)
				SCR_NotificationsComponent.SendToEveryone(ENotification.EDITOR_ATTRIBUTES_ENABLE_GLOBAL_SUPPLY_USAGE, playerID);
			else 
				SCR_NotificationsComponent.SendToEveryone(ENotification.EDITOR_ATTRIBUTES_DISABLE_GLOBAL_SUPPLY_USAGE, playerID);
		}
	}
	
	//------------------------------------------------------------------------------------------------
	//! \Called when Global Supplies is set to enabled or disabled (Server and client)
	protected void OnResourceTypeEnabledChanged()
	{
		if (m_OnResourceTypeEnabledChanged)
			m_OnResourceTypeEnabledChanged.Invoke(m_aDisabledResourceTypes);
	}
	
	//------------------------------------------------------------------------------------------------
	//! \return ScriptInvoker OnSupplies Enabled
	ScriptInvokerBase<SCR_BaseGameMode_OnResourceEnabledChanged> GetOnResourceTypeEnabledChanged()
	{
		if (!m_OnResourceTypeEnabledChanged)
			m_OnResourceTypeEnabledChanged = new ScriptInvokerBase<SCR_BaseGameMode_OnResourceEnabledChanged>();
		
		return m_OnResourceTypeEnabledChanged;
	}
	
	//------------------------------------------------------------------------------------------------
	bool CanStartSpawnPreload()
	{
		ChimeraWorld world = GetGame().GetWorld();
		return (!world.IsGameTimePaused() && m_bUseSpawnPreload);
	}

	//------------------------------------------------------------------------------------------------
	/*!
		Returns whether current game mode is running its game loop.
		\return True in case gamemode is running, false if it is over.
	*/
	bool IsRunning()
	{
		return m_eGameState == SCR_EGameModeState.GAME;
	}

	//------------------------------------------------------------------------------------------------
	/*!
		Returns current game state. See SCR_GameModeState for more details.
		\return Current game state.
	*/
	SCR_EGameModeState GetState()
	{
		return m_eGameState;
	}

	//------------------------------------------------------------------------------------------------
	/*!
		Returns whether the owner of this instance is authority or not.
	*/
	sealed bool IsMaster()
	{
		return (!m_RplComponent || m_RplComponent.IsMaster());
	}

	//------------------------------------------------------------------------------------------------
	/*!
		Returns elapsed time from the start of this game in seconds.
		\return Elapsed time in seconds.
	*/
	float GetElapsedTime()
	{
		return m_fTimeElapsed;
	}

	//------------------------------------------------------------------------------------------------
	/*!
		Returns the game duration from the start of game in seconds or 0 if none.
		\return Maximum time in seconds or 0 if infinite.
	*/
	float GetTimeLimit()
	{
		SCR_BaseGameModeStateComponent stateComponent = GetStateComponent(SCR_EGameModeState.GAME);
		if (stateComponent)
			return stateComponent.GetDuration();

		return 0.0;
	}

	//------------------------------------------------------------------------------------------------
	/*!
		Returns the remaining time of this game in seconds or -1 if none or undefined.
		\return Remaining time of this game.
	*/
	float GetRemainingTime()
	{
		float timeLimit = GetTimeLimit();
		if (!IsRunning() || timeLimit <= 0)
			return -1;

		float time = timeLimit - GetElapsedTime();
		if (time < 0)
			time = 0;

		return time;
	}
	
	//------------------------------------------------------------------------------------------------
	/*!
		\return True if the game is hosted by a player (i.e., not dedicated server)
	*/
	bool IsHosted()
	{
		return m_bIsHosted;
	}

	//------------------------------------------------------------------------------------------------
	/*!
		Called when game state changed, i.e. when game ends. Can be used to display post-scenario scoreboard
		and prepare for next match if any. See IsRunning() for new state.
	*/
	protected void OnGameStateChanged()
	{
		SCR_EGameModeState newState = GetState();
		Print("SCR_BaseGameMode::OnGameStateChanged = " + SCR_Enum.GetEnumName(SCR_EGameModeState, newState));

		//We handle the OnGameModeEnd and OnGameModeStart events here
		//Because this is the only replicated call.
		//And we propagate it to the components here for robusty in case of overriding those methods
		switch (newState)
		{
			case SCR_EGameModeState.POSTGAME:
				OnGameModeEnd(m_pGameEndData);
				foreach (SCR_BaseGameModeComponent component : m_aAdditionalGamemodeComponents)
				{
					component.OnGameModeEnd(m_pGameEndData);
				}
				break;
			
			case SCR_EGameModeState.GAME:
				OnGameModeStart();
				foreach (SCR_BaseGameModeComponent component : m_aAdditionalGamemodeComponents)
				{
					component.OnGameModeStart();
				}
				break;
		}

		// Dispatch events
		foreach (SCR_BaseGameModeComponent component : m_aAdditionalGamemodeComponents)
		{
			component.OnGameStateChanged(newState);
		}
	}

	//------------------------------------------------------------------------------------------------
	void CachePlayerSpawnPosition(int playerID, vector position)
	{
		m_mPlayerSpawnPosition.Set(playerID, position);
	}

	//------------------------------------------------------------------------------------------------
	/*!
		Returns respawn system component attached to this gamemode.
		\return Returns attached respawn system instance or null if none.
	*/
	SCR_RespawnSystemComponent GetRespawnSystemComponent()
	{
		return m_pRespawnSystemComponent;
	}
	
	//------------------------------------------------------------------------------------------------
	SCR_GameModeHealthSettings GetGameModeHealthSettings()
	{
		return m_pGameModeHealthSettings;
	}

	//------------------------------------------------------------------------------------------------
	/*!
		Returns scoring system component attached to this game mode or null if none.
		\return Returns attached scoring system instance or null if none.
	*/
	SCR_BaseScoringSystemComponent GetScoringSystemComponent()
	{
		return m_ScoringSystemComponent;
	}

	//------------------------------------------------------------------------------------------------
	/*!
		Server-only call that starts current session.
		Replicates state to all clients, see GetState() and IsRunning().
	*/
	void StartGameMode()
	{
		if (!IsMaster())
			return;

		if (IsRunning())
		{
			Print("Trying to start a gamemode that is already running.", LogLevel.WARNING);
			return;
		}

		m_fTimeElapsed = 0.0;
		m_eGameState = SCR_EGameModeState.GAME;
		Replication.BumpMe();

		// Raise event for authority
		OnGameStateChanged();
	}

	//------------------------------------------------------------------------------------------------
	/*!
		Server-only logic that implements whether we can transition from pre-game (if enabled)
		to game loop. Requires an attached SCR_BaseGameModeStateComponent affiliated to the
		SCR_EGameModeState.PREGAME state.

		Does not apply to manual StartGameMode() call from the authority!

		\return Returns true in case pre-game can end and game can start or false otherwise.
	*/
	protected bool CanStartGameMode()
	{
		SCR_BaseGameModeStateComponent pregame = GetStateComponent(SCR_EGameModeState.PREGAME);
		if (!pregame)
			return true;

		return pregame.CanAdvanceState(SCR_EGameModeState.GAME);
	}

	//------------------------------------------------------------------------------------------------
	/*!
		Server-only call that marks current session as complete.
		Replicates state to all clients, see GetState() and IsRunning().

		\param SCR_GameModeEndData the data this game mode ends with. When null, fallback to default is used.
		All machines can reach this data in the OnGameModeEnd(SCR_GameModeEndData) method.
	*/
	void EndGameMode(SCR_GameModeEndData endData)
	{
		if (!IsMaster())
			return;

		// Already over
		if (!IsRunning())
		{
			Print("Trying to end a gamemode that is not running.", LogLevel.WARNING);
			return;
		}

		if (endData == null)
			endData = SCR_GameModeEndData.CreateSimple();

		m_pGameEndData = endData;
		m_eGameState = SCR_EGameModeState.POSTGAME;
		Replication.BumpMe();

		// Raise event for authority
		OnGameStateChanged();
	}

	/*!
		Get end game data will return null if game has not ended
		\return SCR_GameModeEndData m_pGameEndData the data this game mode ends with
	*/
	SCR_GameModeEndData GetEndGameData()
	{
		if (m_eGameState != SCR_EGameModeState.POSTGAME)
			return null;
		else
			return m_pGameEndData;
	}

	ScriptInvoker GetOnGameStart()
	{
		return Event_OnGameStart;
	}
	ScriptInvoker GetOnGameEnd()
	{
		return m_OnGameEnd;
	}
	ScriptInvokerBase<SCR_BaseGameMode_PlayerId> GetOnPlayerAuditSuccess()
	{
		return m_OnPlayerAuditSuccess;
	}
	ScriptInvokerBase<SCR_BaseGameMode_PlayerId> GetOnPlayerAuditFail()
	{
		return m_OnPlayerAuditFail;
	}
	ScriptInvokerBase<SCR_BaseGameMode_PlayerId> GetOnPlayerAuditTimeouted()
	{
		return m_OnPlayerAuditTimeouted;
	}
	ScriptInvokerBase<SCR_BaseGameMode_PlayerId> GetOnPlayerAuditRevived()
	{
		return m_OnPlayerAuditRevived;
	}
	ScriptInvokerBase<SCR_BaseGameMode_PlayerId> GetOnPlayerConnected()
	{
		return m_OnPlayerConnected;
	}
	ScriptInvokerBase<SCR_BaseGameMode_PlayerId> GetOnPlayerRegistered()
	{
		return m_OnPlayerRegistered;
	}
	ScriptInvokerBase<SCR_BaseGameMode_OnPlayerDisconnected> GetOnPlayerDisconnected()
	{
		return m_OnPlayerDisconnected;
	}
	/*!
	Called on player disconnect and after Gamemode components are notified
	\return Script invoker
	*/
	ScriptInvokerBase<SCR_BaseGameMode_OnPlayerDisconnected> GetOnPostCompPlayerDisconnected()
	{
		return m_OnPostCompPlayerDisconnected;
	}
	ScriptInvokerBase<SCR_BaseGameMode_PlayerIdAndEntity> GetOnPlayerSpawned()
	{
		return m_OnPlayerSpawned;
	}
	ScriptInvokerBase<SCR_BaseGameMode_OnControllableDestroyed> GetOnPlayerKilled()
	{
		return m_OnPlayerKilled;
	}
	ScriptInvokerBase<SCR_BaseGameMode_PlayerIdAndEntity> GetOnPlayerDeleted()
	{
		return m_OnPlayerDeleted;
	}
	ScriptInvokerBase<SCR_BaseGameMode_OnPlayerRoleChanged> GetOnPlayerRoleChange()
	{
		return m_OnPlayerRoleChange;
	}
	ScriptInvoker GetOnWorldPostProcess()
	{
		return m_OnWorldPostProcess;
	}
	ScriptInvoker GetOnControllableSpawned()
	{
		return m_OnControllableSpawned;
	}
	ScriptInvokerBase<SCR_BaseGameMode_OnControllableDestroyed> GetOnControllableDestroyed()
	{
		return m_OnControllableDestroyed;
	}
	ScriptInvoker GetOnControllableDeleted()
	{
		return m_OnControllableDeleted;
	}
	/*!
	Get on game end script invoker called on every machine
	\return ScriptInvoker Event_OnGameModeEnd
	*/
	ScriptInvoker GetOnGameModeEnd()
	{
		return m_OnGameModeEnd;
	}

	//------------------------------------------------------------------------------------------------
	/*!
		Called on every machine when game mode starts by OnGameStateChanged.
		This can be immediate (if no pre-game period is set) or can happen after
		a certain delay, as deemed appropriate by the authority.
	*/
	protected void OnGameModeStart()
	{
		#ifdef GM_AI_STATS
		if (IsGameModeStatisticsEnabled())
		{
			if (!SCR_GameModeStatistics.IsRecording())
				SCR_GameModeStatistics.StartRecording();
		}
		#endif
	}

	//------------------------------------------------------------------------------------------------
	/*!
		Called on every machine when game mode ends by OnGameStateChanged.
		This can be based on time limit or as deemed appropriate by the authority,
		e.g. after reaching certain score threshold and similar.
		\param SCR_GameModeEndData optional game mode end data received from the server.
	*/
	protected void OnGameModeEnd(SCR_GameModeEndData endData)
	{
		ChimeraWorld world = GetGame().GetWorld();
		if (world)
			m_GameEndTimeStamp = world.GetLocalTimestamp();
		
		m_OnGameModeEnd.Invoke(endData);

		#ifdef GM_AI_STATS
		if (IsGameModeStatisticsEnabled())
		{
			if (SCR_GameModeStatistics.IsRecording())
				SCR_GameModeStatistics.StopRecording();
		}
		#endif
		
		// Automatically restart the session on game mode end if enabled
		float reloadTime = GetAutoReloadDelay();
		if (reloadTime > 0)
			GetGame().GetCallqueue().CallLater(RestartSession, reloadTime * 1000.0, false);	
	}
	
	//------------------------------------------------------------------------------------------------
	/*!
		Returns local timestamp when endgame was called
	*/
	WorldTimestamp GetGameEndTimeStamp()
	{
		return m_GameEndTimeStamp;
	}
	
	//------------------------------------------------------------------------------------------------
	/*!
		Returns delay of mission reload (if enabled) in seconds or else 0 if disabled.
	*/
	float GetAutoReloadDelay()
	{
		// Allow the server owner to override it via -autoReload=TIME
		string autoReloadTimeString;
		if (System.GetCLIParam("autoreload", autoReloadTimeString))
			return Math.Clamp(autoReloadTimeString.ToFloat(), 0.0, 600.0);

		return m_fAutoReloadTime;
	}

	/*!
		Reloads current session (authority only).
	*/
	protected void RestartSession()
	{
		if (!IsMaster())
			return;
		
		Print("SCR_BaseGameMode::RequestScenarioRestart()", LogLevel.DEBUG);
		if (GameStateTransitions.RequestScenarioRestart())
		{
			Print("SCR_BaseGameMode::RequestScenarioRestart() successfull server reload requested!", LogLevel.DEBUG);
		}
	}

	//------------------------------------------------------------------------------------------------
	protected override void OnGameStart()
	{
		BackendApi backendApi = GetGame().GetBackendApi();
		
		if (IsMaster())
			backendApi.NewSession();

		super.OnGameStart();
		Event_OnGameStart.Invoke();
	}

	//------------------------------------------------------------------------------------------------
	void OnGameEnd()
	{
		m_OnGameEnd.Invoke();

		foreach (SCR_BaseGameModeComponent comp : m_aAdditionalGamemodeComponents)
		{
			comp.OnGameEnd();
		}
	}
	
	//------------------------------------------------------------------------------------------------
	bool IsFactionChangeAllowed()
	{
		return m_bAllowFactionChange;
	}

	//------------------------------------------------------------------------------------------------
	override void OnPlayerAuditSuccess(int iPlayerID)
	{
	#ifdef RESPAWN_COMPONENT_VERBOSE
			Print("SCR_BaseGameMode::OnPlayerAuditSuccess - playerId: " + iPlayerID, LogLevel.DEBUG);
	#endif

		super.OnPlayerAuditSuccess(iPlayerID);
		m_OnPlayerAuditSuccess.Invoke(iPlayerID);
		
		// Dispatch event to child components
		foreach (SCR_BaseGameModeComponent comp : m_aAdditionalGamemodeComponents)
		{
			comp.OnPlayerAuditSuccess(iPlayerID);
		}
	}

	//------------------------------------------------------------------------------------------------
	override void OnPlayerAuditFail(int iPlayerID)
	{
	#ifdef RESPAWN_COMPONENT_VERBOSE
		Print("SCR_BaseGameMode::OnPlayerAuditFail - playerId: " + iPlayerID, LogLevel.DEBUG);
	#endif

		super.OnPlayerAuditFail(iPlayerID);
		m_OnPlayerAuditFail.Invoke(iPlayerID);
		
		// Dispatch event to child components
		foreach (SCR_BaseGameModeComponent comp : m_aAdditionalGamemodeComponents)
		{
			comp.OnPlayerAuditFail(iPlayerID);
		}
	}
	
	//------------------------------------------------------------------------------------------------
	override void OnPlayerAuditTimeouted( int iPlayerID) 
	{
		super.OnPlayerAuditTimeouted(iPlayerID);
		m_OnPlayerAuditTimeouted.Invoke(iPlayerID);
		
		// Dispatch event to child components
		foreach (SCR_BaseGameModeComponent comp : m_aAdditionalGamemodeComponents)
		{
			comp.OnPlayerAuditTimeouted(iPlayerID);
		}
	};

	//------------------------------------------------------------------------------------------------
	override void OnPlayerAuditRevived( int iPlayerID) 
	{
		super.OnPlayerAuditRevived(iPlayerID);
		m_OnPlayerAuditRevived.Invoke(iPlayerID);
		
		// Dispatch event to child components
		foreach (SCR_BaseGameModeComponent comp : m_aAdditionalGamemodeComponents)
		{
			comp.OnPlayerAuditRevived(iPlayerID);
		}
	};

	//------------------------------------------------------------------------------------------------
	/*!
		Called after a player is connected. Server-only.
		\param playerId PlayerId of connected player.
	*/
	override void OnPlayerConnected(int playerId)
	{
		if (!m_bIsHosted)
		{
			m_bIsHosted = GetGame().GetPlayerManager().GetPlayerController(playerId).GetRplIdentity() == RplIdentity.Local();
			Replication.BumpMe();
		}
		
		super.OnPlayerConnected(playerId);
		m_OnPlayerConnected.Invoke(playerId);
		
		// TODO: Please revisit and adjust this, this check results in some nasty branching and possible oversights/errors
		// Wait for backend response if dedicated server is used and is not run without backend functionality
		if (m_pRespawnSystemComponent && (RplSession.Mode() != RplMode.Dedicated || System.IsCLIParam("nobackend")))
		{
		#ifdef RESPAWN_COMPONENT_VERBOSE
			Print("SCR_BaseGameMode::OnPlayerConnected - playerId: " + playerId, LogLevel.DEBUG);
		#endif
		}

		// Dispatch event to child components
		foreach (SCR_BaseGameModeComponent comp : m_aAdditionalGamemodeComponents)
		{
			comp.OnPlayerConnected(playerId);
		}

		// DON'T! Leave that up to game mode respawning
		// SetPlayerRandomLoadout(playerId);

		#ifdef TREE_DESTRUCTION
		int count = SCR_DestructibleTree.DestructibleTrees.Count();
		for (int i = 0; i < count; i++)
		{
			SCR_DestructibleTree.DestructibleTrees[i].OnPlayerConnected();
		}
		#endif
	}

	//------------------------------------------------------------------------------------------------
	/*!
		Called after a player is disconnected.
		\param playerId PlayerId of disconnected player.
	*/
	protected override void OnPlayerDisconnected(int playerId, KickCauseCode cause, int timeout)
	{
		super.OnPlayerDisconnected(playerId, cause, timeout);
		m_OnPlayerDisconnected.Invoke(playerId, cause, timeout);
		
		// RespawnSystemComponent is not a SCR_BaseGameModeComponent, so for now we have to
		// propagate these events manually. 
		if (IsMaster())
			m_pRespawnSystemComponent.OnPlayerDisconnected_S(playerId, cause, timeout);

		foreach (SCR_BaseGameModeComponent comp : m_aAdditionalGamemodeComponents)
		{
			comp.OnPlayerDisconnected(playerId, cause, timeout);
		}
		
		m_OnPostCompPlayerDisconnected.Invoke(playerId, cause, timeout);

		if (IsMaster())
		{
			IEntity controlledEntity = GetGame().GetPlayerManager().GetPlayerControlledEntity(playerId);
			if (controlledEntity)
			{
				if (SCR_ReconnectComponent.GetInstance() && SCR_ReconnectComponent.GetInstance().IsReconnectEnabled())
				{
					if (SCR_ReconnectComponent.GetInstance().OnPlayerDC(playerId, cause))	// if conditions to allow reconnect pass, skip the entity delete  
					{
						CharacterControllerComponent charController = CharacterControllerComponent.Cast(controlledEntity.FindComponent(CharacterControllerComponent));
						if (charController)
						{
							charController.SetMovement(0, vector.Forward);
						}
						
						CompartmentAccessComponent compAccess = CompartmentAccessComponent.Cast(controlledEntity.FindComponent(CompartmentAccessComponent)); // TODO nullcheck
						if (compAccess)
						{
							BaseCompartmentSlot compartment = compAccess.GetCompartment();
							if (compartment)
							{
								CarControllerComponent carController = CarControllerComponent.Cast(compartment.GetVehicle().FindComponent(CarControllerComponent));
								if (carController)
								{
									carController.Shutdown();
									carController.StopEngine(false);
								}
							}
						}
						
						return;
					}
				}
				
				RplComponent.DeleteRplEntity(controlledEntity, false);
			}
		}
	}

	//------------------------------------------------------------------------------------------------
	/*!
		Called on every machine after a player is registered (identity, name etc.). Always called after OnPlayerConnected.
		\param playerId PlayerId of registered player.
	*/
	protected override void OnPlayerRegistered(int playerId)
	{
		super.OnPlayerRegistered(playerId);
		m_OnPlayerRegistered.Invoke(playerId);
		
		// RespawnSystemComponent is not a SCR_BaseGameModeComponent, so for now we have to
		// propagate these events manually. 
		if (IsMaster())
			m_pRespawnSystemComponent.OnPlayerRegistered_S(playerId);

		foreach (SCR_BaseGameModeComponent comp : m_aAdditionalGamemodeComponents)
		{
			comp.OnPlayerRegistered(playerId);
		}

		#ifdef GMSTATS
		if (IsGameModeStatisticsEnabled())
			SCR_GameModeStatistics.RecordConnection(playerId, GetGame().GetPlayerManager().GetPlayerName(playerId));
		#endif
	}

	//------------------------------------------------------------------------------------------------
	/*!
		Called after a player is spawned.
		\param playerId PlayerId of spawned player.
		\param controlledEntity Spawned entity for this player.
	*/
	[Obsolete("Use SCR_BaseGameMode.OnPlayerSpawnFinalize_S")]
	protected override void OnPlayerSpawned(int playerId, IEntity controlledEntity)
	{
		super.OnPlayerSpawned(playerId, controlledEntity);
		m_OnPlayerSpawned.Invoke(playerId, controlledEntity);

		foreach (SCR_BaseGameModeComponent comp : m_aAdditionalGamemodeComponents)
		{
			comp.OnPlayerSpawned(playerId, controlledEntity);
		}

		#ifdef GMSTATS
		if (IsGameModeStatisticsEnabled())
		{
			FactionAffiliationComponent fac = FactionAffiliationComponent.Cast(controlledEntity.FindComponent(FactionAffiliationComponent));
			SCR_GameModeStatistics.RecordSpawn(playerId, fac.GetAffiliatedFaction().GetFactionColor().PackToInt());
		}
		#endif
	}
	
	//------------------------------------------------------------------------------------------------
	protected override bool HandlePlayerKilled(int playerId, IEntity playerEntity, IEntity killerEntity, notnull Instigator killer)
	{		
		foreach (SCR_BaseGameModeComponent comp : m_aAdditionalGamemodeComponents)
		{
			// First component that returns false overrides the behaviour and can handle
			// the kill based on their respective needs
			if (!comp.HandlePlayerKilled(playerId, playerEntity, killerEntity, killer))
			{
				OnPlayerKilledHandled(playerId, playerEntity, killerEntity, killer);
				return false;
			}
		}
		
		// Handle automatically
		return true;
	}
	
	//------------------------------------------------------------------------------------------------
	//! Default player kill behaviour. Called when a player is killed (and HandlePlayerKilled returns true).
	protected override void OnPlayerKilled(int playerId, IEntity playerEntity, IEntity killerEntity, notnull Instigator killer)
	{
		super.OnPlayerKilled(playerId, playerEntity, killerEntity, killer);
		
		//~ Create instigator context data to determine what the relation is between victim and killer and control types of the victim and killer
		SCR_InstigatorContextData instigatorContextData = new SCR_InstigatorContextData(playerId, playerEntity, killerEntity, killer);
		
		//~ Send on player killed event
		m_OnPlayerKilled.Invoke(instigatorContextData);
	
		
		// RespawnSystemComponent is not a SCR_BaseGameModeComponent, so for now we have to
		// propagate these events manually. 
		if (IsMaster())
			m_pRespawnSystemComponent.OnPlayerKilled_S(playerId, playerEntity, killerEntity, killer);

		// Dispatch events to children components
		foreach (SCR_BaseGameModeComponent comp : m_aAdditionalGamemodeComponents)
		{
			comp.OnPlayerKilled(instigatorContextData);
		}

		#ifdef GMSTATS
		if (IsGameModeStatisticsEnabled())
			SCR_GameModeStatistics.RecordDeath(playerId, playerEntity, killerEntity, killer);
		#endif
		
		//~ Call extended OnPlayerKilled
		OnPlayerKilledEx(instigatorContextData);
	}
	
	//------------------------------------------------------------------------------------------------
	//! Extended OnPlayer Kill, called after BaseGamemode has executed the OnPlayerKilled
	//! Param[in] instigatorContextData Instigator context data of the killer and victim
	protected void OnPlayerKilledEx(notnull SCR_InstigatorContextData instigatorContextData);
	
	//------------------------------------------------------------------------------------------------
	//! Called after player kill behaviour is handled by a component overriding the generic logic.
	protected void OnPlayerKilledHandled(int playerId, IEntity playerEntity, IEntity killerEntity, notnull Instigator killer)
	{
		foreach (SCR_BaseGameModeComponent comp : m_aAdditionalGamemodeComponents)
			comp.OnPlayerKilledHandled(playerId, playerEntity, killerEntity, killer);
	}
	
	//------------------------------------------------------------------------------------------------
	protected /*override*/ void OnPlayerDeleted(int playerId, IEntity player)
	{
		// RespawnSystemComponent is not a SCR_BaseGameModeComponent, so for now we have to
		// propagate these events manually. 
		if (IsMaster())
			m_pRespawnSystemComponent.OnPlayerDeleted_S(playerId);

		//super.OnPlayerDeleted(playerId, player);
		m_OnPlayerDeleted.Invoke(playerId, player);

		// Dispatch events to children components
		foreach (SCR_BaseGameModeComponent comp : m_aAdditionalGamemodeComponents)
		{
			comp.OnPlayerDeleted(playerId, player);
		}
	}

	//------------------------------------------------------------------------------------------------
	/*!
		Called when player role changes.
		\param playerId Player whose role is being changed.
		\param roleFlags Roles as a flags
	*/
	protected override void OnPlayerRoleChange(int playerId, EPlayerRole roleFlags)
	{
		super.OnPlayerRoleChange(playerId, roleFlags);
		m_OnPlayerRoleChange.Invoke(playerId, roleFlags);

		// Dispatch events to children components
		foreach (SCR_BaseGameModeComponent comp : m_aAdditionalGamemodeComponents)
		{
			comp.OnPlayerRoleChange(playerId, roleFlags);
		}
	}

	//------------------------------------------------------------------------------------------------
	/*!
		Called once loading of all entities of the world have been finished (still within the loading)
		\param world Loaded world
	*/
	override event void OnWorldPostProcess(World world)
	{
		super.OnWorldPostProcess(world);
		m_OnWorldPostProcess.Invoke(world);

		foreach (SCR_BaseGameModeComponent comp : m_aAdditionalGamemodeComponents)
		{
			comp.OnWorldPostProcess(world);
		}
	};

	//------------------------------------------------------------------------------------------------
	/*
		When a controllable entity is spawned, this event is raised.
		\param entity Spawned entity that raised this event
	*/
	protected override void OnControllableSpawned(IEntity entity)
	{
		super.OnControllableSpawned(entity);
		m_OnControllableSpawned.Invoke(entity);

		foreach (SCR_BaseGameModeComponent comp : m_aAdditionalGamemodeComponents)
		{
			comp.OnControllableSpawned(entity);
		}
	}

	//------------------------------------------------------------------------------------------------
	/*
		When a controllable entity is destroyed, this event is raised.
		\param entity Destroyed entity that raised this event
		\param killerEntity Entity that killed the entity (can be null)
		\param killer Instigator entity that destroyed our victim
	*/
	protected override void OnControllableDestroyed(IEntity entity, IEntity killerEntity, notnull Instigator instigator)
	{
		super.OnControllableDestroyed(entity, killerEntity, instigator);
		
		//~ Create instigator context data to determine what the relation is between victim and killer and control types of the victim and killer
		SCR_InstigatorContextData instigatorContextData = new SCR_InstigatorContextData(-1, entity, killerEntity, instigator);
		m_OnControllableDestroyed.Invoke(instigatorContextData);
		
		#ifdef ENABLE_DIAG
		//~ Debug print to see death types of characters
		if (ChimeraCharacter.Cast(entity) && IsMaster())
			Print("Character Killed: " + typename.EnumToString(SCR_ECharacterDeathStatusRelations, instigatorContextData.GetVictimKillerRelation()) + " | Victim: " + typename.EnumToString(SCR_ECharacterControlType, instigatorContextData.GetVictimCharacterControlType()) + " (id: " + instigatorContextData.GetVictimPlayerID() + ") | Killer: " + typename.EnumToString(SCR_ECharacterControlType, instigatorContextData.GetKillerCharacterControlType()) + " (id: " + instigatorContextData.GetKillerPlayerID() + ")");
		#endif
		
		foreach (SCR_BaseGameModeComponent comp : m_aAdditionalGamemodeComponents)
		{
			comp.OnControllableDestroyed(instigatorContextData);	
		}
		
		//~ Call extended OnControllableDestroyed
		OnControllableDestroyedEx(instigatorContextData);
	}
	
	//------------------------------------------------------------------------------------------------
	//! Extended controlled character Kill or destroyed, called after BaseGamemode has executed the OnControllableDestroyed
	//! Param[in] instigatorContextData Instigator context data of the killer and victim
	protected void OnControllableDestroyedEx(notnull SCR_InstigatorContextData instigatorContextData);

	//------------------------------------------------------------------------------------------------
	/*
		Prior to a controllable entity being DELETED, this event is raised.
		Controllable entity is such that has BaseControllerComponent and can be
		possessed either by a player, an AI or stay unpossessed.
		\param entity Entity about to be deleted
	*/
	protected override void OnControllableDeleted(IEntity entity)
	{
		super.OnControllableDeleted(entity);
		m_OnControllableDeleted.Invoke(entity);

		foreach (SCR_BaseGameModeComponent comp : m_aAdditionalGamemodeComponents)
		{
			comp.OnControllableDeleted(entity);
		}
		
		// Ensure that controlled entity is a player
		int playerId = GetGame().GetPlayerManager().GetPlayerIdFromControlledEntity(entity);
		if (playerId > 0)
			OnPlayerDeleted(playerId, entity);
	}
	
	
	//------------------------------------------------------------------------------------------------
	/*!
		Authority:
			Callback raised when the spawn process failed.
			In cases where an entity is spawned, it might be desirable to dispose of it or handle specific
			related game logic if it e.g. cannot be prepared, or assigned to the target player.
			\param entity The entity that should be spawned, but could not be given over (prepared, assigned, ..)
	*/
	void OnSpawnPlayerEntityFailure_S(SCR_SpawnRequestComponent requestComponent, SCR_SpawnHandlerComponent handlerComponent, IEntity entity, SCR_SpawnData data, SCR_ESpawnResult reason)
	{
		foreach (SCR_BaseGameModeComponent component : m_aAdditionalGamemodeComponents)
			component.OnSpawnPlayerEntityFailure_S(requestComponent, handlerComponent, entity, data, reason);
	}
	
	//------------------------------------------------------------------------------------------------
	/*!
		Authority:
			Callback raised when the spawn system causes provided player's controlled entity to change.
	*/
	void OnPlayerEntityChanged_S(int playerId, IEntity previousEntity, IEntity newEntity)
	{
	}
	
	/*!
		Authority only:
			During the spawn process (after validation pass), the SCR_SpawnHandlerComponent can opt to prepare
			spawned entity. This process first happens on affiliated SCR_SpawnHandlerComponent and if it succeeds,
			it additionally raises this method, which can prepare entity on a global scale. (E.g. game mode logic)
			Preparation can still fail (e.g. desire to seat a character, but an error occurs) and by returning false
			the sender is informed of such failure and can respond accordingly.
			\param requestComponent Instigator of the request.
			\param handlerComponent Handler that processed the request.
			\param data The payload of the request.
			\param entity Spawned (or generally assigned) entity to be prepared.
			\return True on success (continue to next step), fail on failure (terminate spawn process).
	*/
	bool PreparePlayerEntity_S(SCR_SpawnRequestComponent requestComponent, SCR_SpawnHandlerComponent handlerComponent, SCR_SpawnData data, IEntity entity)
	{
		// Example(s):
		//	- load some data from storage, fill inventory with stored items
		//  - apply loaded data by setting provided entity to bleed for a certain amount
		//  - drop character unconscious?
		
		foreach (SCR_BaseGameModeComponent component : m_aAdditionalGamemodeComponents)
		{
			if (!component.PreparePlayerEntity_S(requestComponent, handlerComponent, data, entity))
				return false;
		}
		
		// Entity preparation has succeeded
		return true;
	}
	
	//------------------------------------------------------------------------------------------------
	/*!
		Authority only:
			Whenever a SCR_SpawnHandlerComponent processes a spawn request and finished the finalization stage
			(awaits finalization, passes control to client) this method is called. This is the final step in the respawn
			process and after this point the owner of SCR_SpawnRequestComponent is spawned.
			\param requestComponent Instigator of the request.
			\param handlerComponent Handler that processed the request.
			\param data The payload of the request.
			\param entity Spawned (or generally assigned) entity.
	*/
	void OnPlayerSpawnFinalize_S(SCR_SpawnRequestComponent requestComponent, SCR_SpawnHandlerComponent handlerComponent, SCR_SpawnData data, IEntity entity)
	{
		SCR_SpawnPointSpawnData spawnPointData = SCR_SpawnPointSpawnData.Cast(data);
		if (spawnPointData)
		{
			OnPlayerSpawnOnPoint_S(requestComponent, handlerComponent, entity, spawnPointData);
		}
		
		foreach (SCR_BaseGameModeComponent component : m_aAdditionalGamemodeComponents)
			component.OnPlayerSpawnFinalize_S(requestComponent, handlerComponent, data, entity);

		SCR_PlayerLoadoutComponent loadoutComp = SCR_PlayerLoadoutComponent.Cast(requestComponent.GetPlayerController().FindComponent(SCR_PlayerLoadoutComponent));
		if (!SCR_PossessSpawnData.Cast(data) // hotfix when player is spawned through game master, their loadout would change to the saved loadout
			&& loadoutComp && loadoutComp.GetLoadout())
			loadoutComp.GetLoadout().OnLoadoutSpawned(GenericEntity.Cast(entity), requestComponent.GetPlayerId());		
		
		m_OnPlayerSpawned.Invoke(requestComponent.GetPlayerId(), entity);
	}
	
	//------------------------------------------------------------------------------------------------
	/*!
		Authority:
			Callback raised when the spawn system causes provided player to spawn with an entity at given spawn point.
			See: SCR_BaseGameMode.OnPlayerSpawnFinalize_S
	*/
	void OnPlayerSpawnOnPoint_S(SCR_SpawnRequestComponent requestComponent, SCR_SpawnHandlerComponent handlerComponent, IEntity entity, SCR_SpawnPointSpawnData spawnPointData)
	{
		SCR_PlayerLoadoutComponent loadoutComp = SCR_PlayerLoadoutComponent.Cast(requestComponent.GetPlayerController().FindComponent(SCR_PlayerLoadoutComponent));
 		
		//~ Update supplies of base or spawn point
		ConsumeSuppliesOnPlayerSpawn_S(requestComponent.GetPlayerId(), spawnPointData.GetSpawnPoint(), loadoutComp);
	}
	
	//------------------------------------------------------------------------------------------------
	//~ Consume supplies for spawning
	protected void ConsumeSuppliesOnPlayerSpawn_S(int playerID, IEntity spawnPoint, SCR_PlayerLoadoutComponent loadoutComp)
	{
		SCR_CampaignMilitaryBaseComponent base;
		SCR_ResourceComponent resourceComp;
		
		int spawnSupplyCost = 0;
		if (loadoutComp)
			spawnSupplyCost = SCR_ArsenalManagerComponent.GetLoadoutCalculatedSupplyCost(loadoutComp.GetLoadout(), false, playerID, null, spawnPoint, base, resourceComp);
 		
		if (spawnSupplyCost > 0)
		{
			if (base)
				base.AddSupplies(spawnSupplyCost * -1);
			else if (resourceComp)
				SCR_ResourceSystemHelper.ConsumeResources(resourceComp, spawnSupplyCost, false);
		}
	}
	
	//------------------------------------------------------------------------------------------------
	/*!
		Authority:
			Callback raised when provided player (SCR_PlayerLoadoutComponent.GetPlayerController()) has their loadout set.
	*/
	void OnPlayerLoadoutSet_S(SCR_PlayerLoadoutComponent loadoutComponent, SCR_BasePlayerLoadout loadout)
	{
	}
	
	//------------------------------------------------------------------------------------------------
	/*!
		Authority:
			Callback raised when provided player (SCR_PlayerFactionAffiliationComponent.GetPlayerController()) has their faction set.
	*/
	void OnPlayerFactionSet_S(SCR_PlayerFactionAffiliationComponent factionComponent, Faction faction)
	{
	}
	
	//------------------------------------------------------------------------------------------------
	/*!
		Authority:
			Override and implement logic for whether provided player can spawn.
			\param requestComponent The player request component instigating this spawn.
			\param handlerComponent The spawn handler component handling this spawn.
			\param data The request payload.
			\param[out] result Reason why respawn is disabled. Note that if returns true the reason will always be OK
			\return True when spawn is allowed, false otherwise. 
	*/
	bool CanPlayerSpawn_S(SCR_SpawnRequestComponent requestComponent, SCR_SpawnHandlerComponent handlerComponent, SCR_SpawnData data, out SCR_ESpawnResult result = SCR_ESpawnResult.SPAWN_NOT_ALLOWED)
	{
		if (m_RespawnTimerComponent) 
		{
			int playerId = requestComponent.GetPlayerId();
			
			// If player has not been enqueued yet, ignore the spawn timer
			if (m_RespawnTimerComponent.IsPlayerEnqueued(playerId))
			{
				float spawnPointTime = 0;
				if (data.IsInherited(SCR_SpawnPointSpawnData))
				{
					SCR_SpawnPointSpawnData spData = SCR_SpawnPointSpawnData.Cast(data);
					spawnPointTime = spData.GetSpawnPoint().GetRespawnTime();
				}

				if (!m_RespawnTimerComponent.GetCanPlayerSpawn(playerId, spawnPointTime))
				{
					result = SCR_ESpawnResult.NOT_ALLOWED_TIMER;
					return false;
				}
			}
		}
		
		SCR_SpawnPointSpawnData spawnPointData = SCR_SpawnPointSpawnData.Cast(data);
		if (!spawnPointData)
			return true;
		
		//~ Check if spawn point has enough supplies
		SCR_CampaignMilitaryBaseComponent base;
		SCR_ResourceComponent resourceComp;
		
		int spawnSupplyCost = 0;
		
		SCR_PlayerLoadoutComponent loadoutComp = SCR_PlayerLoadoutComponent.Cast(requestComponent.GetPlayerController().FindComponent(SCR_PlayerLoadoutComponent));
		if (loadoutComp)
			spawnSupplyCost = SCR_ArsenalManagerComponent.GetLoadoutCalculatedSupplyCost(loadoutComp.GetLoadout(), false, requestComponent.GetPlayerId(), null, spawnPointData.GetSpawnPoint(), base, resourceComp);
		
		if (base)
		{
			//~ Check if there are enough supplies for base
			if (base.GetSupplies() < spawnSupplyCost)
			{
				result = SCR_ESpawnResult.NOT_ALLOWED_NOT_ENOUGH_SUPPLIES;
				return false;
			}
		}
		else if (resourceComp)
		{
			//~ Check if there are enough supplies for Resource comp
			float availableSupplies;
			if (SCR_ResourceSystemHelper.GetAvailableResources(resourceComp, availableSupplies))
			{
				if (availableSupplies < spawnSupplyCost)
				{
					result = SCR_ESpawnResult.NOT_ALLOWED_NOT_ENOUGH_SUPPLIES;
					return false;
				}
			}
		}
		
		result = SCR_ESpawnResult.OK;
		return true;
	}

	//------------------------------------------------------------------------------------------------
	//! Returns remaining respawn time in seconds for given player
	int GetPlayerRemainingRespawnTime(int playerID)
	{
		// Respawn timers
		if (m_RespawnTimerComponent)
			return m_RespawnTimerComponent.GetPlayerRemainingTime(playerID);

		return 0;
	}

	//------------------------------------------------------------------------------------------------
	override bool RplSave(ScriptBitWriter writer)
	{
		EGameFlags gameFlags = GetGame().GetGameFlags();
		writer.WriteIntRange(gameFlags, 0, (EGameFlags.Last<<1)-1);

		return true;
	}

	//------------------------------------------------------------------------------------------------
	override bool RplLoad(ScriptBitReader reader)
	{
		EGameFlags gameFlags;
		reader.ReadIntRange(gameFlags, 0, (EGameFlags.Last<<1)-1);

		GetGame().SetGameFlags(gameFlags, true);

		return true;
	}

	#ifdef GAME_MODE_DEBUG
	
	//------------------------------------------------------------------------------------------------
	//! Draw diagnostic information about all available players.
	void Diag_DrawPlayersWindow()
	{
		//DbgUI.Begin("SCR_BaseGameMode: Players Diag");
		array<int> connectedPlayers = {};		
		GetGame().GetPlayerManager().GetPlayers(connectedPlayers);
		
		array<int> disconnectedPlayers = {};
		GetGame().GetPlayerManager().GetDisconnectedPlayers(disconnectedPlayers);	

		DbgUI.Begin("SCR_BaseGameMode: Connected players");
		{
			for (int i = 0, cnt = connectedPlayers.Count(); i < cnt; i++)
			{
				int playerId = connectedPlayers[i];
				Diag_DrawPlayerInfo(playerId);
			}
		}
		DbgUI.End();
		DbgUI.Begin("SCR_BaseGameMode: Disconnected players");
		{
			for (int i = 0, cnt = disconnectedPlayers.Count(); i < cnt; i++)
			{
				int playerId = disconnectedPlayers[i];
				Diag_DrawPlayerInfo(playerId);
			}
		}
		DbgUI.End();		
	}

	//------------------------------------------------------------------------------------------------
	//! Draw information about provided player (if valid).
	//! \param playerId
	void Diag_DrawPlayerInfo(int playerId)
	{
		string tmp = string.Format("Player %1: (name: %2)", playerId, GetGame().GetPlayerManager().GetPlayerName(playerId));
		array<string> extra = {};		
		
		// Fetch faction info (if present)
		SCR_FactionManager factionManager = SCR_FactionManager.Cast(GetGame().GetFactionManager());
		if (factionManager)
		{
			string factionKey = "None";
			Faction faction = factionManager.GetPlayerFaction(playerId);
			if (faction)
			{
				factionKey = faction.GetFactionKey();
			}
			
			extra.Insert(string.Format("Faction: %1", factionKey));
		}
		
		// Fetch loadout info (if present)
		SCR_LoadoutManager loadoutManager = GetGame().GetLoadoutManager();
		if (loadoutManager)
		{
			string loadoutKey = "None";
			SCR_BasePlayerLoadout loadout = loadoutManager.GetPlayerLoadout(playerId);
			if (loadout)
			{
				loadoutKey = loadout.GetLoadoutName();
			}
			
			extra.Insert(string.Format("Loadout: %1", loadoutKey));
		}
		
		// If any additional info is present, start formatting
		if (!extra.IsEmpty())
		{
			const string separator = "\n   ";
			for (int i = 0, count = extra.Count(); i < count; i++)
			{
				tmp += string.Format("%1%2", separator, extra[i] );
			}
		}
		
		DbgUI.Text(tmp);
	}

	//------------------------------------------------------------------------------------------------
	//! Draws information about controlled entities.
	void Diag_DrawControlledEntitiesWindow()
	{
		array<int> allPlayers = {};
		GetGame().GetPlayerManager().GetAllPlayers(allPlayers);
	
		DbgUI.Begin("SCR_BaseGameMode: Controlled Entities");	
		{
			for (int i = 0, cnt = allPlayers.Count(); i < cnt; i++)
			{
				int playerId = allPlayers[i];
				Diag_DrawControlledEntityInfo(playerId);
			}
		}
		DbgUI.End();
	}

	//------------------------------------------------------------------------------------------------
	//! Draws information about controlled entity of provided player (if any).
	//! \param playerId
	void Diag_DrawControlledEntityInfo(int playerId)
	{
		string tmp = string.Format("Player %1: (name: %2)", playerId, GetGame().GetPlayerManager().GetPlayerName(playerId));
		array<string> extra = {};
		
		// IsConnected?
		if (GetGame().GetPlayerManager().IsPlayerConnected(playerId))
		{
			extra.Insert("IsConnected: True");
		}
		else
			extra.Insert("IsConnected: False");
		
		// Controlled entity
		IEntity controlledEntity = GetGame().GetPlayerManager().GetPlayerControlledEntity(playerId);
		if (controlledEntity)
		{
			extra.Insert(string.Format("Entity: %1", controlledEntity));
			
			RplComponent rplComponent = RplComponent.Cast(controlledEntity.FindComponent(RplComponent));
			if (rplComponent)
			{
				extra.Insert(string.Format("RplId: %1", rplComponent.Id()));
			}
		}
		else
		{
			extra.Insert("Entity: None");
		}
		
		
		// If any additional info is present, start formatting
		if (!extra.IsEmpty())
		{
			const string separator = "\n   ";
			for (int i = 0, count = extra.Count(); i < count; i++)
			{
				tmp += string.Format("%1%2", separator, extra[i] );
			}
		}
		
		DbgUI.Text(tmp);
	}

	//------------------------------------------------------------------------------------------------
	//! Draws information about game mode component(s)
	void Diag_DrawComponentsWindow()
	{
		DbgUI.Begin("SCR_BaseGameMode: Components");
		{
			int numComponents = m_aAdditionalGamemodeComponents.Count();
			DbgUI.Text(string.Format("NumComponents: %1", numComponents));
			
			for (int i = 0; i < numComponents; i++)
			{
				Diag_DrawComponentInfo(i, m_aAdditionalGamemodeComponents[i]);
			}
		}
		DbgUI.End();
	}

	//------------------------------------------------------------------------------------------------
	//! Draw diagnostics for provided component (if any).
	void Diag_DrawComponentInfo(int index, SCR_BaseGameModeComponent component)
	{
		DbgUI.Text(string.Format("%1: %2", index, component));
	}

	//------------------------------------------------------------------------------------------------
	//!
	void Diag_DrawGameModeWindow()
	{
		DbgUI.Begin("SCR_BaseGameMode");
		{
			string elapsedTime = string.Format("Elapsed time: %1 s", GetElapsedTime());
			DbgUI.Text(elapsedTime);
			
			string running = string.Format("IsRunning: %1", IsRunning());
			DbgUI.Text(running);
			
			string state = string.Format("State: %1", SCR_Enum.GetEnumName(SCR_EGameModeState, GetState()));
			DbgUI.Text(state);
			
			string flags = string.Format("TestFlags: %1 (%2)", SCR_Enum.FlagsToString(EGameFlags, m_eGameState), m_eGameState);
			DbgUI.Text(flags);
			
			if (IsMaster())
			{
				DbgUI.Spacer(16);
				DbgUI.Text("Authority details:");
				
				float autoReloadDelay = GetAutoReloadDelay();
				if (autoReloadDelay > 0)
				{
					DbgUI.Text(string.Format("Auto reload: %1 seconds.", autoReloadDelay));
				}
				else
				{
					DbgUI.Text("Auto reload: Disabled.");
				}
				
				DbgUI.Spacer(16);
				
				if (DbgUI.Button("End Session"))
					EndGameMode(SCR_GameModeEndData.CreateSimple(EGameOverTypes.FACTION_DRAW));
				
				if (DbgUI.Button("Restart Session"))
					RestartSession();
			}
		}
		DbgUI.End();
	}
	#endif
	
	//------------------------------------------------------------------------------------------------
	//! Called once tasks are initialized
	void HandleOnTasksInitialized();

	//------------------------------------------------------------------------------------------------
	//! Enable or disable controls for the local client.
	//! \param enabled True to enable controls, false to disable controls over controlled entity.
	protected void SetLocalControls(bool enabled)
	{
		PlayerController playerController = GetGame().GetPlayerController();
		if (playerController)
		{
			IEntity controlledEntity = playerController.GetControlledEntity();
			if (controlledEntity)
			{
				ChimeraCharacter character = ChimeraCharacter.Cast(controlledEntity);
				if (character)
				{
					CharacterControllerComponent controller = character.GetCharacterController();
					if (controller)
					{
						bool doDisable = !enabled;
						controller.SetDisableWeaponControls(doDisable);
						controller.SetDisableMovementControls(doDisable);
					}
				}
			}
		}
	}

	#ifdef GM_AI_STATS
	private float m_fLastRecordTime;

	private float m_fLastFlushTime;
	private float m_fFlushRecordInterval = 10000; // 10s

	//------------------------------------------------------------------------------------------------
	private void UpdateStatistics(IEntity owner)
	{
		// Create new records only ever so often
		float timeStamp = owner.GetWorld().GetWorldTime();
		if (timeStamp > m_fLastRecordTime + SCR_GameModeStatistics.RECORD_INTERVAL_MS)
		{
			m_fLastRecordTime = timeStamp;

			#ifdef GMSTATS
			PlayerManager pm = GetGame().GetPlayerManager();
			array<int> players = {};
			pm.GetPlayers(players);

			foreach (int pid : players)
			{
				IEntity ctrlEnt = pm.GetPlayerControlledEntity(pid);
				if (!ctrlEnt)
					continue;

				SCR_GameModeStatistics.RecordMovement(ctrlEnt, pid);
			}
			#endif
			#ifdef AISTATS
			auto aiWorld = SCR_AIWorld.Cast(GetGame().GetAIWorld());
			if (aiWorld)
			{
				array<AIAgent> aiAgents = {};
				aiWorld.GetAIAgents(aiAgents);
				foreach (AIAgent agent : aiAgents)
				{		
					SCR_GameModeStatistics.RecordAILOD(agent);
				}
			}
			#endif
		}

		// Flush data if recording in smaller intervals
		if (timeStamp > m_fLastFlushTime + m_fFlushRecordInterval)
		{
			m_fLastFlushTime = timeStamp;
			if (IsGameModeStatisticsEnabled())
			{
				if (SCR_GameModeStatistics.IsRecording())
					SCR_GameModeStatistics.Flush();
			}
		}
	}
	#endif

	//------------------------------------------------------------------------------------------------
	//!
	//! \return true if controls for local player should be disabled.
	bool GetAllowControls()
	{
		return m_bAllowControls;
	}

	//------------------------------------------------------------------------------------------------
	//!
	//! \return the desired target for the authority of whether controls should be disabled or not, based on the current state, if any.
	protected bool GetAllowControlsTarget()
	{
		SCR_BaseGameModeStateComponent stateComponent = GetStateComponent(GetState());
		if (stateComponent)
			return stateComponent.GetAllowControls();

		return true;
	}

	//------------------------------------------------------------------------------------------------
	//! \return state component for provided state or null if none.
	SCR_BaseGameModeStateComponent GetStateComponent(SCR_EGameModeState state)
	{
		SCR_BaseGameModeStateComponent stateComponent;
		if (m_mStateComponents.Find(state, stateComponent))
			return stateComponent;

		return null;
	}
	
	//------------------------------------------------------------------------------------------------
	/*!
	Pause or unpause game. Prevent unpause if it's paused by GM. 
	\param[in] pause		True - will pause game, False - will continue game 
	\param[in] reason		From which system is pause called.
	\return 				True if pause/unpause was done. False if changing pause state is blocked by pause reason or game can't be saved.
	*/
	bool PauseGame(bool pause, SCR_EPauseReason reason = SCR_EPauseReason.SYSTEM)
	{
		if (!CanBePaused())
			return false;
		
		if (pause)
			m_ePauseReasons = m_ePauseReasons | reason;
		else
			m_ePauseReasons = m_ePauseReasons &~ reason;
			
		ChimeraWorld world = GetGame().GetWorld();
		world.PauseGameTime(m_ePauseReasons != 0);
		
		return !pause && m_ePauseReasons != 0 || pause;
	}
	
	//------------------------------------------------------------------------------------------------
	//! Return true if client is offline
	bool CanBePaused()
	{
		return !Replication.IsRunning();
	}


	//------------------------------------------------------------------------------------------------
	// TODO@AS: Small thing, but get rid of m_fTimeElapsed and use
	// some sort of m_fStartTime and Replication.Time() instead!
	override void EOnFrame(IEntity owner, float timeSlice)
	{		
		#ifdef GM_AI_STATS
		if (IsGameModeStatisticsEnabled())
			UpdateStatistics(owner);
		#endif
		
		if (m_bUseSpawnPreload && m_SpawnPreload)
			HandleSpawnPreload(timeSlice);

		// Allow to accumulate time in pre-game too.
 		SCR_BaseGameModeStateComponent pregameComponent = GetStateComponent(SCR_EGameModeState.PREGAME);
		bool isPregame = GetState() == SCR_EGameModeState.PREGAME;
		// Increment elapsed time on every machine
		bool isRunning = IsRunning();
		if (isRunning || isPregame)
		{
			bool canAdvanceTime = true;

			// Check if any players are present; if using "advance time requires players"
			// we will only advance the time if at least one player is present;
			// this is fairly easy to do, because dedicated (headless) server does not
			// count as a player in the PlayerManager
			if (m_bAdvanceTimeRequiresPlayers)
			{
				int playerCount = GetGame().GetPlayerManager().GetPlayerCount();
				if (playerCount == 0)
					canAdvanceTime = false;
			}

			if (canAdvanceTime)
				m_fTimeElapsed += timeSlice;
		}

		// As the authority make corrections as needed
		if (IsMaster())
		{
			if (m_fTimeElapsed >= m_fLastTimeCorrection + m_fTimeCorrectionInterval)
			{
				Replication.BumpMe();
				m_fLastTimeCorrection = m_fTimeElapsed;
			}

			// Transition from pre-game to game if possible
			// Either fully automatic transition (no component)
			// or state-driven transition based on component logic
			if (isPregame && (!pregameComponent || pregameComponent.CanAdvanceState(SCR_EGameModeState.GAME)))
			{
				if (CanStartGameMode())
					StartGameMode();
			}
			else
			{
				// Time limit end game transition to post-game if possible
				if (IsRunning())
				{
					SCR_BaseGameModeStateComponent gameState = GetStateComponent(SCR_EGameModeState.GAME);
					if (gameState && gameState.CanAdvanceState(SCR_EGameModeState.POSTGAME))
					{
						// Clamp time to maximum
						m_fTimeElapsed = Math.Clamp(m_fTimeElapsed, 0, gameState.GetDuration());

						// Terminate session
						SCR_GameModeEndData data = SCR_GameModeEndData.CreateSimple(EGameOverTypes.EDITOR_FACTION_DRAW); // TODO: Once FACTION_DRAW or TIME_LIMIT works..
						EndGameMode(data);
					}
				}
			}

			// Update controls state
			bool shouldAllowControls = GetAllowControlsTarget();
			if (shouldAllowControls != m_bAllowControls)
			{
				m_bAllowControls = shouldAllowControls;
				Replication.BumpMe();
			}
		}


		// Should we disable local player controls?
		bool allowControls = GetAllowControls();
		SetLocalControls(allowControls);

		#ifdef GAME_MODE_DEBUG
		if (DiagMenu.GetBool(SCR_DebugMenuID.DEBUGUI_GAME_MODE))
		{
			Diag_DrawGameModeWindow();
			Diag_DrawComponentsWindow();
			Diag_DrawPlayersWindow();
			Diag_DrawControlledEntitiesWindow();			
		}
		#endif
	}

	//------------------------------------------------------------------------------------------------
	override void EOnInit(IEntity owner)
	{
		// Set Test Game Flags
		#ifdef WORKBENCH
			if (GetGame().GetWorldEntity() && !GetGame().AreGameFlagsObtained())
			{
				GetGame().SetGameFlags(m_eTestGameFlags, false);
			}
		#endif
		
		//~ Remove any duplicate entries
		if (m_aDisabledResourceTypes.IsEmpty())
		{
			//~ TODO: Make this cleaner
			
			set<EResourceType> duplicateRemoveSet = new set<EResourceType>();
			
			foreach (EResourceType resourceType : m_aDisabledResourceTypes)
			{
				duplicateRemoveSet.Insert(resourceType);
			}
			
			m_aDisabledResourceTypes.Clear();
			foreach (EResourceType resourceType : duplicateRemoveSet)
			{
				m_aDisabledResourceTypes.Insert(resourceType);
			}
		}

		// Find required components
        m_RplComponent = RplComponent.Cast(owner.FindComponent(RplComponent));
		m_pRespawnSystemComponent = SCR_RespawnSystemComponent.Cast(owner.FindComponent(SCR_RespawnSystemComponent));		
		m_RespawnTimerComponent = SCR_RespawnTimerComponent.Cast(owner.FindComponent(SCR_RespawnTimerComponent));
		m_ScoringSystemComponent = SCR_BaseScoringSystemComponent.Cast(owner.FindComponent(SCR_BaseScoringSystemComponent));
		m_pGameModeHealthSettings = SCR_GameModeHealthSettings.Cast(owner.FindComponent(SCR_GameModeHealthSettings));

		if (!m_RplComponent)
			Print("SCR_BaseGameMode is missing RplComponent!", LogLevel.ERROR);
		if (!m_pRespawnSystemComponent)
			Print("SCR_BaseGameMode is missing SCR_RespawnSystemComponent!", LogLevel.WARNING);
		
		if (!m_aAdditionalGamemodeComponents)
			m_aAdditionalGamemodeComponents = new array<SCR_BaseGameModeComponent>();

		array<Managed> additionalComponents = new array<Managed>();
		int count = owner.FindComponents(SCR_BaseGameModeComponent, additionalComponents);

		m_aAdditionalGamemodeComponents.Clear();
		for (int i = 0; i < count; i++)
		{
			SCR_BaseGameModeComponent comp = SCR_BaseGameModeComponent.Cast(additionalComponents[i]);
			m_aAdditionalGamemodeComponents.Insert(comp);
		}

		// Find and sort state components
		array<Managed> stateComponents = new array<Managed>();
		int stateCount = owner.FindComponents(SCR_BaseGameModeStateComponent, stateComponents);
		for (int i = 0; i < stateCount; i++)
		{
			SCR_BaseGameModeStateComponent stateComponent = SCR_BaseGameModeStateComponent.Cast(stateComponents[i]);
			SCR_EGameModeState state = stateComponent.GetAffiliatedState();
			// Invalid state
			if (state < 0)
			{
				Print("Skipping one of SCR_BaseGameStateComponent(s), invalid affiliated state!", LogLevel.ERROR);
				continue;
			}

			if (m_mStateComponents.Contains(state))
			{
				string stateName = SCR_Enum.GetEnumName(SCR_EGameModeState, state);
				Print("Skipping one of SCR_BaseGameStateComponent(s), duplicate component for state: " + stateName + "!", LogLevel.ERROR);
				continue;
			}

			m_mStateComponents.Insert(state, stateComponent);
		}
	}
	
	/*
		Preload handling
	*/

	//------------------------------------------------------------------------------------------------
	OnPreloadFinishedInvoker GetOnPreloadFinished()
	{
		if (!m_OnPreloadFinished)
			m_OnPreloadFinished = new OnPreloadFinishedInvoker();
		
		return m_OnPreloadFinished;
	}

	//------------------------------------------------------------------------------------------------
	//!
	//! \param position
	void StartSpawnPreload(vector position)
	{
		m_SpawnPreload = SCR_SpawnPreload.PreloadSpawnPosition(position);
		if (!m_SpawnPreload && m_OnPreloadFinished)
			m_OnPreloadFinished.Invoke();

	}

	//------------------------------------------------------------------------------------------------
	protected void HandleSpawnPreload(float timeSlice)
	{
		bool finished = m_SpawnPreload.Update(timeSlice);
		if (finished)
		{
			m_SpawnPreload = null;
			if (m_OnPreloadFinished)
				m_OnPreloadFinished.Invoke();
		}
	}	
	
	//------------------------------------------------------------------------------------------------
	// constructor
	void SCR_BaseGameMode(IEntitySource src, IEntity parent)
	{
		#ifdef GAME_MODE_DEBUG
		if (!s_DebugRegistered)
		{
			DiagMenu.RegisterMenu(SCR_DebugMenuID.DEBUGUI_GAME_MODE_MENU, "GameMode", "");
			DiagMenu.RegisterBool(SCR_DebugMenuID.DEBUGUI_GAME_MODE, "", "Game Mode", "GameMode");
			s_DebugRegistered = true;
		}
		#endif

		Activate();
		SetEventMask(EntityEvent.INIT | EntityEvent.FRAME);
	}

	//------------------------------------------------------------------------------------------------
	// destructor
	void ~SCR_BaseGameMode()
	{
		#ifdef GAME_MODE_DEBUG
			DiagMenu.Unregister(SCR_DebugMenuID.DEBUGUI_GAME_MODE);
			s_DebugRegistered = false;
		#endif

		#ifdef GM_AI_STATS
		if (SCR_GameModeStatistics.IsRecording())
			SCR_GameModeStatistics.StopRecording();
		#endif
	}

	#ifdef GM_AI_STATS
	//------------------------------------------------------------------------------------------------
	//! Should gamemode diagnostic statistics be enabled?
	private bool IsGameModeStatisticsEnabled()
	{
		// not authority
		if (m_RplComponent && !m_RplComponent.IsMaster())
			return false;

		return GetGame().InPlayMode();
	}
	#endif
}
